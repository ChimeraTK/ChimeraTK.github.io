<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: Technical specification: Exception handling for device runtime errors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec_execption_handling.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Technical specification: Exception handling for device runtime errors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>DRAFT VERSION, WRITE-UP IN PROGRESS!</b></p>
<h1><a class="anchor" id="spec_execptionHandling_intro"></a>
Introduction</h1>
<p>Exceptions are handled by ApplicationCore in a way that the application developer does not need to care much about it.</p>
<p>ChimeraTK::runtime_error exceptions are caught by the framework and are reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>. The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> handles this exception and periodically tries to open the device. Communication with the faulty device is blocked or delayed until the device is functional again. In case of several devices only the faulty device is blocked. Faulty devices do not prevent the application from starting, only the parts of the application that depend on the fault device are waiting for the device to come up.</p>
<p>Input variables of ApplicationModules which cannot be read due to a faulty device will set and propagate the DataValidity::faulty flag (see also <a class="el" href="spec_data_validity_propagation.html">spec_dataValidityPropagation</a>).</p>
<p>When the device is functional, it be (re)initialised by using application-defined initialisation handlers and also recover the last known values of its process variables.</p>
<h1><a class="anchor" id="spec_execptionHandling_behaviour"></a>
1. Behavioural description</h1>
<ul>
<li>1.1 All ChimeraTK::runtime_error exceptions thrown by device register accessors are handled by the framework and are never exposed to user code in ApplicationModules.</li>
<li>1.2 When an exception has been received (thrown by a device register accessor in an <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a>, <a class="el" href="class_chimera_t_k_1_1_fan_out.html" title="Base class for several implementations which distribute values from one feeder to multiple consumers...">FanOut</a> etc.):<ul>
<li>1.2.1 The exception status is published as a process variable together with an error message.<ul>
<li>1.2.1.1 The variable Devices/&lt;alias&gt;/</li>
</ul>
</li>
<li>1.2.1 Read operations will propagate the DataValidity::faulty to the owning module / fan out (without changing the actual value).</li>
<li>1.2.2 The normal module algorithm code will be continued, to allow this flag to propagate to the outputs in the same way as if it had been received through the process variable itself (c.f. 1.9).</li>
<li>1.2.3 Blocking read operations will block after the flag has been read and propagated once (i.e. on the second blocking read of the same accessor).</li>
<li>1.2.4 Non-blocking read operations (incl. readLatest) never block.</li>
<li>1.2.5 Asynchronous read operations behave analogue to 1.2.3: The TransferFuture, which was valid while the exception was received, is fulfilled once, the DataValidity::faulty is propaated to the owning module and the value is left unchanged. The TransferFuture will only be fulfilled again after the device has been recovered.</li>
<li>1.2.6 [TBD: proposed replacement for the next bullet point including sub-points, see discussion there] Write operations never block. In case of an exception (new or persisting), the actual write operation will be delayed until the device is functional and recovered again. The same mechanism as used for 1.3.1.2 is used here, hence the order of write operations is guaranteed across accessors, but only the latest written value of each accessor prevails. (*)</li>
<li>&lt;strike&gt;1.2.6 Write operations will block immediately until the device has been recovered and the write operation has been completed. [TBD: is this really a good idea? <b>COMMENT</b>: The order of write operations is still not guaranteed through the recovery accessors (which maybe should be changed), and blocking writes has some severe drawbacks. Not only in fan outs but also in normal ApplicationModules blocking writes will prevent propagation of DataValidity flags! Blocking writes might help if a sequence of values is written to the same register - this is not handled by the recovery accessor. But if a handshake register is read back in between the writes, the situation can already be handled properly (check DataValidity flag, restart sequence after recovery). Maybe blocking writes create more probelms then they solve!? On the other hand, how does the application then know that a write() has no effect yet? E.g. a PI controller might wind-up if actuator and sensor are on different devices and the actuator fails. Then again, how is this different a failing actuator hardware without breaking the communication? Some form of a status readback of the actuator again cures the situation. I think I am in favour of "fire-and-forget" writes.].&lt;/strike&gt;<ul>
<li>&lt;strike&gt;1.2.6.1 Write should not block in case of an exception for the outputs of <a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a> / <a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a>.&lt;/strike&gt;</li>
<li>&lt;strike&gt;1.2.6.2 According to <a class="el" href="spec_initial_value_propagation.html">spec_initialValuePropagation</a>, writes in ApplicationModules do not block before the first successful read in the main loop.&lt;/strike&gt;</li>
</ul>
</li>
<li>1.2.7 In case of exceptions, there is no guaranteed realtime behaviour, not even for "non-blocking" transfers. (*)</li>
</ul>
</li>
<li>1.3 The framework tries to resolve an exception state by periodically re-opening the faulty device.<ul>
<li>1.3.1 After successfully re-opening the device, a recovery procedure is executed before allowing any read/write operations from the AppliactionModules and FanOuts again. This recovery procedure involves:<ul>
<li>1.3.1.1 the execution of so-called initialisation handlers (cf. 1.3.2), and</li>
<li>1.3.1.2 restoring all registers that have been written since the start of the application with their latest values. The register values are restored in the same order they were written. [<b>NEW REQUIREMENT!</b>] (*)</li>
<li>1.3.1.3 Finally, Devices/&lt;alias&gt;/deviceBecameFunctional is written to inform any module subscribing this variable about the finished recovery. (*)</li>
</ul>
</li>
<li>1.3.2 Any number of initialisation handlers can be added to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> in the user code. Initialisation handlers are callback function which will be executed when a device is opened for the first time and after a device recovers from an exception, before any process variables are written. See <a class="el" href="class_chimera_t_k_1_1_device_module.html#ab30bf1b235913143d45bb5da7d84052c" title="Add initialisation handlers to the device. ">DeviceModule::addInitialisationHandler()</a>.</li>
</ul>
</li>
<li>1.4 The behaviour at application start (when all devices are still closed at first) is similar to the case of a later received exception. The only differences are mentioned in &lt;strike&gt;1.2.6.2 and&lt;/strike&gt; 1.4.2.<ul>
<li>1.4.1 Even if some devices are initially in a persisting error state, the part of the application which does not interact with the faulty devices starts and works normally.</li>
<li>1.4.2 Initial values are correctly propagated after a device is opened. See <a class="el" href="spec_initial_value_propagation.html">spec_initialValuePropagation</a>. Especially, no read function (even readNonBlocking/readLatest) will return before an initial value has been received.(*)</li>
</ul>
</li>
<li>1.5 Exception handling and DataValidity flag propagation is implemented such that it is transparent to a module whether it is directly connected to a device, or whether a fanout or another application module is in between.</li>
<li>1.6 ChimeraTK::logic_error exceptions are left unhandled and will terminate the application. These errors may only occur in the initialisation phase (up to the point where all devices are opened and initialised) and point to a severe configuration error which is not recoverable. (*)</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_behaviour_comments"></a>
(*) Comments</h2>
<ul>
<li>&lt;strike&gt;1.2.5.1 If writes in ThreadedFanOut/TriggerFanOut would block, the other receivers would no longer receive updates. The exact behaviour would not even be well-defined, since the order of writes in the fanouts is random.&lt;/strike&gt;</li>
<li>1.2.6 / 1.3.1.3 If timing is important for write operations (e.g. must not write a sequence of registers too fast), or if multiple values need to be written to the same register in sequence, the application cannot fully rely on the framework's recovery procedure. The framework hence provides the process variable Devices/&lt;alias&gt;/deviceBecameFunctional for each device, which will be written each time the recovery procedure is completed (cf. 1.3.1.3). ApplicationModules which implement such timed sequence need to receive this variable and restart the entire sequence after the recovery.</li>
<li>1.2.7 Even non-blocking read and write operations are not truely non-blocking, since they are still synchronous. The "non-blocking" guarantee only means that the operation does not block for an extended period of time until the fault state has been cleared. For the duration of the recovery procedure and of course for timeout periods these operations may still block.</li>
<li>1.3.1.2 For some applications, the order of writes may be important, e.g. if firmware expects this. Please note that the VersionNumber is insufficient as a sorting criteria, since many writes may have been done with the same VersionNumber (in an <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a>, the VersionNumber used for the writes is determined by the largest VersionNumber of the inputs).</li>
<li>1.4.2 DataValidity::faulty is set at first by default, so there is no need to propagate this flag initially. To prevent race conditions and undefined behaviour, it even needs to be made sure that the flag is not propagated unnecessarily. See also <a class="el" href="spec_initial_value_propagation.html">spec_initialValuePropagation</a>.</li>
<li>1.6 In future, maybe logic_errors are also handled, so configuration errors can nicely be presented to the control system. This may be important especially since logic_errors may depend also on the configuration of external components (devices). If e.g. a device is changed (e.g. device is another control system application which has been modified), logic_errors may be thrown in the recovery phase, despite the device had been successfully initialsed previously.</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_high_level_implmentation"></a>
2. High-level description of the implementation</h1>
<ul>
<li>2.1. A so-called <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> is placed around all device register accessors.<ul>
<li>2.1.1 A second, undecorated copy of each device register accessor is used as a so-called recoveryAccessor by the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> and the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>. These recoveryAccessor are used to correctly set the values of registers when the device is opened for the first time and after a device is recovered from an exception. (*)</li>
<li>2.1.2 An <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> for an input knows its DataFaultCounter, which lives in the <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> or fanout that reads the input. Like this it can propagate the DataValidity flag. Outputs do not send DataValidity faulty in case of exceptions (see <a class="el" href="spec_data_validity_propagation.html">spec_dataValidityPropagation</a>). [<b>COMMENT</b>: I think this is not necessary. The <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> simply has to return the right data validity flag, which will be propagated in the same way as in <a class="el" href="spec_data_validity_propagation.html">spec_dataValidityPropagation</a>. No special treatment required for exceptions!]</li>
</ul>
</li>
<li>2.2. <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>:<ul>
<li>2.2.1 The application always starts with all devices as closed. For each device, the initial value for Devices/&lt;alias&gt;/status is set to 1 and the initial value for Devices/&lt;alias&gt;/message is set to an error that the device has not been opened yet (the message will be overwritten with the real error message if the first attempt to open fails, see 2.2.3.1).</li>
<li>2.2.2 The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> takes care that ExceptionHandlingDecorators initally do not perform any read or write operations, but block. This happens before running any prepare() of an <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a>, where the first write calls to ExceptionHandlingDecorators are done.</li>
<li>2.2.3 In the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread, the following procedure is executed (in a loop until termination):<ul>
<li>2.2.3.1 The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> tries to open the device until it succeeds. (*)<ul>
<li>2.2.3.1.1 If the very first attempt to open the device since the application start fails, the error message of the exception is used to overwrite the content of Devices/&lt;alias&gt;/message. Otherwise error messages of exceptions thrown by Device::open() are not visible.</li>
</ul>
</li>
<li>2.2.3.2 Device is initialised by iterating initialisationHandlers list. If there is an exception, update Devices/&lt;alias&gt;/message with the error message and go back to 2.2.3.1. (*)</li>
<li>2.2.3.3 The list of reported exceptions is cleared. (*)</li>
<li>2.2.3.4 All valid (*) recovery accessors are written in the same order they were originally written [<b>NEW REQUIREMENT! see 1.4.2</b>]. If there is an exception, update Devices/&lt;alias&gt;/message with the error message and go back to 2.2.3.1. (*)</li>
<li>2.2.3.5 Devices/&lt;alias&gt;/status is set to 0 and Devices/&lt;alias&gt;/message is set to an empty string.</li>
<li>2.2.3.6 <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> allows that ExceptionHandlingDecorators execute reads and writes.</li>
<li>2.2.3.7 All blocked read and write operations (from 2.5.3) are notified.(*)</li>
<li>2.2.3.8 The DeviceModuleThread waits for the next reported exception.</li>
<li>2.2.3.9 An exception is received.</li>
<li>2.2.3.10 Devices/&lt;alias&gt;/status is set to 1 and Devices/&lt;alias&gt;/message is set to the first received exception message.</li>
<li>2.2.3.11 From this point on, all ExceptionHandlingDecorators for this device must block new read and write operations from starting (see also 2.2.2 and 2.2.3.6).</li>
<li>2.2.3.11 The device module waits until all running read and write operations of ExceptionHandlingDecorators have ended. (*)</li>
<li>2.2.3.12 The thread goes back to 2.2.3.1 and tries to re-open the device.</li>
</ul>
</li>
</ul>
</li>
<li>2.3. ApplicationModule/FanOuts with ExceptionHandlingDecorators:<ul>
<li>2.3.3 As per 1.6, ExceptionHandlingDecorators will initially block all read operations until 2.2.3.6. Write operations are not blocking, but the written values are recorded in the recoveryAccessor and report an exception to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> (*).</li>
<li>2.3.4 When notified by the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> (cf. 2.2.3.7), all blocked ExceptionHandlingDecorators will unblock:<ul>
<li>2.3.4.1 write just continues (recovery accessor has done the write)</li>
<li>2.3.4.2 read/readNonBlocking/readLatest<ul>
<li>2.3.4.2.1 tells the DataFaultCounter that the device error has gone [<b>COMMENT</b> May not be necessary, see COMMENT in 2.1.2]</li>
<li>2.3.4.2.2 (re-)tries to get the value. Exceptions are handled in the same way as in normal read operations (see 2.3.6)</li>
</ul>
</li>
</ul>
</li>
<li>2.3.5 In the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>, all write calls always fill the value into the recoveryAccessors before trying to execute the real write. Like this, the recoveryAccessor always has the last value that should have been written to the device. All recoveryAccessors become valid over time (see comment for 2.2.3.4).<ul>
<li>2.3.5.1 If a write is not executed because the device is already faulty (from 2.2.2 or 2.2.3.11), the recoveryAccessor has to take care of this. In this case we always have to send another exception notification to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> to make sure that the new recovery value is not missed (avoid race condition). (*)</li>
</ul>
</li>
<li>2.3.6 The <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> will catch any runtime_error exception thrown in a read/write operation.</li>
<li>2.3.6.1. If it is a read operation the DataFaultCounter is informed that there was a device error. (*) [<b>COMMENT</b> May not be necessary, see COMMENT in 2.1.2]</li>
<li>2.3.6.2. The error is reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a></li>
<li>2.3.6.3. Action depending on the calling operation:<ul>
<li>write: blocks until the device is recovered. [<b>See discussion in 1.2</b>]</li>
<li>read: If the accessor has already seen its initial value, the first "blocking" read call returns immediately (remember DataValidity is set to faulty). The <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> remembers that it is in an exception state. The calling module thread will continue and propagate the data invalid flag. The second call will finally block. If there has not been an initial value yet, even the first call will block until it is available.</li>
<li>readNonBlocking / readLatest: will always return with data invalid flag (unless there has not been an initial value yet).</li>
<li>writeWithoutErrorBlocking: just returns (*)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_comments"></a>
(*) Comments</h2>
<ul>
<li>1.1 Possible future change: Output accessors can have the option not to have a recovery accessor. This is needed for instance for "trigger registers" which start an operation on the hardware. Also void registers don't have recovery accessors (once the void data type is supported).</li>
<li>2.3.3 This works in the same way in <a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a> (where the devices will never be opened) and <a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a> until the first device read operation of the <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a>. In theory, reporting the exception to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> would not be necessary in <a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a>, but when the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread is running in parallel it is necessarg to avoid a race condition. See 2.3.5.1.</li>
<li>2.3.1 Successful opening includes that the device reports isFunctional() as true.</li>
<li>2.3.2 and 2.3.4 Exceptions for re-initialisation and recovery will be reported once, but not if it occurs again before the device has completely recovered.</li>
<li>2.3.3 ExceptionHandlingDecorators must always first write the recovery accessor, then report an exception. As the device module clears the exceptions first, then processes the accessors, it is guaranteed that no value is missed. As a side effect it can be that a pending exception triggers an unnecessary recovery loop in the device module.</li>
<li>2.3.4 If a recovery accessors has not seen an initial value yet, it will not be written (see <a class="el" href="spec_initial_value_propagation.html">spec_initialValuePropagation</a>).</li>
<li>2.3.7 This is different from 2.2.6 because 2.2.6 affects accessors which want to perform a read or write, while 2.2.7 affects accessors that failed to do so and are waiting for the device to become available again. This is needed for two cases:<ul>
<li>1. A blocking write, where the recovery accessor has already done the job when the device if back to OK.</li>
<li>2. The first blocking read if the data has not seen the initial value yet, and retrieving it caused the exception.</li>
</ul>
</li>
<li>2.3.5 writeWithoutErrorBlocking is not mentioned because it never blocks. Although blocked by different mechanisms read/readNonBlocking/readLatest behave the same:<ul>
<li>read is either the second read call which is expected to deliver the next value, or any of the three are still waiting for the initial value. In any case they have to (re-)try reading.</li>
</ul>
</li>
<li>2.3.5.1 Basically after each update of the recovery accessor there has to be a valid write, or an exception has to be reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>, to make sure the value is seen by the device (unless the recovery accessor is updated before this happens).</li>
<li>2.5.1 increment the DataFaultCounter. See <a class="el" href="spec_data_validity_propagation.html">spec_dataValidityPropagation</a>.</li>
<li>2.5.3 The RecoveryAccessor has been updated before the failed write attempt and will write the value once the device has recovered.</li>
<li>2.6.2 The backend has to take care that all operations, also the reads with "waitForNewData", terminate when an exception is thrown, so recovery can take place (see 3.6).</li>
</ul>
<p><b>Asynchronous read</b></p><ul>
<li>The transfer future in readAsync() behaves like the normal read:<ul>
<li>The first call to hasNewData() returns true if an error occurred in the read transfer. <code>wait()</code> will return immediately with DataVality::faulty.</li>
<li>The second call to hasNewData() will return false until the device has recovered and there actually is new data. <code>wait()</code> will bock until then.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_implmentation_details"></a>
Implementation details</h1>
<p><b>3. DeviceAccess</b></p>
<p>Requirements to the DeviceAccess interface:</p>
<ul>
<li>3.1 Exceptions are reported in postRead()/postWrite()<ul>
<li>As the error itself always occurs in the read/write transfer, the TransferElement base class implements a mechanism to catch it and transfer the exception message into the post-read function, where it is re-thrown.</li>
<li>This is required for three reasons:<ul>
<li>1. A transfer must always be complete, i.e. preXxx and postXxx must always be called. This is for instance important in case a user buffer has been swapped out, and has to be swapped back in so the user buffer stays intact in the application. Letting the exception in doXxxTransfer through would break this. (This is DeviceAccess spec.)</li>
<li>2. The transfer groups calls xxxTransfer itself on a potentially exchanged hardware accessing element. All code using transfer groups would have to do exception handling itself, and the individual accessors would not behave according to this (ApplicationCore exception handling) specification when used with a transfer group. By throwing in postXxx the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> can handle it, and it automatically works with transfer groups.</li>
<li>3. Asynchronous reads are executing the transfer in a different thread anyway, and have to delay the throwing to postRead.</li>
</ul>
</li>
</ul>
</li>
<li>3.2 Before throwing, each backend must make sure that the actions in doPostRead() are completed such that the user buffer of a calling accessor is intact</li>
<li>3.3 postRead() and postWrite() take care that the bookkeeping of ongoing transfers is done correctly, even if the called doPostXxx actions throw.</li>
<li>3.4 The TransferType (read, readNonBlocking, readLatest, readAsync, write, writeDestructively) is known in postRead and postWrite, so a decorator or backend can do different actions if required.</li>
<li>3.5 postRead() must always be called, also for failed transfers and for readNonBlocking and readLatest if there was no new data.</li>
<li>3.6 If a backend / doXXXTransfer implementation throws, the backend must make sure that all pending transactions will terminate. Especially transfers which implement reading with watiForNewData must return with an error, because no new data will arrive because the device is broken. These transfers must be interruptible.</li>
<li>3.7 In the level closest to the hardware the exception will be caught in the transfer. postXxx() (without 'do') will raise the exception. In case of the decorator-like pattern, where the call is delegated, the doPostXxx() (with 'do') will throw because it is calls _impl-&gt;postXxx(). The postXxx() implementation in TransferElement must make sure that the bookkeeping in each layer is complete. If required it has to catch the exception from doPostXxx(), finish what needs to be done and re-throw.</li>
</ul>
<p><b>4. The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a></b></p>
<p>Interfaces:</p>
<ul>
<li><p class="startli">4.1 External interface</p>
<p class="startli">An error status and the last error message are automatically connected to the control system for each device</p><ul>
<li>/Devices/{AliasName}/message</li>
<li>/Devices/{AliasName}/status</li>
</ul>
<p class="startli">Implements 2.1, 2.3.5, 2.6.1</p>
</li>
<li>4.2 Internal interface to the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a><ul>
<li>4.2.1 A thread safe function <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception. ">DeviceModule::reportException()</a> (implements 2.5.2). It does not block but only puts the exception into a lock-free queue.</li>
<li>4.2.2 A blocking way to wait for the device to become available after reporting the exception (implements 2.3.7 and 2.4.1) (as a response that report exception has been processed).</li>
<li>4.2.3 A shared mutex to prevent read and write operations before the device has been initialised (implements 1.b, 2.1, 2.3.6 and 2.6.1)</li>
<li>4.2.4 A function to add recoveryAccessors (implements 1.g)</li>
<li>4.2.5 A shared mutex to protect the recovery accessors</li>
<li>4.2.6 A counter of active transfers</li>
</ul>
</li>
</ul>
<p>Comments:</p>
<ul>
<li>4.2.1 A user/application can also report device errors calling DeviceModue::reportException(). This allows to for instance to write a watchdog module which is monitoring a reference register, and puts the whole device into an exception state (incl. automatic message to the CS, propagation of the DataValidity::faulty flag and recovery).</li>
<li>4.2.2 Currently implemented as a condition variable</li>
<li>4.2.2 FIXME We might also need a way to wait until the device module has seen the exception, but not recovered yet. But if it is already recovering this might take a while, so it would effectively be the same. Not clear at this moment.</li>
<li>4.2.3 Read/write operations must hold a shared lock before starting the actual read/write. This is implemented in the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>. As the lock is shared, parallel write operations don't block each other inside application core. While recovering, the device module will hold an exclusive lock.</li>
<li>4.2.5 As the recovery accessors are filled in the <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> threads (or fanouts), but the writing is taking place in the device module thread, the recovery accessor's user buffer must be protected with a mutex. Again, a shared mutex is used so normal write operations can run in parallel and don't interfere with each other (each one only touches its own buffer), and the write, which touches all buffers holds an exclusive lock.</li>
<li>4.2.6 The counter is needed so the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> knows when no transfer will access the device, and the recovery accessors can be used. If the accessors would hold the shared lock, they could dead-lock each other in asynchronous transfers if accessor A holds the lock while waiting for accessor B to finish. But B is waiting for the device to recover which cannot happen because A is holding the lock. The counter is increased while holding the lock 4.2.3, and then the lock is released again. This is sufficient to stop new accessors from starting a transfer. And the counter is there to make sure the running ones have finished.</li>
</ul>
<p><b>5. <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a></b></p>
<ul>
<li>5.1 External interface<ul>
<li>5.1.1 Provides a function that does not block writes, even if the device is not available (part of implementation of 1.i) [TBD: name of the function, maybe writeWithoutErrorBlocking() ]</li>
<li>5.1.2 There is a convenience function that allows to call a this function on any transfer element. If it is has an <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>, this functions called. Otherwise the normal write() is executed, which does not block in case of connections inside of ApplicationCore.</li>
</ul>
</li>
<li>5.2 Internal interface with other parts of ApplicationCore<ul>
<li>5.2.1 Catches exception thrown in TransferElement::doPostRead()/doPostWrite() (implements 1.e)</li>
<li>5.2.2 In read operations, it informs it's associated DataFaultCounter about device errors (implements 2.4.2.1 and 2.5.1)</li>
<li>5.2.3 Reports exceptions to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> (implements 2.5.2)</li>
</ul>
</li>
<li>5.3 Implementation<ul>
<li>5.3.1 Writing<ul>
<li>5.3.1.1 Writes to the recovery accessor before initiating the transfer (implements 2.4.2) in doPreWrite()</li>
<li>5.3.1.2 Decorates doPreWrite to acquire the shared lock described in 4.2.3, then increase the transfer counter and release the lock.</li>
<li>5.3.1.3 Decorates doPostWrite to decrease the transfer counter 4.2.6</li>
<li>5.3.1.4 Blocking writes wait in doPostWrite() until informed by the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> that the device has recovered (via 4.2.2, implements 2.5.3 for writing)</li>
<li>5.3.1.5 If doReadTransferNonBlocking()/doReadTransferLatest() must return true even in case of an exception, because eventually</li>
</ul>
</li>
<li>5.3.2 Reading<ul>
<li>5.3.2.1 Decorates doPreRead to acquire the shared lock described in 4.2.3, then increase the transfer counter and release the lock.</li>
<li>5.3.2.2 Decorates doPostRead to decrease the transfer counter, then perform the delegated call to postRead, which might throw, and catch here.</li>
<li>5.3.2.2 Blocking reads, or reads which have not seen a valid initial value yet, wait in doPostRead() until informed by the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> that the device has recovered (via 4.2.2, implements 2.5.3 for writing), the try a complete read cycle (incl. preRead) until they can successfully read a value (they might receive data with the faulty flag turned on by the sender, which is ok. It is a valid transfer).</li>
</ul>
</li>
<li>5.3.3 Sequences of calles to the delegated preXxx(), xxxTransferYyy() and postXxx() must always follow the DeviceAccess TransferElement specification.<ul>
<li>5.3.3.1 preXxx() and postXxx() must alwas be called in matching pairs. If a recovery is started in doPostXxx(), the failed transfer must be finished first by calling postXxx() and DeviceModule::stopTransfer(), then a completely new cycle (including DeviceModule::startTransfer() and DeviceModule::stopTransfer()) must be initiated.</li>
<li>5.3.3.2 If the transfer is not taking place at all (because in preXxx() the device is already known to be broken and no recovery shall be attempted), the delegated preXxx() and postXxx() functions must not be called as well.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>6. TriggerFanout and <a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a> </b></p>
<ul>
<li>6.1 TriggerFanout Each <a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a> reads several poll-type variables when a trigger (push type) is received. If one of the poll-type inputs is in error state, it shall not block the other variables. To implement this, the TriggerFanout uses the write function which does not block on device exceptions (5.1.2), (implements 1.i)</li>
<li>6.2 <a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a> If outputs of a <a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a> also write do devices, the writes must not block the other variables in the fanout. To implement this, the TreadedFanOut uses the non blocking write through the convenience function described in 5.1.2 (implements 1.i)</li>
</ul>
<p><b>7. The server must always start even if a device is in error state .</b></p>
<p>Implementation of 1.k. This section extracts some points from 1. and 2. to put the bits and pieces into context.</p>
<p>To make sure that the server always starts, even if some or all devices are in error state, the initial opening of the device takes place in the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread (inside the exception handling loop). The device module reports its status and error messages to the control system (see 2.1, 2.3.5, 2.6.1).</p>
<p>Some initial values are already written in prepare(), before the threads are started. Writing these values must be delayed until the device is available. This is done by the same mechanism that is used to re-write the values after recovery. (see 10 and <a class="el" href="spec_initial_value_propagation.html">spec_initialValuePropagation</a>)</p>
<p><b>8. Propagating the DataValidity flag</b></p>
<p>If a device is in error state, all it's output data is marked as invalid. This invalid flag shall be propagated through the connected modules such that all data that is calculated from these invalid values is also marked invalid (see <a class="el" href="spec_data_validity_propagation.html">spec_dataValidityPropagation</a>). The <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> is informing the DataFaultCounter about the device state (faulty or ok, see 3.6.3 and 2.4.1.2.1)</p>
<p>To propagate the flag, the first blocking read after the device error return the last value. As the DataFaultCounter knows about the device error, the data invalid flag is turned on (2.5.3-read). In order not to prevent unnecessary running of modules with invalid data, the following read call blocks until the device has recovered.</p>
<p>After recovery the DataFaultCounter is informed that the device is OK again, and the received DataValidity of the variable is propagated (usually 'ok', but if 'faulty' is received, the data validity stays faulty).</p>
<p><b>9. Device initialisation </b></p>
<p>This partly is specification of the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>. As it is strongly connected with exception handling, and in fact handled by the same code, it is mentioned here.</p>
<ul>
<li>9.1 The user code can register exception handlers (in the constructor of the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> or using <a class="el" href="class_chimera_t_k_1_1_device_module.html#ab30bf1b235913143d45bb5da7d84052c" title="Add initialisation handlers to the device. ">DeviceModule::addInitialisationHandler</a>). They are executed each time after the device has successfully been opened (*)</li>
<li>9.2 Sometimes it is only possible to write parts of the device after a proper initialisation sequence (for instance reset-registers must be cleared, or communication clocks to sub-devices must be set). Hence no read or write operations must take place until this point, not even writing recovery accessors (implements 1.c, implemented by 4.2.3, 5.3.1.2 and 5.3.2.1).</li>
<li>9.3 The recovery accessors are written after the initialisation (implements 1.l).</li>
<li>9.4 The lock 4.2.3 is only released after all recovery accessors are written, so ApplicationModules which continue find the same state as before the error when writing or reading.</li>
</ul>
<p>Comments:</p><ul>
<li>9.1 Successfully opened means open() did not throw, and the device reports isFunctional() as true.</li>
</ul>
<p><b>10. Recover accessors</b></p>
<p>After a device has failed and recovered, it might have re-booted and lost the values of the process variables that live in the server and are written to the device. Hence these values have to be re-written after the device has recovered. The same holds for initial values which have been written before the device thread has started (see 7.), and even normal variables which have been written before the device is available, as several threads start asynchronously.</p>
<p>The writing after the recovery is done in the device thread. The regular register accessors (which are decorated with the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>) belong to the <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> threads (or those of the fanouts), which can modify the user buffer any time. Hence the device thread cannot use these accessors in a thread-safe way. In addition, the device module has to remember the last value which has been written to restore a consistent state. The <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> might already have modified it's user buffer, but not have written yet. Hence also for logical reasons this buffer cannot be used for recovery.</p>
<p>As a consequence a copy has to be created whenever the data is written to the device. It is implemented by a so called recovery accessor. This is a regular second accessor to the register whose accessor has been decorated with the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>, but with the special usage that the data is set in the <a class="el" href="class_chimera_t_k_1_1_application.html">Application</a> thread, and written in the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread.</p>
<ul>
<li>10.1 The recovery accessor is created together with the normal accessor in the connection code (in DeviceModule::writeRecoveryOpen), registered at the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> and given to the recovery accessors.</li>
<li>10.2 Data is copied in doPreWrite(), before the original accessor's pre-write is called. This is the last occasion where the data is still guaranteed to be in the original accessors's user buffer. The accessor's pre-write might swap the data out, and it might never be available again (in case of write destructively.</li>
<li>10.3 As the user buffer recovery accessor is written in an <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> or fanout thread, but read in the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread when recovering, it has to be protected by a mutex. For efficiency one single shared mutex is used. All ExceptionHandlingDecorators will acquire a shared lock, as each decorator only touches his own buffer. The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>, which writes all recovery accessors, uses the unique lock to prevent any <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> to modify the user buffer while doing so.</li>
<li>10.4 All valid recovery accessors are written each time the device has been (re)-opened, after the initialisation handlers have been executed. If a recovery accessor has not seen an initial value yet, the version number is still nullptr, and the accessor is invalid. These accessors are not written. (implements 1.l)</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_known_issues"></a>
Known issues</h1>
<ul>
<li>11.1 In step 2.1: The initial value of deviceError is not set to 1.</li>
<li>11.2 In step 2.2.3: is not correctly fulfilled as we are only waiting for device to be opened and don't wait for it to be correctly initialised. The lock 4.2.3 is not implemented at all.</li>
<li>11.3 In step 2.3.5: is currently being set before initialisationHandlers and writeAfterOpen.</li>
<li>11.4 Check the documentation of DataValidity. ...'Note that if the data is distributed through a triggered <a class="el" href="class_chimera_t_k_1_1_fan_out.html" title="Base class for several implementations which distribute values from one feeder to multiple consumers...">FanOut</a>....'</li>
<li>11.5 Data validity is currently propagated through the "owner", which conceptually does not always work. A DataFaultCounter needs to be introduced and used at the correct places.</li>
<li>11.6 In comment to 1.g: recovery accessors are not optional at the moment.</li>
<li>11.7 In 1.c: Currently data is transported even if the "value after construction" is still in.</li>
<li>11.8 In 1.i, 6: ThreadedFanout and TriggerFanout do not use non-blocking write because it does not exist yet</li>
<li>11.9 In 1.j, 2.5.3: Not implemented like that. The first read blocks, and a special mechanism to propagate the flags is triggered only in the next module.</li>
<li>11.10 In 2.3: The device module has a special "first opening" sequence. This is not necessary any more. The "writeAfterOpen" list is obsolete. You can always use the recovery accessors.</li>
<li>11.11 In 2.3.4: Recovery accessors are always written. It is not checked whether there is valid data (not "value after construction")</li>
<li>11.12 In 2.4.1.1: Write probably re-executed after recovery. This should not happen because the recovery accessor has already done it.</li>
<li>11.13 In 2.5.3: The non-blocking read functions always block on exceptions. They should not (only if there is no initial value).</li>
<li>11.14 In 2.5.2, 5.1: writeWithoutErrorBlocking is not implemented yet</li>
<li>11.15 Asynchronous reads are not working with the current implementation, incl. readAny.</li>
<li>11.16 In 3: DeviceAccess : RegisterAccessors throw in doReadTransfer now.</li>
<li>11.17 In 4.2.1: reportException does block (should not)</li>
<li>11.18 In 4.2.2: blocking wait function does not exist (not needed in current implementation as reportException blocks)</li>
<li>11.19 In 5.2.1: Exceptions are caught in doXxxTransfer instead of doPostXxx.</li>
<li>11.20 In 5.3.1.2, 5.3.2.1: Decoration of doXxxTransfer does not acquire the lock (which does not even exist yet, see 4.2.3)</li>
<li>11.21 In 3.2: Decorators might have to try-catch because they usually can only do their task after calling the delegated postXxx.</li>
<li>11.22 In 3.4: The TransferType is not known. Needs to be implemented in TransferElement</li>
<li>11.23 In 3.5: PostRead is currently skipped if readNonBlocking or readLatest does not have new data</li>
<li>11.24 In 3.6: The waitForNewData calls in the DoocsBackend (using zmq) are currently not interruptible </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li>
    <li class="footer">Generated on Wed Apr 29 2020 03:53:45 for ChimeraTK-ApplicationCore by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
