<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mtca4u-deviceaccess: mtca4u::TransferElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DESY_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mtca4u-deviceaccess
   &#160;<span id="projectnumber">00.27.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemtca4u.html">mtca4u</a></li><li class="navelem"><a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmtca4u_1_1_transfer_element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mtca4u::TransferElement Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for register accessors which can be part of a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>.  
 <a href="classmtca4u_1_1_transfer_element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mtca4u::TransferElement:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmtca4u_1_1_transfer_element.png" usemap="#mtca4u::TransferElement_map" alt=""/>
  <map id="mtca4u::TransferElement_map" name="mtca4u::TransferElement_map">
<area href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. " alt="mtca4u::NDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="0,112,431,136"/>
<area href="classmtca4u_1_1_n_d_register_accessor_bridge.html" title="Base class for the reigster accessor bridges (ScalarRegisterAccessor, OneDRegisterAccessor and TwoDRe..." alt="mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;" shape="rect" coords="882,112,1313,136"/>
<area href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends, responsible for the underlying..." alt="mtca4u::NumericAddressedLowLevelTransferElement" shape="rect" coords="1323,112,1754,136"/>
<area href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html" alt="mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;" shape="rect" coords="441,168,872,192"/>
<area href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html" alt="mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;" shape="rect" coords="441,224,872,248"/>
<area href="classmtca4u_1_1_multiplexed_data_accessor.html" alt="mtca4u::MultiplexedDataAccessor&lt; UserType &gt;" shape="rect" coords="441,280,872,304"/>
<area href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for multiplexd 2D registers..." alt="mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;" shape="rect" coords="441,336,872,360"/>
<area href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for scalar and 1D registers..." alt="mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;" shape="rect" coords="441,392,872,416"/>
<area href="classmtca4u_1_1_scale_register_plugin_register_accessor.html" title="The register accessor used by the ScaleRegisterPlugin. " alt="mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;" shape="rect" coords="441,448,872,472"/>
<area href="classmtca4u_1_1_buffering_register_accessor.html" title="DEPRECATED! Use OneDRegisterAccessor or ScalarRegisterAccessor instead! " alt="mtca4u::BufferingRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1323,168,1754,192"/>
<area href="classmtca4u_1_1_one_d_register_accessor.html" title="Accessor class to read and write registers transparently by using the accessor object like a vector o..." alt="mtca4u::OneDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1323,224,1754,248"/>
<area href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v..." alt="mtca4u::ScalarRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1323,280,1754,304"/>
<area href="classmtca4u_1_1_two_d_register_accessor.html" title="TODO add documentation. " alt="mtca4u::TwoDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1323,336,1754,360"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class holding a unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> for a <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="classmtca4u_1_1_transfer_element_1_1_i_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0db950554a40340e7aeca3249ca2d46d"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0db950554a40340e7aeca3249ca2d46d">SharedPtr</a></td></tr>
<tr class="memdesc:a0db950554a40340e7aeca3249ca2d46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for more compact syntax.  <a href="#a0db950554a40340e7aeca3249ca2d46d">More...</a><br /></td></tr>
<tr class="separator:a0db950554a40340e7aeca3249ca2d46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9901e666ac60d41473a69bae04859871"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a9901e666ac60d41473a69bae04859871">TransferElement</a> (std::string const &amp;name=std::string(), std::string const &amp;unit=std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:a9901e666ac60d41473a69bae04859871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer element with the specified name.  <a href="#a9901e666ac60d41473a69bae04859871">More...</a><br /></td></tr>
<tr class="separator:a9901e666ac60d41473a69bae04859871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ac07c9d4fab89208a93016a101898a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a32ac07c9d4fab89208a93016a101898a">TransferElement</a> (const <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &amp;other)</td></tr>
<tr class="memdesc:a32ac07c9d4fab89208a93016a101898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: do not allow copying when in <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>, remove asynchronous read state.  <a href="#a32ac07c9d4fab89208a93016a101898a">More...</a><br /></td></tr>
<tr class="separator:a32ac07c9d4fab89208a93016a101898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578ad1991d6b9763b5cc8096220af0d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aa578ad1991d6b9763b5cc8096220af0d">~TransferElement</a> ()</td></tr>
<tr class="memdesc:aa578ad1991d6b9763b5cc8096220af0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <a href="#aa578ad1991d6b9763b5cc8096220af0d">More...</a><br /></td></tr>
<tr class="separator:aa578ad1991d6b9763b5cc8096220af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ecc0786839b0949f13a4203187e5b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a1b1ecc0786839b0949f13a4203187e5b">getName</a> () const </td></tr>
<tr class="memdesc:a1b1ecc0786839b0949f13a4203187e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#a1b1ecc0786839b0949f13a4203187e5b">More...</a><br /></td></tr>
<tr class="separator:a1b1ecc0786839b0949f13a4203187e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f64bf74aed8bb95796dafaff5ddd98"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a95f64bf74aed8bb95796dafaff5ddd98">getUnit</a> () const </td></tr>
<tr class="memdesc:a95f64bf74aed8bb95796dafaff5ddd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#a95f64bf74aed8bb95796dafaff5ddd98">More...</a><br /></td></tr>
<tr class="separator:a95f64bf74aed8bb95796dafaff5ddd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66ca9c081ec77cf6d9cc64a4c267fb"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adc66ca9c081ec77cf6d9cc64a4c267fb">getDescription</a> () const </td></tr>
<tr class="memdesc:adc66ca9c081ec77cf6d9cc64a4c267fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#adc66ca9c081ec77cf6d9cc64a4c267fb">More...</a><br /></td></tr>
<tr class="separator:adc66ca9c081ec77cf6d9cc64a4c267fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c56d5d123fd245ff352808c281ea2"><td class="memItemLeft" align="right" valign="top">virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a475c56d5d123fd245ff352808c281ea2">getValueType</a> () const =0</td></tr>
<tr class="memdesc:a475c56d5d123fd245ff352808c281ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#a475c56d5d123fd245ff352808c281ea2">More...</a><br /></td></tr>
<tr class="separator:a475c56d5d123fd245ff352808c281ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6bfac3968093e94171e76123f382dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd">read</a> ()</td></tr>
<tr class="memdesc:a9a6bfac3968093e94171e76123f382dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#a9a6bfac3968093e94171e76123f382dd">More...</a><br /></td></tr>
<tr class="separator:a9a6bfac3968093e94171e76123f382dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2ea63a93acb6b93af71c1882a6154"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:a39c2ea63a93acb6b93af71c1882a6154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#a39c2ea63a93acb6b93af71c1882a6154">More...</a><br /></td></tr>
<tr class="separator:a39c2ea63a93acb6b93af71c1882a6154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7483fd20ad5c8c4332368738de10c56b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a7483fd20ad5c8c4332368738de10c56b">readAsync</a> ()=0</td></tr>
<tr class="memdesc:a7483fd20ad5c8c4332368738de10c56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#a7483fd20ad5c8c4332368738de10c56b">More...</a><br /></td></tr>
<tr class="separator:a7483fd20ad5c8c4332368738de10c56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6114d163656e92a02b901c8d7ddc346"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af6114d163656e92a02b901c8d7ddc346">readLatest</a> ()</td></tr>
<tr class="memdesc:af6114d163656e92a02b901c8d7ddc346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#af6114d163656e92a02b901c8d7ddc346">More...</a><br /></td></tr>
<tr class="separator:af6114d163656e92a02b901c8d7ddc346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e7690a5dbba2e34a0fc8f91f4af5ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a77e7690a5dbba2e34a0fc8f91f4af5ca">getVersionNumber</a> () const </td></tr>
<tr class="memdesc:a77e7690a5dbba2e34a0fc8f91f4af5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#a77e7690a5dbba2e34a0fc8f91f4af5ca">More...</a><br /></td></tr>
<tr class="separator:a77e7690a5dbba2e34a0fc8f91f4af5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b2fdb9a6dea04fd343edf9511a0159"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a06b2fdb9a6dea04fd343edf9511a0159">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})=0</td></tr>
<tr class="memdesc:a06b2fdb9a6dea04fd343edf9511a0159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a06b2fdb9a6dea04fd343edf9511a0159">More...</a><br /></td></tr>
<tr class="separator:a06b2fdb9a6dea04fd343edf9511a0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb02e2fa3228e645f6ff88d10226381"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a3eb02e2fa3228e645f6ff88d10226381">doReadTransfer</a> ()=0</td></tr>
<tr class="memdesc:a3eb02e2fa3228e645f6ff88d10226381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a3eb02e2fa3228e645f6ff88d10226381">More...</a><br /></td></tr>
<tr class="separator:a3eb02e2fa3228e645f6ff88d10226381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad313e332b8bf872eade35bd4cdec9462"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ad313e332b8bf872eade35bd4cdec9462">doReadTransferNonBlocking</a> ()=0</td></tr>
<tr class="memdesc:ad313e332b8bf872eade35bd4cdec9462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ad313e332b8bf872eade35bd4cdec9462">More...</a><br /></td></tr>
<tr class="separator:ad313e332b8bf872eade35bd4cdec9462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095ac74aa9aa2fc21baa37d9e07e85e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a095ac74aa9aa2fc21baa37d9e07e85e1">doReadTransferLatest</a> ()=0</td></tr>
<tr class="memdesc:a095ac74aa9aa2fc21baa37d9e07e85e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a095ac74aa9aa2fc21baa37d9e07e85e1">More...</a><br /></td></tr>
<tr class="separator:a095ac74aa9aa2fc21baa37d9e07e85e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e189d1260a18cd02ada7a5ba2e44c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ad6e189d1260a18cd02ada7a5ba2e44c8">postRead</a> ()</td></tr>
<tr class="memdesc:ad6e189d1260a18cd02ada7a5ba2e44c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed.  <a href="#ad6e189d1260a18cd02ada7a5ba2e44c8">More...</a><br /></td></tr>
<tr class="separator:ad6e189d1260a18cd02ada7a5ba2e44c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e00e60a19ea7f94ce0d520f335bb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a986e00e60a19ea7f94ce0d520f335bb4">preWrite</a> ()</td></tr>
<tr class="memdesc:a986e00e60a19ea7f94ce0d520f335bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed.  <a href="#a986e00e60a19ea7f94ce0d520f335bb4">More...</a><br /></td></tr>
<tr class="separator:a986e00e60a19ea7f94ce0d520f335bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0126b6acdba460cb27676878d10c83a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0126b6acdba460cb27676878d10c83a3">postWrite</a> ()</td></tr>
<tr class="memdesc:a0126b6acdba460cb27676878d10c83a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any post-write cleanups if necessary.  <a href="#a0126b6acdba460cb27676878d10c83a3">More...</a><br /></td></tr>
<tr class="separator:a0126b6acdba460cb27676878d10c83a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74817fa1c4323897f0af32bbc3d57aa5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a74817fa1c4323897f0af32bbc3d57aa5">isSameRegister</a> (const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;other) const =0</td></tr>
<tr class="memdesc:a74817fa1c4323897f0af32bbc3d57aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two TransferElements are identical, i.e.  <a href="#a74817fa1c4323897f0af32bbc3d57aa5">More...</a><br /></td></tr>
<tr class="separator:a74817fa1c4323897f0af32bbc3d57aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2807cd6932846d6988b9fb645a420e9b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a2807cd6932846d6988b9fb645a420e9b">isReadOnly</a> () const =0</td></tr>
<tr class="memdesc:a2807cd6932846d6988b9fb645a420e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <a href="#a2807cd6932846d6988b9fb645a420e9b">More...</a><br /></td></tr>
<tr class="separator:a2807cd6932846d6988b9fb645a420e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e803ec5758a3cd2d25a1e743e24d5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a55e803ec5758a3cd2d25a1e743e24d5c">isReadable</a> () const =0</td></tr>
<tr class="memdesc:a55e803ec5758a3cd2d25a1e743e24d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#a55e803ec5758a3cd2d25a1e743e24d5c">More...</a><br /></td></tr>
<tr class="separator:a55e803ec5758a3cd2d25a1e743e24d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e9f2ec21138931f5f8c5cdc03c11a4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aa0e9f2ec21138931f5f8c5cdc03c11a4">isWriteable</a> () const =0</td></tr>
<tr class="memdesc:aa0e9f2ec21138931f5f8c5cdc03c11a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#aa0e9f2ec21138931f5f8c5cdc03c11a4">More...</a><br /></td></tr>
<tr class="separator:aa0e9f2ec21138931f5f8c5cdc03c11a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedfb9d715e3077bad6312238e411998"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmtca4u_1_1_time_stamp.html">TimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aeedfb9d715e3077bad6312238e411998">getTimeStamp</a> () const </td></tr>
<tr class="memdesc:aeedfb9d715e3077bad6312238e411998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aeedfb9d715e3077bad6312238e411998">More...</a><br /></td></tr>
<tr class="separator:aeedfb9d715e3077bad6312238e411998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3faef1e424f7eb1546f1aa7aa34d85"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aac3faef1e424f7eb1546f1aa7aa34d85">isArray</a> () const </td></tr>
<tr class="memdesc:aac3faef1e424f7eb1546f1aa7aa34d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aac3faef1e424f7eb1546f1aa7aa34d85">More...</a><br /></td></tr>
<tr class="separator:aac3faef1e424f7eb1546f1aa7aa34d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c43acb77928d2ccc12829d1b386195b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a4c43acb77928d2ccc12829d1b386195b">getHardwareAccessingElements</a> ()=0</td></tr>
<tr class="memdesc:a4c43acb77928d2ccc12829d1b386195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a4c43acb77928d2ccc12829d1b386195b">More...</a><br /></td></tr>
<tr class="separator:a4c43acb77928d2ccc12829d1b386195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174b74892bb5aa866b0be19c73e67542"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a174b74892bb5aa866b0be19c73e67542">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:a174b74892bb5aa866b0be19c73e67542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a174b74892bb5aa866b0be19c73e67542">More...</a><br /></td></tr>
<tr class="separator:a174b74892bb5aa866b0be19c73e67542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd708790ccb8388ee8f7d01d6b47220"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#accd708790ccb8388ee8f7d01d6b47220">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; newElement)=0</td></tr>
<tr class="memdesc:accd708790ccb8388ee8f7d01d6b47220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#accd708790ccb8388ee8f7d01d6b47220">More...</a><br /></td></tr>
<tr class="separator:accd708790ccb8388ee8f7d01d6b47220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0815a31412f1e862dff4bf6b5f90d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8a0815a31412f1e862dff4bf6b5f90d4">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;)</td></tr>
<tr class="memdesc:a8a0815a31412f1e862dff4bf6b5f90d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a8a0815a31412f1e862dff4bf6b5f90d4">More...</a><br /></td></tr>
<tr class="separator:a8a0815a31412f1e862dff4bf6b5f90d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7779fc0a610a11a1b9758a2584fa6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ab7779fc0a610a11a1b9758a2584fa6ce">getId</a> () const </td></tr>
<tr class="memdesc:ab7779fc0a610a11a1b9758a2584fa6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> for this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ab7779fc0a610a11a1b9758a2584fa6ce">More...</a><br /></td></tr>
<tr class="separator:ab7779fc0a610a11a1b9758a2584fa6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae22fdbe57951c132c5af6b8634de04fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">TransferElement::ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ae22fdbe57951c132c5af6b8634de04fc">readAny</a> (std::list&lt; std::reference_wrapper&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&gt; elementsToRead)</td></tr>
<tr class="memdesc:ae22fdbe57951c132c5af6b8634de04fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data asynchronously from all given TransferElements and wait until one of the TransferElements has new data.  <a href="#ae22fdbe57951c132c5af6b8634de04fc">More...</a><br /></td></tr>
<tr class="separator:ae22fdbe57951c132c5af6b8634de04fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a05577297da10eba9575c1606efb838b9"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a> [] = &quot;n./a.&quot;</td></tr>
<tr class="memdesc:a05577297da10eba9575c1606efb838b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant string to be used as a unit when the unit is not provided or known.  <a href="#a05577297da10eba9575c1606efb838b9">More...</a><br /></td></tr>
<tr class="separator:a05577297da10eba9575c1606efb838b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af76e8a733a92e5a36ab6466e8fec43d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af76e8a733a92e5a36ab6466e8fec43d7">makeUniqueId</a> ()</td></tr>
<tr class="memdesc:af76e8a733a92e5a36ab6466e8fec43d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow generating a unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> from derived classes.  <a href="#af76e8a733a92e5a36ab6466e8fec43d7">More...</a><br /></td></tr>
<tr class="separator:af76e8a733a92e5a36ab6466e8fec43d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a674e1814502195c7545c0d6512f65fcc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a674e1814502195c7545c0d6512f65fcc">_name</a></td></tr>
<tr class="memdesc:a674e1814502195c7545c0d6512f65fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier uniquely identifying the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a674e1814502195c7545c0d6512f65fcc">More...</a><br /></td></tr>
<tr class="separator:a674e1814502195c7545c0d6512f65fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53051ab33dd295fa8d14007159d5498c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a53051ab33dd295fa8d14007159d5498c">_unit</a></td></tr>
<tr class="memdesc:a53051ab33dd295fa8d14007159d5498c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engineering unit.  <a href="#a53051ab33dd295fa8d14007159d5498c">More...</a><br /></td></tr>
<tr class="separator:a53051ab33dd295fa8d14007159d5498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaebf84a4baead76fcca5b38bead596a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adaebf84a4baead76fcca5b38bead596a">_description</a></td></tr>
<tr class="memdesc:adaebf84a4baead76fcca5b38bead596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of this variable/register.  <a href="#adaebf84a4baead76fcca5b38bead596a">More...</a><br /></td></tr>
<tr class="separator:adaebf84a4baead76fcca5b38bead596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472a62db198011226904af5d41aec7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a3472a62db198011226904af5d41aec7b">_id</a></td></tr>
<tr class="memdesc:a3472a62db198011226904af5d41aec7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a3472a62db198011226904af5d41aec7b">More...</a><br /></td></tr>
<tr class="separator:a3472a62db198011226904af5d41aec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f6bbbd0a7230f21c0900541efc5336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a04f6bbbd0a7230f21c0900541efc5336">isInTransferGroup</a></td></tr>
<tr class="memdesc:a04f6bbbd0a7230f21c0900541efc5336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not.  <a href="#a04f6bbbd0a7230f21c0900541efc5336">More...</a><br /></td></tr>
<tr class="separator:a04f6bbbd0a7230f21c0900541efc5336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5c05a8d573fc17c6fcc6c0a7874c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a82d5c05a8d573fc17c6fcc6c0a7874c7">hasActiveFuture</a> {false}</td></tr>
<tr class="memdesc:a82d5c05a8d573fc17c6fcc6c0a7874c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether there is an "active" TransferFuture which was given out by readAync() but its ready state was not yet obtained by the user e.g.  <a href="#a82d5c05a8d573fc17c6fcc6c0a7874c7">More...</a><br /></td></tr>
<tr class="separator:a82d5c05a8d573fc17c6fcc6c0a7874c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8194c23ca0a8b08293e6c3410c845bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8194c23ca0a8b08293e6c3410c845bc1">activeFuture</a></td></tr>
<tr class="memdesc:a8194c23ca0a8b08293e6c3410c845bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently "active" future, if hasActiveFuture == true.  <a href="#a8194c23ca0a8b08293e6c3410c845bc1">More...</a><br /></td></tr>
<tr class="separator:a8194c23ca0a8b08293e6c3410c845bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5bdf5501b097a054a0be0bd5c8332ef3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a5bdf5501b097a054a0be0bd5c8332ef3">TransferGroup</a></td></tr>
<tr class="separator:a5bdf5501b097a054a0be0bd5c8332ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6cb788c9f76a35a66d7b6266e94c70"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aba6cb788c9f76a35a66d7b6266e94c70">TransferFuture</a></td></tr>
<tr class="separator:aba6cb788c9f76a35a66d7b6266e94c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for register accessors which can be part of a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00042">42</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0db950554a40340e7aeca3249ca2d46d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; <a class="el" href="classmtca4u_1_1_transfer_element.html#a0db950554a40340e7aeca3249ca2d46d">mtca4u::TransferElement::SharedPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typedef for more compact syntax. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00121">121</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9901e666ac60d41473a69bae04859871"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mtca4u::TransferElement::TransferElement </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transfer element with the specified name. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00047">47</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32ac07c9d4fab89208a93016a101898a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mtca4u::TransferElement::TransferElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: do not allow copying when in <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>, remove asynchronous read state. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00052">52</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa578ad1991d6b9763b5cc8096220af0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mtca4u::TransferElement::~TransferElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract base classes need a virtual destructor. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00066">66</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3eb02e2fa3228e645f6ff88d10226381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElement::doReadTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#ad6e189d1260a18cd02ada7a5ba2e44c8" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a>.</p>
<p>Implementation note: This function must return within ~1 second after boost::thread::interrupt() has been called on the thread calling this function. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a94dfcb84e4172105f2be1b556904a268">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#af2f839615676682d55aded65f19ff760">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a65d9d1d3f391681d35052e59c80cdb7f">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a374c3d30791af4fb1e94e4313b860182">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a234679c77f230047a6da4aa9e0c1813a">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a828b08e88b2854a151f2a393d545dabc">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adaa7f4a4203547250a6f801fa8bc2b07">mtca4u::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a1102cea4d56dc92b61e88e34d1673ee0">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a095ac74aa9aa2fc21baa37d9e07e85e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::doReadTransferLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#ad6e189d1260a18cd02ada7a5ba2e44c8" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_transfer_element.html#af6114d163656e92a02b901c8d7ddc346" title="Read the latest value, discarding any other update since the last read if present. ">readLatest()</a>. For the return value, see <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#abfeb3ed7ee81ae2fa4a1446d6d777589">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a5d1d645d4440ec4cce3be9d55e3367b8">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a60763b1b2ac1e23a1313d0b187f83552">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#aeceb64d0a7a585823f08e71d5805b89e">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#aa5c5c7484b091e5dd9da195b38ddee0b">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a7e33dc545449852faa5dec4b872b0c5f">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a40f2e6a88c0cddcd3e2fbed0b5266749">mtca4u::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#ace0a02f6d1e859bca0390193bb1bb606">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad313e332b8bf872eade35bd4cdec9462"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::doReadTransferNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#ad6e189d1260a18cd02ada7a5ba2e44c8" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. For the return value, see <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a3398f5bf9df7594ec11472a14d0de6c7">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#ae9b2655d7ce19360f61e41bd3bfd92c6">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a6c7f83ea48544157508c717c7694fca2">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a9021f0527ff5777ace91c07af3b5ef38">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#ae1511921e4dc74e855ee0159fa0d5984">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a982735c311b461350c53b39fd5302881">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#ab2f011286aefc91ed504976091ce08ec">mtca4u::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a890ecf134b6a9486dddd535e6b425648">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adc66ca9c081ec77cf6d9cc64a4c267fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mtca4u::TransferElement::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of this variable/register. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00134">134</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4c43acb77928d2ccc12829d1b386195b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; &gt; mtca4u::TransferElement::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a72de00f12793aba74006113880c7e0e9">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a656f246ea1a2a8f7cdcd3b44d145bf2d">mtca4u::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a1b112d3318a29b32e3ccc67464352a01">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a4eadc2ae2f805f3a37b155ddf83065a5">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a52f86c4599cd2b96e12f56fbac0b937b">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a9347c515f30231c5a9b98f75e0079300">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a98ed40c0573147cf044124f01ce87a73">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a297307b218bde43d5ab0762967403c55">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a174b74892bb5aa866b0be19c73e67542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; mtca4u::TransferElement::getHighLevelImplElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>For TransferElements which are itself an implementation this will directly return a shared pointer to this. If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is a user frontend, the pointer to the internal implementation is returned.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Reimplemented in <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a8ef07ab0aad73ba295dabb7acbdd759a">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00322">322</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7779fc0a610a11a1b9758a2584fa6ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a> mtca4u::TransferElement::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> for this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is the abstractor side of the bridge, this function will return the unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of the actual implementation. This means that e.g. two instances of <a class="el" href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a> created by the same call to <a class="el" href="classmtca4u_1_1_device.html#a5223e36dcdefaf8e1b99dbca86b6ea87" title="Get a ScalarRegisterObject object for the given register. ">Device::getScalarRegisterAccessor()</a> (e.g. by copying the accessor to another using <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#aa542896c14145a27faca963b82967dc7" title="Assign a new accessor to this NDRegisterAccessorBridge. ">NDRegisterAccessorBridge::replace()</a>) will have the same <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a>, while two instances obtained by to difference calls to <a class="el" href="classmtca4u_1_1_device.html#a5223e36dcdefaf8e1b99dbca86b6ea87" title="Get a ScalarRegisterObject object for the given register. ">Device::getScalarRegisterAccessor()</a> will have a different <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> even when accessing the very same register. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00356">356</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b1ecc0786839b0949f13a4203187e5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mtca4u::TransferElement::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name that identifies the process variable. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00124">124</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeedfb9d715e3077bad6312238e411998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structmtca4u_1_1_time_stamp.html">TimeStamp</a> mtca4u::TransferElement::getTimeStamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated, do not use. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>The time stamp will be replaced with a unique counter.</dd></dl>
<p>Only used for backward compatibility with the control system adapter. All implementations in DeviceAccess will throw an exception with <a class="el" href="classmtca4u_1_1_device_exception.html#a141bf6874b02df4f7f7166b863370883af8064003cb7ee7eb6a21179fd1ebad0a" title="The function called is not implemented yet, e.g. for the used backend. ">DeviceException::NOT_IMPLEMENTED</a>.</p>
<p>Returns the time stamp associated with the current value of the transfer element. Typically, this is the time when the value was updated. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00294">294</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95f64bf74aed8bb95796dafaff5ddd98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mtca4u::TransferElement::getUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the engineering unit. </p>
<p>If none was specified, it will default to "n./a." </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00129">129</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a475c56d5d123fd245ff352808c281ea2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::type_info&amp; mtca4u::TransferElement::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#aaec246234229b9f6662390455a16525f">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a7e5de20e5459961b2c58b4c62d8fe860">mtca4u::NDRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8cfa19333000184f262f21beac60ad8a">mtca4u::NumericAddressedLowLevelTransferElement</a>.</p>

</div>
</div>
<a class="anchor" id="a77e7690a5dbba2e34a0fc8f91f4af5ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> mtca4u::TransferElement::getVersionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version number that is associated with the last transfer (i.e. </p>
<p>last read or write). See <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">ChimeraTK::VersionNumber</a> for details.</p>
<p>The returned version number may be invalid (i.e. ChimeraTK::VersionNumber::isValid() returns false), if <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> as not been specified. If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was specified, a valid version number must be returned (either obtained from the ChimeraTK::VersionNumberSource or derived from an existing version number e.g. of another variable). </p>

<p>Reimplemented in <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#adce5978a17802052818e1d7e878c7289">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00220">220</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac3faef1e424f7eb1546f1aa7aa34d85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::isArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated, do not use. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Only used for backward compatibility with the control system adapter.</dd></dl>
<p>This feature will be removed soon, maybe even before the next tag. DO NOT USE IT!! </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00302">302</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a55e803ec5758a3cd2d25a1e743e24d5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="classmtca4u_1_1_transfer_element.html#a55e803ec5758a3cd2d25a1e743e24d5c" title="Check if transfer element is readable. ">isReadable()</a> is not true. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_buffering_register_accessor.html#a5bf6ba2143951281019f8b9afcf5749c">mtca4u::BufferingRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a60b42044343269203983815c6ca06216">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a1852bb84c750e88ca97bde9d1a5a8e94">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a7a729aac8200a9f2937206b95f882707">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#ac94ad7f78dee81feff0c2b59fe3f1ad2">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a1ec380846c9e88ad8c405b1367735055">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a5fdd555501b2891d895602db8d5a9940">mtca4u::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#af02f4ec33234254feccbd55dd9c66685">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a8cd3df723aad7436bf3a5a1fd57f295b">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2807cd6932846d6988b9fb645a420e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_buffering_register_accessor.html#a5c01c3fe9be8e78f214d6de1248d3262">mtca4u::BufferingRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#ac9ee765365ec3c67acb868a4c03bdd0f">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#aa9e511a789f878162d211ad4222ca0f7">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a4767cd3f32114712756c6b1fd3638d82">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a46a27c1bf371f9b2e42f3df82bda5c8b">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a9285fb15b290002f7c203d1b53668df6">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a74f7323552a1ed0f33fdfb3d48652d6e">mtca4u::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a40abca9a32c6aba5b7414edd754a4775">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#ac2a0c8dea8a3c6bc40dcb53ba2aaa34b">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a74817fa1c4323897f0af32bbc3d57aa5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::isSameRegister </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the two TransferElements are identical, i.e. </p>
<p>accessing the same hardware register. The definition of an "hardware register" is strongly depending on the backend implementation, thus using this function in application code will probably break the abstraction!</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>Rename this function to something more appropriate (e.g. mayJoinTransfer?) </dd></dl>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#aaee5c0ca77e9f1260a3a40e9cd786295">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a8dbdb8c9e0d1c9370c0c2f5db85b9df6">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a6cf8b89eac56623d6342355e888bbcf4">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a35523af8063b8bb39a48a431348f890b">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a21c5c87c8f4c2b84e4cccfccfd7e6529">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a4689477616c79ae5561ceb21e7908901">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a4c6c7a22aa26c6a20f388d87e59a6fb4">mtca4u::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a5c4af157246c08292e8ceda438828130">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e9f2ec21138931f5f8c5cdc03c11a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="classmtca4u_1_1_transfer_element.html#aa0e9f2ec21138931f5f8c5cdc03c11a4" title="Check if transfer element is writeable. ">isWriteable()</a> is not true. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_buffering_register_accessor.html#a7d00262b9f78f509ba838c233a6dd7fa">mtca4u::BufferingRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a01a1113f32d2404aba92d9fdcaf33c60">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#affc386ffa784a1f686229db6900c3343">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a3d1bff1111e07dfd56f43eb0aadeac3c">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a7a2faf3a8c9872fd54973fc941745401">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#af857ba2904847c09772ffb8318245561">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#ae11924bf4382fc720e9829daf56f1355">mtca4u::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a89d471aa50dd373f91123215bd21d20b">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#aad6d10583f73dbf430080951addc8e2b">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af76e8a733a92e5a36ab6466e8fec43d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::TransferElement::makeUniqueId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow generating a unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> from derived classes. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00373">373</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6e189d1260a18cd02ada7a5ba2e44c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElement::postRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed. </p>
<p>Called by the <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> after a read was executed directly on the underlying accessor. This function must be implemented to extract the read data from the underlying accessor and expose it to the user. </p>

<p>Reimplemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#aa23d8e5ddddf73c55cc5ffdcc6aca891">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a1f695ffffe5a55f56487c9d8df782122">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a4d985340a57378033bde042c71440015">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a1f695ffffe5a55f56487c9d8df782122">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#ad9bf7cc17a4836b73e9afa62f34ffa0b">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#ab38dd9f588431b9cd5235d112839447d">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#aa1fe89a83701925540f66f7a2d866b7b">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#ac3db1e3b1e0b55f22a7906a654017034">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#aa0773353fd41f7b8b79762f6bdbdb367">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#ada946453c9726829153d5d2103c15616">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#aa23d8e5ddddf73c55cc5ffdcc6aca891">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00250">250</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0126b6acdba460cb27676878d10c83a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElement::postWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any post-write cleanups if necessary. </p>
<p>If during <a class="el" href="classmtca4u_1_1_transfer_element.html#a986e00e60a19ea7f94ce0d520f335bb4" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> e.g. the user data buffer was swapped away, it must be swapped back in this function so the just sent data is available again to the calling program.</p>
<p>Called by the <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> after a write will be executed directly on the underlying accessor. </p>

<p>Reimplemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a5cae930dfe397de26baafbe45893c11b">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a7bbe37bc3b835fbb01881b7781674f64">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a5cae930dfe397de26baafbe45893c11b">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00264">264</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a986e00e60a19ea7f94ce0d520f335bb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElement::preWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed. </p>
<p>Called by the <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> before a write will be executed directly on the underlying accessor. This function implemented be used to transfer the data to be written into the underlying accessor. </p>

<p>Reimplemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a719df4ca933457c014b608e8a716a51d">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a0129a41978098797ad038d48f521cba8">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a4fdade61cb373c21597fee68cc50a6ed">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a0129a41978098797ad038d48f521cba8">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#acb5304a0c2b9e7771f303e75aa255b84">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a490c0b260c267a4cd1c48da3a29e7ab5">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#afa09dda23b8dfc220ab154efa17b8aea">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a719df4ca933457c014b608e8a716a51d">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00257">257</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a6bfac3968093e94171e76123f382dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::TransferElement::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00145">145</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae22fdbe57951c132c5af6b8634de04fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">TransferElement::ID</a> mtca4u::TransferElement::readAny </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::reference_wrapper&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>elementsToRead</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data asynchronously from all given TransferElements and wait until one of the TransferElements has new data. </p>
<p>The <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> which received new data is returned as a reference. In case multiple TransferElements receive new data simultaneously (or already have new data available before the call to <a class="el" href="classmtca4u_1_1_transfer_element.html#ae22fdbe57951c132c5af6b8634de04fc" title="Read data asynchronously from all given TransferElements and wait until one of the TransferElements h...">readAny()</a>), the <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> with the oldest VersionNumber (see <a class="el" href="classmtca4u_1_1_transfer_element.html#a77e7690a5dbba2e34a0fc8f91f4af5ca" title="Returns the version number that is associated with the last transfer (i.e. ">getVersionNumber()</a>) will be returned by this function. This ensures that data is received in the order of sending (unless data is "dated back" and sent with an older version number, which might be the case e.g. when using the ControlSystemAdapter). </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00427">427</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7483fd20ad5c8c4332368738de10c56b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&amp; mtca4u::TransferElement::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElemennt::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread. A reference is returned since we need polymorphism. This is possible since the implementation anyway needs to store the object to be able to return it a second time if <a class="el" href="classmtca4u_1_1_transfer_element.html#a7483fd20ad5c8c4332368738de10c56b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> is called again before the future is fulfilled.</p>
<p>Note: This feature is still experimental. Expect API changes without notice! </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b">mtca4u::NDRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#af94bc4809d5ba2e539b7de23d7567692">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#add560ee0774d5ae11055c6b322e6c32a">mtca4u::NumericAddressedLowLevelTransferElement</a>.</p>

</div>
</div>
<a class="anchor" id="af6114d163656e92a02b901c8d7ddc346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElement::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00197">197</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a39c2ea63a93acb6b93af71c1882a6154"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElement::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00163">163</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="accd708790ccb8388ee8f7d01d6b47220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElement::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#ad0ba0f16a3e676c2349d16a2c19dabbb">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adebf8dcace64cf630d6ce574208165fd">mtca4u::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a62c853aba779cb11414cd617dba78263">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a1b0974cae784b8973130be47c61309d1">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a10db306187aa906cdcd2a350f5faee11">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a2a17d0ab6625ac88aef5ed7b09868f44">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a8b0cc62c6ded3447c54c4ad5388fefa3">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a14ca83441bc319ec3713d572cfb42173">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8a0815a31412f1e862dff4bf6b5f90d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElement::setPersistentDataStorage </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate a persistent data storage object to be updated on each write operation of this ProcessArray. </p>
<p>If no persistent data storage as associated previously, the value from the persistent storage is read and send to the receiver.</p>
<p>Note: A call to this function will be ignored, if the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> does not support persistent data storage (e.g. read-only variables or device registers)</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000068">Todo:</a></b></dt><dd>TODO does this make sense? </dd></dl>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00346">346</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06b2fdb9a6dea04fd343edf9511a0159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mtca4u::TransferElement::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>

<p>Implemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#a8d3c73263cc6be153a12f1bd645d1417">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#a2886b9c963937e9d49834a494132edc6">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a076480948f741845acfc1cc941e94862">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a74b3b1297446a0d15e1784db728ba8c1">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html#a9d3fd9fc619d0d56ed1a211c40fc3833">mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a7e59c2522c817231938804de20f6a9b1">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a8e3da774fb5cdbe7134fddb8d6bbccbf">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#affb5c983d25698e51581fb95824e8254">mtca4u::NumericAddressedLowLevelTransferElement</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aba6cb788c9f76a35a66d7b6266e94c70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00388">388</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5bdf5501b097a054a0be0bd5c8332ef3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmtca4u_1_1_transfer_group.html">TransferGroup</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00387">387</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="adaebf84a4baead76fcca5b38bead596a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mtca4u::TransferElement::_description</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Description of this variable/register. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00367">367</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3472a62db198011226904af5d41aec7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a> mtca4u::TransferElement::_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00370">370</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a674e1814502195c7545c0d6512f65fcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mtca4u::TransferElement::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifier uniquely identifying the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00356">356</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53051ab33dd295fa8d14007159d5498c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mtca4u::TransferElement::_unit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Engineering unit. </p>
<p>Defaults to "n./a.", if none was specified </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00364">364</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8194c23ca0a8b08293e6c3410c845bc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> mtca4u::TransferElement::activeFuture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently "active" future, if hasActiveFuture == true. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00385">385</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a82d5c05a8d573fc17c6fcc6c0a7874c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElement::hasActiveFuture {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag whether there is an "active" TransferFuture which was given out by readAync() but its ready state was not yet obtained by the user e.g. </p>
<p>through <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a>. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00382">382</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a04f6bbbd0a7230f21c0900541efc5336"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElement::isInTransferGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag whether this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00378">378</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05577297da10eba9575c1606efb838b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char mtca4u::TransferElement::unitNotSet = &quot;n./a.&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant string to be used as a unit when the unit is not provided or known. </p>

<p>Definition at line <a class="el" href="_transfer_element_8h_source.html#l00336">336</a> of file <a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device/include/<a class="el" href="_transfer_element_8h_source.html">TransferElement.h</a></li>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device/src/<a class="el" href="_transfer_element_8cc_source.html">TransferElement.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 2 2017 21:11:45 for mtca4u-deviceaccess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
