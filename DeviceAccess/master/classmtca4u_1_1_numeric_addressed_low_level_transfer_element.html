<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mtca4u-deviceaccess: mtca4u::NumericAddressedLowLevelTransferElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DESY_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mtca4u-deviceaccess
   &#160;<span id="projectnumber">00.28.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemtca4u.html">mtca4u</a></li><li class="navelem"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html">NumericAddressedLowLevelTransferElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mtca4u::NumericAddressedLowLevelTransferElement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a> for NumericAddressedBackends, responsible for the underlying raw data access.  
 <a href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mtca4u::NumericAddressedLowLevelTransferElement:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.png" usemap="#mtca4u::NumericAddressedLowLevelTransferElement_map" alt=""/>
  <map id="mtca4u::NumericAddressedLowLevelTransferElement_map" name="mtca4u::NumericAddressedLowLevelTransferElement_map">
<area href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. " alt="mtca4u::TransferElement" shape="rect" coords="0,56,312,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa490e9ef5a6dcfa0ccb996ea242d1fbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa490e9ef5a6dcfa0ccb996ea242d1fbe">NumericAddressedLowLevelTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_numeric_addressed_backend.html">NumericAddressedBackend</a> &gt; dev, size_t bar, size_t startAddress, size_t numberOfWords)</td></tr>
<tr class="separator:aa490e9ef5a6dcfa0ccb996ea242d1fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13f0cf59e9703819e6dea9c3ce60066"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa13f0cf59e9703819e6dea9c3ce60066">~NumericAddressedLowLevelTransferElement</a> ()</td></tr>
<tr class="separator:aa13f0cf59e9703819e6dea9c3ce60066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a01173cb3a8eb388065716f877ae428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a9a01173cb3a8eb388065716f877ae428">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={}) final</td></tr>
<tr class="memdesc:a9a01173cb3a8eb388065716f877ae428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a9a01173cb3a8eb388065716f877ae428">More...</a><br /></td></tr>
<tr class="separator:a9a01173cb3a8eb388065716f877ae428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a763e3b953f26516a642d9fb9566503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8a763e3b953f26516a642d9fb9566503">read</a> () final</td></tr>
<tr class="memdesc:a8a763e3b953f26516a642d9fb9566503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#a8a763e3b953f26516a642d9fb9566503">More...</a><br /></td></tr>
<tr class="separator:a8a763e3b953f26516a642d9fb9566503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa7f4a4203547250a6f801fa8bc2b07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adaa7f4a4203547250a6f801fa8bc2b07">doReadTransfer</a> () override</td></tr>
<tr class="memdesc:adaa7f4a4203547250a6f801fa8bc2b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#adaa7f4a4203547250a6f801fa8bc2b07">More...</a><br /></td></tr>
<tr class="separator:adaa7f4a4203547250a6f801fa8bc2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023bb50b1f51068dc0137213edcd0f65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a023bb50b1f51068dc0137213edcd0f65">doWriteTransfer</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>={}) override</td></tr>
<tr class="memdesc:a023bb50b1f51068dc0137213edcd0f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a023bb50b1f51068dc0137213edcd0f65">More...</a><br /></td></tr>
<tr class="separator:a023bb50b1f51068dc0137213edcd0f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f011286aefc91ed504976091ce08ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#ab2f011286aefc91ed504976091ce08ec">doReadTransferNonBlocking</a> () override</td></tr>
<tr class="memdesc:ab2f011286aefc91ed504976091ce08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ab2f011286aefc91ed504976091ce08ec">More...</a><br /></td></tr>
<tr class="separator:ab2f011286aefc91ed504976091ce08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f2e6a88c0cddcd3e2fbed0b5266749"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a40f2e6a88c0cddcd3e2fbed0b5266749">doReadTransferLatest</a> () override</td></tr>
<tr class="memdesc:a40f2e6a88c0cddcd3e2fbed0b5266749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a40f2e6a88c0cddcd3e2fbed0b5266749">More...</a><br /></td></tr>
<tr class="separator:a40f2e6a88c0cddcd3e2fbed0b5266749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00777510899853221a9bb768f8230ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad">readNonBlocking</a> () final</td></tr>
<tr class="memdesc:aa00777510899853221a9bb768f8230ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#aa00777510899853221a9bb768f8230ad">More...</a><br /></td></tr>
<tr class="separator:aa00777510899853221a9bb768f8230ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3369483aa8f42f8f68a4d2807b9a84b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a3369483aa8f42f8f68a4d2807b9a84b9">readLatest</a> () final</td></tr>
<tr class="memdesc:a3369483aa8f42f8f68a4d2807b9a84b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#a3369483aa8f42f8f68a4d2807b9a84b9">More...</a><br /></td></tr>
<tr class="separator:a3369483aa8f42f8f68a4d2807b9a84b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2b8b05831d3efd05e4d9323602530c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aff2b8b05831d3efd05e4d9323602530c">readAsync</a> () override</td></tr>
<tr class="memdesc:aff2b8b05831d3efd05e4d9323602530c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#aff2b8b05831d3efd05e4d9323602530c">More...</a><br /></td></tr>
<tr class="separator:aff2b8b05831d3efd05e4d9323602530c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba10cb54b89531fbff657ff12dda1fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a0ba10cb54b89531fbff657ff12dda1fa">asyncTransferActive</a> () override</td></tr>
<tr class="memdesc:a0ba10cb54b89531fbff657ff12dda1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether there is an ongoing active asynchronous transfer.  <a href="#a0ba10cb54b89531fbff657ff12dda1fa">More...</a><br /></td></tr>
<tr class="separator:a0ba10cb54b89531fbff657ff12dda1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92af5a66b06fc4783e945e42738428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aeb92af5a66b06fc4783e945e42738428">clearAsyncTransferActive</a> () override</td></tr>
<tr class="memdesc:aeb92af5a66b06fc4783e945e42738428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the flag that there is an ongoing asynchronous transfer.  <a href="#aeb92af5a66b06fc4783e945e42738428">More...</a><br /></td></tr>
<tr class="separator:aeb92af5a66b06fc4783e945e42738428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc43cc93650c28a93c8c9718089902c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a9cc43cc93650c28a93c8c9718089902c">isMergeable</a> (const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;other) const </td></tr>
<tr class="memdesc:a9cc43cc93650c28a93c8c9718089902c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the address areas are adjacent and/or overlapping.  <a href="#a9cc43cc93650c28a93c8c9718089902c">More...</a><br /></td></tr>
<tr class="separator:a9cc43cc93650c28a93c8c9718089902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d42c95d34ea8e9f6016749719d6ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a6e7d42c95d34ea8e9f6016749719d6ac">mayReplaceOther</a> (const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;) const override</td></tr>
<tr class="memdesc:a6e7d42c95d34ea8e9f6016749719d6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> can be used in places where the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> "other" is currently used, e.g.  <a href="#a6e7d42c95d34ea8e9f6016749719d6ac">More...</a><br /></td></tr>
<tr class="separator:a6e7d42c95d34ea8e9f6016749719d6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa19333000184f262f21beac60ad8a"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8cfa19333000184f262f21beac60ad8a">getValueType</a> () const override</td></tr>
<tr class="memdesc:a8cfa19333000184f262f21beac60ad8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#a8cfa19333000184f262f21beac60ad8a">More...</a><br /></td></tr>
<tr class="separator:a8cfa19333000184f262f21beac60ad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f7323552a1ed0f33fdfb3d48652d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a74f7323552a1ed0f33fdfb3d48652d6e">isReadOnly</a> () const override</td></tr>
<tr class="memdesc:a74f7323552a1ed0f33fdfb3d48652d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <a href="#a74f7323552a1ed0f33fdfb3d48652d6e">More...</a><br /></td></tr>
<tr class="separator:a74f7323552a1ed0f33fdfb3d48652d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdd555501b2891d895602db8d5a9940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a5fdd555501b2891d895602db8d5a9940">isReadable</a> () const override</td></tr>
<tr class="memdesc:a5fdd555501b2891d895602db8d5a9940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#a5fdd555501b2891d895602db8d5a9940">More...</a><br /></td></tr>
<tr class="separator:a5fdd555501b2891d895602db8d5a9940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11924bf4382fc720e9829daf56f1355"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#ae11924bf4382fc720e9829daf56f1355">isWriteable</a> () const override</td></tr>
<tr class="memdesc:ae11924bf4382fc720e9829daf56f1355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#ae11924bf4382fc720e9829daf56f1355">More...</a><br /></td></tr>
<tr class="separator:ae11924bf4382fc720e9829daf56f1355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048e3a2a97263f9e1af55e7f45a7266f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a048e3a2a97263f9e1af55e7f45a7266f">begin</a> (size_t addressInBar)</td></tr>
<tr class="memdesc:a048e3a2a97263f9e1af55e7f45a7266f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return accessor to the begin of the raw buffer matching the given address.  <a href="#a048e3a2a97263f9e1af55e7f45a7266f">More...</a><br /></td></tr>
<tr class="separator:a048e3a2a97263f9e1af55e7f45a7266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b0bf5e83fb8d21876f96e41dbe8ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a51b0bf5e83fb8d21876f96e41dbe8ee1">changeAddress</a> (size_t startAddress, size_t numberOfWords)</td></tr>
<tr class="memdesc:a51b0bf5e83fb8d21876f96e41dbe8ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the start address (inside the bar given in the constructor) and number of words of this accessor, and set the shared flag.  <a href="#a51b0bf5e83fb8d21876f96e41dbe8ee1">More...</a><br /></td></tr>
<tr class="separator:a51b0bf5e83fb8d21876f96e41dbe8ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a9901e666ac60d41473a69bae04859871">TransferElement</a> (std::string const &amp;name=std::string(), std::string const &amp;unit=std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer element with the specified name.  <a href="#a9901e666ac60d41473a69bae04859871">More...</a><br /></td></tr>
<tr class="separator:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a32ac07c9d4fab89208a93016a101898a">TransferElement</a> (const <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &amp;other)</td></tr>
<tr class="memdesc:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: do not allow copying when in <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>, remove asynchronous read state.  <a href="#a32ac07c9d4fab89208a93016a101898a">More...</a><br /></td></tr>
<tr class="separator:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aa578ad1991d6b9763b5cc8096220af0d">~TransferElement</a> ()</td></tr>
<tr class="memdesc:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <a href="#aa578ad1991d6b9763b5cc8096220af0d">More...</a><br /></td></tr>
<tr class="separator:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a1b1ecc0786839b0949f13a4203187e5b">getName</a> () const </td></tr>
<tr class="memdesc:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#a1b1ecc0786839b0949f13a4203187e5b">More...</a><br /></td></tr>
<tr class="separator:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a95f64bf74aed8bb95796dafaff5ddd98">getUnit</a> () const </td></tr>
<tr class="memdesc:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#a95f64bf74aed8bb95796dafaff5ddd98">More...</a><br /></td></tr>
<tr class="separator:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adc66ca9c081ec77cf6d9cc64a4c267fb">getDescription</a> () const </td></tr>
<tr class="memdesc:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#adc66ca9c081ec77cf6d9cc64a4c267fb">More...</a><br /></td></tr>
<tr class="separator:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e7690a5dbba2e34a0fc8f91f4af5ca inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a77e7690a5dbba2e34a0fc8f91f4af5ca">getVersionNumber</a> () const </td></tr>
<tr class="memdesc:a77e7690a5dbba2e34a0fc8f91f4af5ca inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#a77e7690a5dbba2e34a0fc8f91f4af5ca">More...</a><br /></td></tr>
<tr class="separator:a77e7690a5dbba2e34a0fc8f91f4af5ca inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fccb4f40373d618857e7ab6cf9b8912 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912">preRead</a> ()</td></tr>
<tr class="memdesc:a1fccb4f40373d618857e7ab6cf9b8912 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any pre-read tasks if necessary.  <a href="#a1fccb4f40373d618857e7ab6cf9b8912">More...</a><br /></td></tr>
<tr class="separator:a1fccb4f40373d618857e7ab6cf9b8912 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2defb63b7607f31ad773ce01bdc69f47 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47">postRead</a> ()</td></tr>
<tr class="memdesc:a2defb63b7607f31ad773ce01bdc69f47 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed.  <a href="#a2defb63b7607f31ad773ce01bdc69f47">More...</a><br /></td></tr>
<tr class="separator:a2defb63b7607f31ad773ce01bdc69f47 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d747fecded78470b7c9e64703e8238 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a60d747fecded78470b7c9e64703e8238">transferFutureWaitCallback</a> ()</td></tr>
<tr class="memdesc:a60d747fecded78470b7c9e64703e8238 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by the TransferFuture before entering a potentially blocking wait().  <a href="#a60d747fecded78470b7c9e64703e8238">More...</a><br /></td></tr>
<tr class="separator:a60d747fecded78470b7c9e64703e8238 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd483871e80ff7eb6c2c8094b00353 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a02dd483871e80ff7eb6c2c8094b00353">preWrite</a> ()</td></tr>
<tr class="memdesc:a02dd483871e80ff7eb6c2c8094b00353 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed.  <a href="#a02dd483871e80ff7eb6c2c8094b00353">More...</a><br /></td></tr>
<tr class="separator:a02dd483871e80ff7eb6c2c8094b00353 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab68105cb64b7a456b7e61bf9bb5b23c inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aab68105cb64b7a456b7e61bf9bb5b23c">postWrite</a> ()</td></tr>
<tr class="memdesc:aab68105cb64b7a456b7e61bf9bb5b23c inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any post-write cleanups if necessary.  <a href="#aab68105cb64b7a456b7e61bf9bb5b23c">More...</a><br /></td></tr>
<tr class="separator:aab68105cb64b7a456b7e61bf9bb5b23c inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmtca4u_1_1_time_stamp.html">TimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aeedfb9d715e3077bad6312238e411998">getTimeStamp</a> () const </td></tr>
<tr class="memdesc:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aeedfb9d715e3077bad6312238e411998">More...</a><br /></td></tr>
<tr class="separator:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aac3faef1e424f7eb1546f1aa7aa34d85">isArray</a> () const </td></tr>
<tr class="memdesc:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aac3faef1e424f7eb1546f1aa7aa34d85">More...</a><br /></td></tr>
<tr class="separator:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174b74892bb5aa866b0be19c73e67542 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a174b74892bb5aa866b0be19c73e67542">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:a174b74892bb5aa866b0be19c73e67542 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a174b74892bb5aa866b0be19c73e67542">More...</a><br /></td></tr>
<tr class="separator:a174b74892bb5aa866b0be19c73e67542 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8a0815a31412f1e862dff4bf6b5f90d4">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;)</td></tr>
<tr class="memdesc:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a8a0815a31412f1e862dff4bf6b5f90d4">More...</a><br /></td></tr>
<tr class="separator:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7779fc0a610a11a1b9758a2584fa6ce inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ab7779fc0a610a11a1b9758a2584fa6ce">getId</a> () const </td></tr>
<tr class="memdesc:ab7779fc0a610a11a1b9758a2584fa6ce inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> for this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ab7779fc0a610a11a1b9758a2584fa6ce">More...</a><br /></td></tr>
<tr class="separator:ab7779fc0a610a11a1b9758a2584fa6ce inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4fb173eb535ac26d9f3c2976466f55fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a4fb173eb535ac26d9f3c2976466f55fa">setAddress</a> (size_t startAddress, size_t numberOfWords)</td></tr>
<tr class="memdesc:a4fb173eb535ac26d9f3c2976466f55fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the start address (inside the bar given in the constructor) and number of words of this accessor.  <a href="#a4fb173eb535ac26d9f3c2976466f55fa">More...</a><br /></td></tr>
<tr class="separator:a4fb173eb535ac26d9f3c2976466f55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f246ea1a2a8f7cdcd3b44d145bf2d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a656f246ea1a2a8f7cdcd3b44d145bf2d">getHardwareAccessingElements</a> () override</td></tr>
<tr class="memdesc:a656f246ea1a2a8f7cdcd3b44d145bf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a656f246ea1a2a8f7cdcd3b44d145bf2d">More...</a><br /></td></tr>
<tr class="separator:a656f246ea1a2a8f7cdcd3b44d145bf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d51aa72b09a08e3ca914dd7c55c92"><td class="memItemLeft" align="right" valign="top">std::list&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a3f3d51aa72b09a08e3ca914dd7c55c92">getInternalElements</a> () override</td></tr>
<tr class="memdesc:a3f3d51aa72b09a08e3ca914dd7c55c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the full list of TransferElements internally used by this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a3f3d51aa72b09a08e3ca914dd7c55c92">More...</a><br /></td></tr>
<tr class="separator:a3f3d51aa72b09a08e3ca914dd7c55c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebf8dcace64cf630d6ce574208165fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adebf8dcace64cf630d6ce574208165fd">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;) override</td></tr>
<tr class="memdesc:adebf8dcace64cf630d6ce574208165fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#adebf8dcace64cf630d6ce574208165fd">More...</a><br /></td></tr>
<tr class="separator:adebf8dcace64cf630d6ce574208165fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:af76d51407d97f19876485ef00718b952 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af76d51407d97f19876485ef00718b952">doPreRead</a> ()</td></tr>
<tr class="memdesc:af76d51407d97f19876485ef00718b952 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912" title="Perform any pre-read tasks if necessary. ">preRead()</a>.  <a href="#af76d51407d97f19876485ef00718b952">More...</a><br /></td></tr>
<tr class="separator:af76d51407d97f19876485ef00718b952 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fde8c821f856ea7b193c23e2383e056 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a6fde8c821f856ea7b193c23e2383e056">doPostRead</a> ()</td></tr>
<tr class="memdesc:a6fde8c821f856ea7b193c23e2383e056 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a>.  <a href="#a6fde8c821f856ea7b193c23e2383e056">More...</a><br /></td></tr>
<tr class="separator:a6fde8c821f856ea7b193c23e2383e056 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba4c8bcac2ae34dd8c2858bfcd24104 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a7ba4c8bcac2ae34dd8c2858bfcd24104">doPreWrite</a> ()</td></tr>
<tr class="memdesc:a7ba4c8bcac2ae34dd8c2858bfcd24104 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="classmtca4u_1_1_transfer_element.html#a02dd483871e80ff7eb6c2c8094b00353" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a>.  <a href="#a7ba4c8bcac2ae34dd8c2858bfcd24104">More...</a><br /></td></tr>
<tr class="separator:a7ba4c8bcac2ae34dd8c2858bfcd24104 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57b6bd901fd269b79786dd659811b76 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ab57b6bd901fd269b79786dd659811b76">doPostWrite</a> ()</td></tr>
<tr class="memdesc:ab57b6bd901fd269b79786dd659811b76 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="classmtca4u_1_1_transfer_element.html#aab68105cb64b7a456b7e61bf9bb5b23c" title="Perform any post-write cleanups if necessary. ">postWrite()</a>.  <a href="#ab57b6bd901fd269b79786dd659811b76">More...</a><br /></td></tr>
<tr class="separator:ab57b6bd901fd269b79786dd659811b76 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e8a733a92e5a36ab6466e8fec43d7 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af76e8a733a92e5a36ab6466e8fec43d7">makeUniqueId</a> ()</td></tr>
<tr class="memdesc:af76e8a733a92e5a36ab6466e8fec43d7 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow generating a unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> from derived classes.  <a href="#af76e8a733a92e5a36ab6466e8fec43d7">More...</a><br /></td></tr>
<tr class="separator:af76e8a733a92e5a36ab6466e8fec43d7 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aae70a7cbd152d6881517d922584c494c"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_numeric_addressed_backend.html">NumericAddressedBackend</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aae70a7cbd152d6881517d922584c494c">_dev</a></td></tr>
<tr class="memdesc:aae70a7cbd152d6881517d922584c494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the backend to use for the actual hardware access  <a href="#aae70a7cbd152d6881517d922584c494c">More...</a><br /></td></tr>
<tr class="separator:aae70a7cbd152d6881517d922584c494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b343bb930c301c14cec996afc34344"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a08b343bb930c301c14cec996afc34344">_bar</a></td></tr>
<tr class="memdesc:a08b343bb930c301c14cec996afc34344"><td class="mdescLeft">&#160;</td><td class="mdescRight">start address w.r.t.  <a href="#a08b343bb930c301c14cec996afc34344">More...</a><br /></td></tr>
<tr class="separator:a08b343bb930c301c14cec996afc34344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad734c221dbb7a050b8e80b133c387ceb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#ad734c221dbb7a050b8e80b133c387ceb">_startAddress</a></td></tr>
<tr class="memdesc:ad734c221dbb7a050b8e80b133c387ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">start address w.r.t.  <a href="#ad734c221dbb7a050b8e80b133c387ceb">More...</a><br /></td></tr>
<tr class="separator:ad734c221dbb7a050b8e80b133c387ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875e8abdc31275f7c63a0ef53aafe739"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a875e8abdc31275f7c63a0ef53aafe739">_numberOfWords</a></td></tr>
<tr class="memdesc:a875e8abdc31275f7c63a0ef53aafe739"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of 4-byte words to access  <a href="#a875e8abdc31275f7c63a0ef53aafe739">More...</a><br /></td></tr>
<tr class="separator:a875e8abdc31275f7c63a0ef53aafe739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322324a253ccc892b2bbe65b92e2f512"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a322324a253ccc892b2bbe65b92e2f512">_numberOfBytes</a></td></tr>
<tr class="memdesc:a322324a253ccc892b2bbe65b92e2f512"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes to access  <a href="#a322324a253ccc892b2bbe65b92e2f512">More...</a><br /></td></tr>
<tr class="separator:a322324a253ccc892b2bbe65b92e2f512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9552030b215cc56311c4862a6d7c569a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a9552030b215cc56311c4862a6d7c569a">isShared</a></td></tr>
<tr class="memdesc:a9552030b215cc56311c4862a6d7c569a"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag if <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a51b0bf5e83fb8d21876f96e41dbe8ee1" title="Change the start address (inside the bar given in the constructor) and number of words of this access...">changeAddress()</a> has been called, which is this low-level transfer element is shared between multiple accessors  <a href="#a9552030b215cc56311c4862a6d7c569a">More...</a><br /></td></tr>
<tr class="separator:a9552030b215cc56311c4862a6d7c569a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44fe1a822ddc97f5213438d5012fa9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#af44fe1a822ddc97f5213438d5012fa9c">rawDataBuffer</a></td></tr>
<tr class="memdesc:af44fe1a822ddc97f5213438d5012fa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw buffer  <a href="#af44fe1a822ddc97f5213438d5012fa9c">More...</a><br /></td></tr>
<tr class="separator:af44fe1a822ddc97f5213438d5012fa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a674e1814502195c7545c0d6512f65fcc">_name</a></td></tr>
<tr class="memdesc:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier uniquely identifying the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a674e1814502195c7545c0d6512f65fcc">More...</a><br /></td></tr>
<tr class="separator:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a53051ab33dd295fa8d14007159d5498c">_unit</a></td></tr>
<tr class="memdesc:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engineering unit.  <a href="#a53051ab33dd295fa8d14007159d5498c">More...</a><br /></td></tr>
<tr class="separator:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adaebf84a4baead76fcca5b38bead596a">_description</a></td></tr>
<tr class="memdesc:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of this variable/register.  <a href="#adaebf84a4baead76fcca5b38bead596a">More...</a><br /></td></tr>
<tr class="separator:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472a62db198011226904af5d41aec7b inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a3472a62db198011226904af5d41aec7b">_id</a></td></tr>
<tr class="memdesc:a3472a62db198011226904af5d41aec7b inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a3472a62db198011226904af5d41aec7b">More...</a><br /></td></tr>
<tr class="separator:a3472a62db198011226904af5d41aec7b inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a04f6bbbd0a7230f21c0900541efc5336">isInTransferGroup</a></td></tr>
<tr class="memdesc:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not.  <a href="#a04f6bbbd0a7230f21c0900541efc5336">More...</a><br /></td></tr>
<tr class="separator:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af175d23409e5e26ed804aab0caac497f inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af175d23409e5e26ed804aab0caac497f">readTransactionInProgress</a> {false}</td></tr>
<tr class="memdesc:af175d23409e5e26ed804aab0caac497f inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether a read transaction is in progress.  <a href="#af175d23409e5e26ed804aab0caac497f">More...</a><br /></td></tr>
<tr class="separator:af175d23409e5e26ed804aab0caac497f inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af9f3df3e0241b4fb7fec94d5b8c24 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ae8af9f3df3e0241b4fb7fec94d5b8c24">writeTransactionInProgress</a> {false}</td></tr>
<tr class="memdesc:ae8af9f3df3e0241b4fb7fec94d5b8c24 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether a write transaction is in progress.  <a href="#ae8af9f3df3e0241b4fb7fec94d5b8c24">More...</a><br /></td></tr>
<tr class="separator:ae8af9f3df3e0241b4fb7fec94d5b8c24 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2da661d92f7e3cc19e8c9847b0a99afe"><td class="memTemplParams" colspan="2">template&lt;typename UserType &gt; </td></tr>
<tr class="memitem:a2da661d92f7e3cc19e8c9847b0a99afe"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a2da661d92f7e3cc19e8c9847b0a99afe">NumericAddressedBackendRegisterAccessor</a></td></tr>
<tr class="separator:a2da661d92f7e3cc19e8c9847b0a99afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0db950554a40340e7aeca3249ca2d46d">SharedPtr</a></td></tr>
<tr class="memdesc:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for more compact syntax.  <a href="#a0db950554a40340e7aeca3249ca2d46d">More...</a><br /></td></tr>
<tr class="separator:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:ae22fdbe57951c132c5af6b8634de04fc inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">TransferElement::ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ae22fdbe57951c132c5af6b8634de04fc">readAny</a> (std::list&lt; std::reference_wrapper&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&gt; elementsToRead)</td></tr>
<tr class="memdesc:ae22fdbe57951c132c5af6b8634de04fc inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data asynchronously from all given TransferElements and wait until one of the TransferElements has new data.  <a href="#ae22fdbe57951c132c5af6b8634de04fc">More...</a><br /></td></tr>
<tr class="separator:ae22fdbe57951c132c5af6b8634de04fc inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a> [] = &quot;n./a.&quot;</td></tr>
<tr class="memdesc:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant string to be used as a unit when the unit is not provided or known.  <a href="#a05577297da10eba9575c1606efb838b9">More...</a><br /></td></tr>
<tr class="separator:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a> for NumericAddressedBackends, responsible for the underlying raw data access. </p>
<p>This accessor is never directly returned to the user and thus is based only on the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> base class (unstead of the <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a>). It is only internally used by other register accessors of the NumericAddressBackends. The reason for introducing this class is that it allows the <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> to replace the raw accessor used by other accessors to merge data transfers of neighbouring registers. </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00027">27</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa490e9ef5a6dcfa0ccb996ea242d1fbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mtca4u::NumericAddressedLowLevelTransferElement::NumericAddressedLowLevelTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_numeric_addressed_backend.html">NumericAddressedBackend</a> &gt;&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00030">30</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa13f0cf59e9703819e6dea9c3ce60066"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mtca4u::NumericAddressedLowLevelTransferElement::~NumericAddressedLowLevelTransferElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00037">37</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0ba10cb54b89531fbff657ff12dda1fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::asyncTransferActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether there is an ongoing active asynchronous transfer. </p>
<p>An asynchronous transfer is considered active from the call to <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aff2b8b05831d3efd05e4d9323602530c" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> until wait() has been called on the future (directly or indirectly by successfully calling another read function on the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>). </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a298b4e231cb3f426d70d12685ecd40fa">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00095">95</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a048e3a2a97263f9e1af55e7f45a7266f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int32_t&gt;::iterator mtca4u::NumericAddressedLowLevelTransferElement::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>addressInBar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return accessor to the begin of the raw buffer matching the given address. </p>
<p>No <a class="el" href="_register_info_map_8cpp.html#a204a3f4fa39b9c007f9784d3e4af4667">end()</a> is provided, since the <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for scalar and 1D registers...">NumericAddressedBackendRegisterAccessor</a> using this functionality uses the cooked buffer for this check. Only addresses within the range specified in the constructor or <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a51b0bf5e83fb8d21876f96e41dbe8ee1" title="Change the start address (inside the bar given in the constructor) and number of words of this access...">changeAddress()</a> may be passed. The address must also have an integer multiple of the word size as an offset w.r.t. the start address specified in the constructor. Otherwise an undefined behaviour will occur! </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00152">152</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51b0bf5e83fb8d21876f96e41dbe8ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::NumericAddressedLowLevelTransferElement::changeAddress </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the start address (inside the bar given in the constructor) and number of words of this accessor, and set the shared flag. </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00157">157</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb92af5a66b06fc4783e945e42738428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::NumericAddressedLowLevelTransferElement::clearAsyncTransferActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the flag that there is an ongoing asynchronous transfer. </p>
<p>This function will be called by <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> and must be passed on in decorators. Do not otherwise use this function! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a334ff9a3d121ba2be690c37537730e57">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00101">101</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaa7f4a4203547250a6f801fa8bc2b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::NumericAddressedLowLevelTransferElement::doReadTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function after <a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912" title="Perform any pre-read tasks if necessary. ">preRead()</a> and followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8a763e3b953f26516a642d9fb9566503" title="Read the data from the device. ">read()</a>.</p>
<p>Implementation note: This function must return within ~1 second after boost::thread::interrupt() has been called on the thread calling this function. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a3eb02e2fa3228e645f6ff88d10226381">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00053">53</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40f2e6a88c0cddcd3e2fbed0b5266749"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::doReadTransferLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function after <a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912" title="Perform any pre-read tasks if necessary. ">preRead()</a> and followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a3369483aa8f42f8f68a4d2807b9a84b9" title="Read the latest value, discarding any other update since the last read if present. ">readLatest()</a>. For the return value, see <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a095ac74aa9aa2fc21baa37d9e07e85e1">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00067">67</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab2f011286aefc91ed504976091ce08ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::doReadTransferNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function after <a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912" title="Perform any pre-read tasks if necessary. ">preRead()</a> and followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. For the return value, see <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#ad313e332b8bf872eade35bd4cdec9462">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00062">62</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a023bb50b1f51068dc0137213edcd0f65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::doWriteTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false.</p>
<p>Calling this function after <a class="el" href="classmtca4u_1_1_transfer_element.html#a02dd483871e80ff7eb6c2c8094b00353" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> and followed by <a class="el" href="classmtca4u_1_1_transfer_element.html#aab68105cb64b7a456b7e61bf9bb5b23c" title="Perform any post-write cleanups if necessary. ">postWrite()</a> is exactly equivalent to a call to <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a9a01173cb3a8eb388065716f877ae428" title="Write the data to device. ">write()</a>. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#af1f7a496c406682b61a54316d10bb45e">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00057">57</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a656f246ea1a2a8f7cdcd3b44d145bf2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; &gt; mtca4u::NumericAddressedLowLevelTransferElement::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a4c43acb77928d2ccc12829d1b386195b">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00202">202</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f3d51aa72b09a08e3ca914dd7c55c92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; &gt; mtca4u::NumericAddressedLowLevelTransferElement::getInternalElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the full list of TransferElements internally used by this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>The function is recursive, i.e. elements used by the elements returned by this function are also added to the list. It is guaranteed that the directly used elements are first in the list and the result from recursion is appended to the list.</p>
<p>Example: A decorator would return a list with its target <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> followed by the result of <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a3f3d51aa72b09a08e3ca914dd7c55c92" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a> called on its target <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.</p>
<p>If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is not using any other element, it should return an empty vector. Thus those elements which return a list just containing themselves in <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a656f246ea1a2a8f7cdcd3b44d145bf2d" title="Obtain the underlying TransferElements with actual hardware access. ">getHardwareAccessingElements()</a> will return an empty list here in <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a3f3d51aa72b09a08e3ca914dd7c55c92" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a>.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#aa456e62c843c9c5f7dc6c839c17e239e">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00206">206</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8cfa19333000184f262f21beac60ad8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; mtca4u::NumericAddressedLowLevelTransferElement::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a475c56d5d123fd245ff352808c281ea2">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00129">129</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9cc43cc93650c28a93c8c9718089902c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::isMergeable </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the address areas are adjacent and/or overlapping. </p>
<p><a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#ad0ba0f16a3e676c2349d16a2c19dabbb" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">NumericAddressedBackendRegisterAccessor::replaceTransferElement()</a> takes care of replacing the NumericAddressedBackendRawAccessors with a single NumericAddressedBackendRawAccessor covering the address space of both accessors. </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00112">112</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5fdd555501b2891d895602db8d5a9940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a5fdd555501b2891d895602db8d5a9940" title="Check if transfer element is readable. ">isReadable()</a> is not true. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a55e803ec5758a3cd2d25a1e743e24d5c">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00139">139</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a74f7323552a1ed0f33fdfb3d48652d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a2807cd6932846d6988b9fb645a420e9b">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00135">135</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae11924bf4382fc720e9829daf56f1355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#ae11924bf4382fc720e9829daf56f1355" title="Check if transfer element is writeable. ">isWriteable()</a> is not true. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#aa0e9f2ec21138931f5f8c5cdc03c11a4">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00143">143</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e7d42c95d34ea8e9f6016749719d6ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::mayReplaceOther </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> can be used in places where the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> "other" is currently used, e.g. </p>
<p>to merge the two transfers. This function must be used in <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adebf8dcace64cf630d6ce574208165fd" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> by implementations which use other TransferElements, to determine if a used <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> shall be replaced with the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> "other".</p>
<p>The purpose of this function is not to determine if at any point in the hierarchy an replacement could be done. This function only works on a single level. It is not used by the <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> to determine <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adebf8dcace64cf630d6ce574208165fd" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> whether shall be used (it is always called). Instead this function can be used by decorators etc. inside their implementation of <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adebf8dcace64cf630d6ce574208165fd" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> to determine if they might swap their implementation(s).</p>
<p>Note for decorators and similar implementations: This function must not be decorated. It should only return true if this should actually be replaced with other in the call to <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#adebf8dcace64cf630d6ce574208165fd" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> one level up in the hierarchy. If the replacement should be done further down in the hierarchy, simply return false. It should only return if other is fully identical to this (i.e. behaves identical in all situations but might be another instance). </p>

<p>Reimplemented from <a class="el" href="classmtca4u_1_1_transfer_element.html#ab99387f62e43b18cb4f5f00ed2bb7a97">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00125">125</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a763e3b953f26516a642d9fb9566503"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::NumericAddressedLowLevelTransferElement::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#aff8dfb35106ffe971cb900a87c22a1a3">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00046">46</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff2b8b05831d3efd05e4d9323602530c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> mtca4u::NumericAddressedLowLevelTransferElement::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8a763e3b953f26516a642d9fb9566503" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8a763e3b953f26516a642d9fb9566503" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8a763e3b953f26516a642d9fb9566503" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElement::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread.</p>
<p>Note for implementations: Inside this function and before launching the actual transfer, the flag readTransactionInProgress must be cleared, then <a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912" title="Perform any pre-read tasks if necessary. ">preRead()</a> has to be called. Otherwise <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> will not get executed after the transfer. <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> on the other hand must not be called inside this function, since this would update the user buffer, which should only happen when waiting on the TransferFuture. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> will automatically call <a class="el" href="classmtca4u_1_1_transfer_element.html#a2defb63b7607f31ad773ce01bdc69f47" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> before returning. Decorators must also call <a class="el" href="classmtca4u_1_1_transfer_element.html#a1fccb4f40373d618857e7ab6cf9b8912" title="Perform any pre-read tasks if necessary. ">preRead()</a> in their implementations of <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aff2b8b05831d3efd05e4d9323602530c" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>!</p>
<p>Note: This feature is still experimental. Expect API changes without notice! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a8d7b8e3adc6afdf6fd873c19f149067e">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00088">88</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3369483aa8f42f8f68a4d2807b9a84b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#aa00777510899853221a9bb768f8230ad" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a3664a01fdc6f463ad0f0516742000c5c">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00080">80</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa00777510899853221a9bb768f8230ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a8a763e3b953f26516a642d9fb9566503" title="Read the data from the device. ">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a2165a21cef5394f18d1dcbd227801260">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00072">72</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="adebf8dcace64cf630d6ce574208165fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::NumericAddressedLowLevelTransferElement::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect. </p>

<p>Reimplemented from <a class="el" href="classmtca4u_1_1_transfer_element.html#a2637a2b7ac207c0becd4ef0548d2126e">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00210">210</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4fb173eb535ac26d9f3c2976466f55fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::NumericAddressedLowLevelTransferElement::setAddress </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numberOfWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the start address (inside the bar given in the constructor) and number of words of this accessor. </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00165">165</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a01173cb3a8eb388065716f877ae428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a06b2fdb9a6dea04fd343edf9511a0159">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00039">39</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2da661d92f7e3cc19e8c9847b0a99afe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html">NumericAddressedBackendRegisterAccessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00213">213</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a08b343bb930c301c14cec996afc34344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtca4u::NumericAddressedLowLevelTransferElement::_bar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start address w.r.t. </p>
<p>the PCIe bar </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00184">184</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aae70a7cbd152d6881517d922584c494c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_numeric_addressed_backend.html">NumericAddressedBackend</a>&gt; mtca4u::NumericAddressedLowLevelTransferElement::_dev</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the backend to use for the actual hardware access </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00181">181</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a322324a253ccc892b2bbe65b92e2f512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtca4u::NumericAddressedLowLevelTransferElement::_numberOfBytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of bytes to access </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00193">193</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a875e8abdc31275f7c63a0ef53aafe739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtca4u::NumericAddressedLowLevelTransferElement::_numberOfWords</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of 4-byte words to access </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00190">190</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad734c221dbb7a050b8e80b133c387ceb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mtca4u::NumericAddressedLowLevelTransferElement::_startAddress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start address w.r.t. </p>
<p>the PCIe bar </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00187">187</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9552030b215cc56311c4862a6d7c569a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::NumericAddressedLowLevelTransferElement::isShared</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>flag if <a class="el" href="classmtca4u_1_1_numeric_addressed_low_level_transfer_element.html#a51b0bf5e83fb8d21876f96e41dbe8ee1" title="Change the start address (inside the bar given in the constructor) and number of words of this access...">changeAddress()</a> has been called, which is this low-level transfer element is shared between multiple accessors </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00197">197</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="af44fe1a822ddc97f5213438d5012fa9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int32_t&gt; mtca4u::NumericAddressedLowLevelTransferElement::rawDataBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>raw buffer </p>

<p>Definition at line <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html#l00200">200</a> of file <a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device_backends/include/<a class="el" href="_numeric_addressed_low_level_transfer_element_8h_source.html">NumericAddressedLowLevelTransferElement.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 16 2017 06:17:15 for mtca4u-deviceaccess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
