<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mtca4u-deviceaccess: mtca4u::TransferElementAbstractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DESY_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mtca4u-deviceaccess
   &#160;<span id="projectnumber">00.29.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemtca4u.html">mtca4u</a></li><li class="navelem"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmtca4u_1_1_transfer_element_abstractor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mtca4u::TransferElementAbstractor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for register accessors abstractors independent of the UserType.  
 <a href="classmtca4u_1_1_transfer_element_abstractor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mtca4u::TransferElementAbstractor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmtca4u_1_1_transfer_element_abstractor.png" usemap="#mtca4u::TransferElementAbstractor_map" alt=""/>
  <map id="mtca4u::TransferElementAbstractor_map" name="mtca4u::TransferElementAbstractor_map">
<area href="structmtca4u_1_1detail_1_1_transfer_group_transfer_element_abstractor.html" title="just used in TransferGroup::addAccessor(const boost::shared_ptr&lt;TransferElement&gt; &amp;accessor) ..." alt="mtca4u::detail::TransferGroupTransferElementAbstractor" shape="rect" coords="0,56,328,80"/>
<area href="classmtca4u_1_1_n_d_register_accessor_abstractor.html" title="Base class for the reigster accessor abstractors (ScalarRegisterAccessor, OneDRegisterAccessor and Tw..." alt="mtca4u::NDRegisterAccessorAbstractor&lt; UserType &gt;" shape="rect" coords="507,56,835,80"/>
<area href="classmtca4u_1_1_buffering_register_accessor.html" title="DEPRECATED! Use OneDRegisterAccessor or ScalarRegisterAccessor instead! " alt="mtca4u::BufferingRegisterAccessor&lt; UserType &gt;" shape="rect" coords="0,112,328,136"/>
<area href="classmtca4u_1_1_one_d_register_accessor.html" title="Accessor class to read and write registers transparently by using the accessor object like a vector o..." alt="mtca4u::OneDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="338,112,666,136"/>
<area href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v..." alt="mtca4u::ScalarRegisterAccessor&lt; UserType &gt;" shape="rect" coords="676,112,1004,136"/>
<area href="classmtca4u_1_1_two_d_register_accessor.html" title="TODO add documentation. " alt="mtca4u::TwoDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1014,112,1342,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca23dd9f4cbfc319ede1fa02677d9b5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#aca23dd9f4cbfc319ede1fa02677d9b5a">TransferElementAbstractor</a> ()</td></tr>
<tr class="memdesc:aca23dd9f4cbfc319ede1fa02677d9b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialised abstractor - just for late initialisation.  <a href="#aca23dd9f4cbfc319ede1fa02677d9b5a">More...</a><br /></td></tr>
<tr class="separator:aca23dd9f4cbfc319ede1fa02677d9b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dd8dbd11a1d4e12992b2c00df6808e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a76dd8dbd11a1d4e12992b2c00df6808e">~TransferElementAbstractor</a> ()</td></tr>
<tr class="memdesc:a76dd8dbd11a1d4e12992b2c00df6808e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <a href="#a76dd8dbd11a1d4e12992b2c00df6808e">More...</a><br /></td></tr>
<tr class="separator:a76dd8dbd11a1d4e12992b2c00df6808e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90dffb0c0d7939783e2905ecd0f96bf"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#ac90dffb0c0d7939783e2905ecd0f96bf">getName</a> () const </td></tr>
<tr class="memdesc:ac90dffb0c0d7939783e2905ecd0f96bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#ac90dffb0c0d7939783e2905ecd0f96bf">More...</a><br /></td></tr>
<tr class="separator:ac90dffb0c0d7939783e2905ecd0f96bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14523486d7ded2a40326ee46038998b0"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a14523486d7ded2a40326ee46038998b0">getUnit</a> () const </td></tr>
<tr class="memdesc:a14523486d7ded2a40326ee46038998b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#a14523486d7ded2a40326ee46038998b0">More...</a><br /></td></tr>
<tr class="separator:a14523486d7ded2a40326ee46038998b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf8d80bc2f0cb7a076568bbe54760f"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#afbbf8d80bc2f0cb7a076568bbe54760f">getDescription</a> () const </td></tr>
<tr class="memdesc:afbbf8d80bc2f0cb7a076568bbe54760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#afbbf8d80bc2f0cb7a076568bbe54760f">More...</a><br /></td></tr>
<tr class="separator:afbbf8d80bc2f0cb7a076568bbe54760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff937868ad793685688c0f02a477d7f"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a2ff937868ad793685688c0f02a477d7f">getValueType</a> () const </td></tr>
<tr class="memdesc:a2ff937868ad793685688c0f02a477d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#a2ff937868ad793685688c0f02a477d7f">More...</a><br /></td></tr>
<tr class="separator:a2ff937868ad793685688c0f02a477d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d217489cc7323843a2f398ee8fdd7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a18d217489cc7323843a2f398ee8fdd7e">read</a> ()</td></tr>
<tr class="memdesc:a18d217489cc7323843a2f398ee8fdd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#a18d217489cc7323843a2f398ee8fdd7e">More...</a><br /></td></tr>
<tr class="separator:a18d217489cc7323843a2f398ee8fdd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ceb976a13604dd140fd0b684b2ea94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a92ceb976a13604dd140fd0b684b2ea94">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:a92ceb976a13604dd140fd0b684b2ea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#a92ceb976a13604dd140fd0b684b2ea94">More...</a><br /></td></tr>
<tr class="separator:a92ceb976a13604dd140fd0b684b2ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a91e45e3729ca5b3de3fb6763c98db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#aa0a91e45e3729ca5b3de3fb6763c98db">readLatest</a> ()</td></tr>
<tr class="memdesc:aa0a91e45e3729ca5b3de3fb6763c98db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#aa0a91e45e3729ca5b3de3fb6763c98db">More...</a><br /></td></tr>
<tr class="separator:aa0a91e45e3729ca5b3de3fb6763c98db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e21952c00c6bda8bd99f5e22998134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a88e21952c00c6bda8bd99f5e22998134">readAsync</a> ()</td></tr>
<tr class="memdesc:a88e21952c00c6bda8bd99f5e22998134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#a88e21952c00c6bda8bd99f5e22998134">More...</a><br /></td></tr>
<tr class="separator:a88e21952c00c6bda8bd99f5e22998134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fdfada5c7f9ebe2c9d4579ceb87206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a17fdfada5c7f9ebe2c9d4579ceb87206">getVersionNumber</a> () const </td></tr>
<tr class="memdesc:a17fdfada5c7f9ebe2c9d4579ceb87206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#a17fdfada5c7f9ebe2c9d4579ceb87206">More...</a><br /></td></tr>
<tr class="separator:a17fdfada5c7f9ebe2c9d4579ceb87206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c53b8c4d7e35e3c717ec8a2e3e6c11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a33c53b8c4d7e35e3c717ec8a2e3e6c11">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:a33c53b8c4d7e35e3c717ec8a2e3e6c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a33c53b8c4d7e35e3c717ec8a2e3e6c11">More...</a><br /></td></tr>
<tr class="separator:a33c53b8c4d7e35e3c717ec8a2e3e6c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd3b8268a9b68aad64c2a549c97fbcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a4cd3b8268a9b68aad64c2a549c97fbcb">isReadOnly</a> () const </td></tr>
<tr class="memdesc:a4cd3b8268a9b68aad64c2a549c97fbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <a href="#a4cd3b8268a9b68aad64c2a549c97fbcb">More...</a><br /></td></tr>
<tr class="separator:a4cd3b8268a9b68aad64c2a549c97fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aca19aed8487b4fbf84a861481757f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a16aca19aed8487b4fbf84a861481757f">isReadable</a> () const </td></tr>
<tr class="memdesc:a16aca19aed8487b4fbf84a861481757f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#a16aca19aed8487b4fbf84a861481757f">More...</a><br /></td></tr>
<tr class="separator:a16aca19aed8487b4fbf84a861481757f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc061417f2c1360d2425528b267f2ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#afdc061417f2c1360d2425528b267f2ae">isWriteable</a> () const </td></tr>
<tr class="memdesc:afdc061417f2c1360d2425528b267f2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#afdc061417f2c1360d2425528b267f2ae">More...</a><br /></td></tr>
<tr class="separator:afdc061417f2c1360d2425528b267f2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1398009ab341e899ad27b700cbf49750"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a1398009ab341e899ad27b700cbf49750">getHardwareAccessingElements</a> ()</td></tr>
<tr class="memdesc:a1398009ab341e899ad27b700cbf49750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a1398009ab341e899ad27b700cbf49750">More...</a><br /></td></tr>
<tr class="separator:a1398009ab341e899ad27b700cbf49750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27f1948484388baf201fd7c80b3429d"><td class="memItemLeft" align="right" valign="top">std::list&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#ac27f1948484388baf201fd7c80b3429d">getInternalElements</a> ()</td></tr>
<tr class="memdesc:ac27f1948484388baf201fd7c80b3429d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the full list of TransferElements internally used by this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ac27f1948484388baf201fd7c80b3429d">More...</a><br /></td></tr>
<tr class="separator:ac27f1948484388baf201fd7c80b3429d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98898c2f8689baea9caf53e358a9a26"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#ac98898c2f8689baea9caf53e358a9a26">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:ac98898c2f8689baea9caf53e358a9a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ac98898c2f8689baea9caf53e358a9a26">More...</a><br /></td></tr>
<tr class="separator:ac98898c2f8689baea9caf53e358a9a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ef0cf5278cbf3452909065898ce9e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a72ef0cf5278cbf3452909065898ce9e8">isInitialised</a> () const </td></tr>
<tr class="memdesc:a72ef0cf5278cbf3452909065898ce9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the accessor is properly initialised.  <a href="#a72ef0cf5278cbf3452909065898ce9e8">More...</a><br /></td></tr>
<tr class="separator:a72ef0cf5278cbf3452909065898ce9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4f1ba975bc779ce4981140596e35b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a8a4f1ba975bc779ce4981140596e35b2">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; newElement)=0</td></tr>
<tr class="memdesc:a8a4f1ba975bc779ce4981140596e35b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a8a4f1ba975bc779ce4981140596e35b2">More...</a><br /></td></tr>
<tr class="separator:a8a4f1ba975bc779ce4981140596e35b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dda030ec4fa72e45a1cbc65541735c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a8dda030ec4fa72e45a1cbc65541735c6">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt; storage)</td></tr>
<tr class="memdesc:a8dda030ec4fa72e45a1cbc65541735c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a8dda030ec4fa72e45a1cbc65541735c6">More...</a><br /></td></tr>
<tr class="separator:a8dda030ec4fa72e45a1cbc65541735c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286333ba68d075ebd11f29e098ad1b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a286333ba68d075ebd11f29e098ad1b32">getId</a> () const </td></tr>
<tr class="memdesc:a286333ba68d075ebd11f29e098ad1b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique ID for this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a286333ba68d075ebd11f29e098ad1b32">More...</a><br /></td></tr>
<tr class="separator:a286333ba68d075ebd11f29e098ad1b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a05069257536fe3266be9d1b22f262e05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a05069257536fe3266be9d1b22f262e05">TransferElementAbstractor</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; impl)</td></tr>
<tr class="memdesc:a05069257536fe3266be9d1b22f262e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> implementation.  <a href="#a05069257536fe3266be9d1b22f262e05">More...</a><br /></td></tr>
<tr class="separator:a05069257536fe3266be9d1b22f262e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a51acf125c31a571b6c55ac44085d09cb"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a51acf125c31a571b6c55ac44085d09cb">_implUntyped</a></td></tr>
<tr class="memdesc:a51acf125c31a571b6c55ac44085d09cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untyped pointer to implementation.  <a href="#a51acf125c31a571b6c55ac44085d09cb">More...</a><br /></td></tr>
<tr class="separator:a51acf125c31a571b6c55ac44085d09cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for register accessors abstractors independent of the UserType. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00044">44</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aca23dd9f4cbfc319ede1fa02677d9b5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mtca4u::TransferElementAbstractor::TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an uninitialised abstractor - just for late initialisation. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00049">49</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a76dd8dbd11a1d4e12992b2c00df6808e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mtca4u::TransferElementAbstractor::~TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract base classes need a virtual destructor. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00052">52</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05069257536fe3266be9d1b22f262e05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mtca4u::TransferElementAbstractor::TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> implementation. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00217">217</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afbbf8d80bc2f0cb7a076568bbe54760f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mtca4u::TransferElementAbstractor::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of this variable/register. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00061">61</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1398009ab341e899ad27b700cbf49750"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; &gt; mtca4u::TransferElementAbstractor::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00145">145</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac98898c2f8689baea9caf53e358a9a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; mtca4u::TransferElementAbstractor::getHighLevelImplElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>For TransferElements which are itself an implementation this will directly return a shared pointer to this. If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is a user frontend, the pointer to the internal implementation is returned.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00176">176</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a286333ba68d075ebd11f29e098ad1b32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_transfer_element_i_d.html">TransferElementID</a> mtca4u::TransferElementAbstractor::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain unique ID for this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is the abstractor side of the bridge, this function will return the unique ID of the actual implementation. This means that e.g. two instances of <a class="el" href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a> created by the same call to <a class="el" href="classmtca4u_1_1_device.html#a5223e36dcdefaf8e1b99dbca86b6ea87" title="Get a ScalarRegisterObject object for the given register. ">Device::getScalarRegisterAccessor()</a> (e.g. by copying the accessor to another using NDRegisterAccessorBridge::replace()) will have the same ID, while two instances obtained by to difference calls to <a class="el" href="classmtca4u_1_1_device.html#a5223e36dcdefaf8e1b99dbca86b6ea87" title="Get a ScalarRegisterObject object for the given register. ">Device::getScalarRegisterAccessor()</a> will have a different ID even when accessing the very same register. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00212">212</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac27f1948484388baf201fd7c80b3429d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; &gt; mtca4u::TransferElementAbstractor::getInternalElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the full list of TransferElements internally used by this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>The function is recursive, i.e. elements used by the elements returned by this function are also added to the list. It is guaranteed that the directly used elements are first in the list and the result from recursion is appended to the list.</p>
<p>Example: A decorator would return a list with its target <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> followed by the result of <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#ac27f1948484388baf201fd7c80b3429d" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a> called on its target <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.</p>
<p>If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is not using any other element, it should return an empty vector. Thus those elements which return a list just containing themselves in <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a1398009ab341e899ad27b700cbf49750" title="Obtain the underlying TransferElements with actual hardware access. ">getHardwareAccessingElements()</a> will return an empty list here in <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#ac27f1948484388baf201fd7c80b3429d" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a>.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00163">163</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac90dffb0c0d7939783e2905ecd0f96bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mtca4u::TransferElementAbstractor::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name that identifies the process variable. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00055">55</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a14523486d7ded2a40326ee46038998b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; mtca4u::TransferElementAbstractor::getUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the engineering unit. </p>
<p>If none was specified, it will default to "n./a." </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00058">58</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff937868ad793685688c0f02a477d7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; mtca4u::TransferElementAbstractor::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00065">65</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a17fdfada5c7f9ebe2c9d4579ceb87206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> mtca4u::TransferElementAbstractor::getVersionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version number that is associated with the last transfer (i.e. </p>
<p>last read or write). See <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">ChimeraTK::VersionNumber</a> for details. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00121">121</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a72ef0cf5278cbf3452909065898ce9e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::isInitialised </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the accessor is properly initialised. </p>
<p>It is initialised if it was constructed passing the pointer to an implementation (a <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a>), it is not initialised if it was constructed only using the placeholder constructor without arguments. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00181">181</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a16aca19aed8487b4fbf84a861481757f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a16aca19aed8487b4fbf84a861481757f" title="Check if transfer element is readable. ">isReadable()</a> is not true. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00132">132</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cd3b8268a9b68aad64c2a549c97fbcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00128">128</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="afdc061417f2c1360d2425528b267f2ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#afdc061417f2c1360d2425528b267f2ae" title="Check if transfer element is writeable. ">isWriteable()</a> is not true. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00136">136</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18d217489cc7323843a2f398ee8fdd7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::TransferElementAbstractor::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00069">69</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88e21952c00c6bda8bd99f5e22998134"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> mtca4u::TransferElementAbstractor::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a18d217489cc7323843a2f398ee8fdd7e" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a92ceb976a13604dd140fd0b684b2ea94" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a18d217489cc7323843a2f398ee8fdd7e" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a92ceb976a13604dd140fd0b684b2ea94" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a18d217489cc7323843a2f398ee8fdd7e" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElement::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread.</p>
<p>Note for implementations: Inside this function and before launching the actual transfer, the flag readTransactionInProgress must be cleared, then preRead() has to be called. Otherwise postRead() will not get executed after the transfer. postRead() on the other hand must not be called inside this function, since this would update the user buffer, which should only happen when waiting on the TransferFuture. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> will automatically call postRead() before returning. Decorators must also call preRead() in their implementations of <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a88e21952c00c6bda8bd99f5e22998134" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>!</p>
<p>Note: This feature is still experimental. Expect API changes without notice! </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00115">115</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa0a91e45e3729ca5b3de3fb6763c98db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a92ceb976a13604dd140fd0b684b2ea94" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00085">85</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a92ceb976a13604dd140fd0b684b2ea94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="classmtca4u_1_1_transfer_element_abstractor.html#a18d217489cc7323843a2f398ee8fdd7e" title="Read the data from the device. ">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00080">80</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a4f1ba975bc779ce4981140596e35b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mtca4u::TransferElementAbstractor::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect. </p>

<p>Implemented in <a class="el" href="structmtca4u_1_1detail_1_1_transfer_group_transfer_element_abstractor.html#a102956242ed1f1f0e41a7d4e7aa13a39">mtca4u::detail::TransferGroupTransferElementAbstractor</a>, and <a class="el" href="classmtca4u_1_1_n_d_register_accessor_abstractor.html#a77fd8e8acfe4522c67a688c0c6b91ba2">mtca4u::NDRegisterAccessorAbstractor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8dda030ec4fa72e45a1cbc65541735c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtca4u::TransferElementAbstractor::setPersistentDataStorage </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate a persistent data storage object to be updated on each write operation of this ProcessArray. </p>
<p>If no persistent data storage as associated previously, the value from the persistent storage is read and send to the receiver.</p>
<p>Note: A call to this function will be ignored, if the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> does not support persistent data storage (e.g. read-only variables or device registers)</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000064">Todo:</a></b></dt><dd>TODO does this make sense? </dd></dl>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00200">200</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33c53b8c4d7e35e3c717ec8a2e3e6c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mtca4u::TransferElementAbstractor::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00125">125</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a51acf125c31a571b6c55ac44085d09cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; mtca4u::TransferElementAbstractor::_implUntyped</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untyped pointer to implementation. </p>

<p>Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00222">222</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device/include/<a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 9 2018 06:17:45 for mtca4u-deviceaccess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
