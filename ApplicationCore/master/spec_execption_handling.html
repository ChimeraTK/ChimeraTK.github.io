<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: Technical specification: Exception handling for device runtime errors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec_execption_handling.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Technical specification: Exception handling for device runtime errors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>DRAFT VERSION, WRITE-UP IN PROGRESS!</b></p>
<h1><a class="anchor" id="spec_execptionHandling_intro"></a>
Introduction</h1>
<p>Exceptions are handled by ApplicationCore in a way that the application developer does not need to care much about it.</p>
<p>ChimeraTK::runtime_error exceptions are caught by the framework and are reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a>. The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> handles this exception and periodically tries to open the device. Communication with the faulty device is frozen or delayed until the device is functional again. In case of several devices only the faulty device is frozen. Faulty devices do not prevent the application from starting, only the parts of the application that depend on the fault device are waiting for the device to come up.</p>
<p>Input variables of ApplicationModules which cannot be read due to a faulty device will set and propagate the DataValidity::faulty flag (see also the <a class="el" href="spec_data_validity_propagation.html">Technical specification: data validity propagation</a>).</p>
<p>When the device is functional, it be (re)initialised by using application-defined initialisation handlers and also recover the last known values of its process variables.</p>
<h2><a class="anchor" id="spec_exceptionHandling_intro_terminology"></a>
Special terminology used in this document</h2>
<ul>
<li>An read operation might be "skipped". It means, the operation will not take place at all. Instead, the data is marked as DataValidity::faulty. Note: This term is also used, if the a running operation is interrupted by an exception.</li>
<li>An read operation might be "frozen". This means, the function called will not return until the fault state is resolved and the operation is executed. Freezing always happens before the actual operation is executed and hence will always act on pre-existing fault states only.</li>
<li>An write operation might be "delayed". This means, the operation will not be executed immediately and the calling thread continues. The operation will be asynchronosuly executed when the fault state is resolved. Note that the VersionNumber specified in the write operation will be retained and also used for the delayed write operation.</li>
<li>Whenever a write operation or a call to write() is mentioned, destructive writes via writeDestructively() are included. The destructive write optimisation makes no difference for the exception handling.</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_behaviour"></a>
A. Behavioural description</h1>
<ul>
<li>1. All ChimeraTK::runtime_error exceptions thrown by device register accessors are handled by the framework and are never exposed to user code in ApplicationModules.<ul>
<li><a class="anchor" id="a_1_1"></a>1.1 ChimeraTK::logic_error exceptions are left unhandled and will terminate the application. These errors may only occur in the (re-)initialisation phase (up to the point where all devices are opened and initialised) and point to a severe configuration error which is not recoverable. <a class="el" href="spec_execption_handling.html#comment_a_1_1">(*)</a></li>
<li><a class="anchor" id="a_1_2"></a>1.2 <b>Exception handling and DataValidity flag propagation is implemented such that it is transparent to a module whether it is directly connected to a device, or whether a fanout or another application module is in between.</b> This is the central requirement from which most other requirements are derived.</li>
</ul>
</li>
<li><a class="anchor" id="a_2"></a>2. When an exception has been received by the framework (thrown by a device register accessor):<ul>
<li>2.1 The exception status is published as a process variable together with an error message.<ul>
<li>2.1.1 The variable <code>Devices/&lt;alias&gt;/status</code> contains a boolean flag whether the device is in an error state</li>
<li>2.1.2 The variable <code>Devices/&lt;alias&gt;/message</code> contains an error message, if the device is in an error state, or an empty string otherwise.</li>
</ul>
</li>
<li><a class="anchor" id="a_2_2"></a>2.2 Read operations will propagate the DataValidity::faulty flag to the owning module / fan out (without changing the actual value):<ul>
<li>2.2.1 The normal module algorithm code will be continued, to allow this flag to propagate to the outputs in the same way as if it had been received through the process variable itself (cf. <a class="el" href="spec_execption_handling.html#a_1_2">1.2</a>).</li>
<li>2.2.2 The DataValidity::faulty flag resulting from the fault state is propagated once, even if the variable had the a DataValidity::faulty flag already set previously for another reason.</li>
<li><a class="anchor" id="a_2_2_3"></a>2.2.3 Read operations without AccessMode::wait_for_new_data are skipped until the device is fully recovered again (cf. <a class="el" href="spec_execption_handling.html#a_3_1">3.1</a>).</li>
<li><a class="anchor" id="a_2_2_4"></a>2.2.4 Read operations with AccessMode::wait_for_new_data will be skipped once for each accessor to propagate the DataValidity::faulty flag (which counts as new data, i.e. readNonBlocking() will return true). In the following:<ul>
<li>non-blocking read operations (readNonBlocking() and readLatest()) are skipped and return false, until new data has arrived from the device, and</li>
<li>blocking read operations (read()) will freeze until new data has arrived from the device.</li>
<li>Note: The device may start sending data already before the recovery procedure (cf. <a class="el" href="spec_execption_handling.html#a_3_1">3.1</a>) is complete. If this is not acceptable, a device specific handshake mechanism has to be implemented in the application to control when the device is allowed to send updates again. <a class="el" href="spec_execption_handling.html#comment_a_2_2_4">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="a_2_2_5"></a>2.2.5 If the fault state had been resolved in between one read operation (regardless of the type) and a second blocking read operation, and the device had become faulty again before the second operation is executed, it is not defined whether the second operation will frozen or skipped. The second operation might in this case behave either like it is a new exception or like the same fault state would still prevail. <a class="el" href="spec_execption_handling.html#comment_a_2_2_5">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="a_2_3"></a>2.3 Write operations will be delayed until the device is fully recovered again (cf. <a class="el" href="spec_execption_handling.html#a_3_1">3.1</a>). In case of a fault state (new or persisting), the actual write operation will take place asynchronously when the device is recovering. The same mechanism as used for <a class="el" href="spec_execption_handling.html#a_3_1_2">3.1.2</a> is used here, hence the order of write operations is guaranteed across accessors, but only the latest written value of each accessor prevails. <a class="el" href="spec_execption_handling.html#comment_a_2_3">(*)</a><ul>
<li>2.3.1 The return value of write() indicates whether data was lost in the transfer. If the write has to be delayed due to an exception, the return value will be true, if a previously delayed and not-yet written value is discarded in the process, false otherwise.</li>
<li>2.3.2 When the delayed value is finally written to the device during the recovery procedure, it is guaranteed that no data loss happens (writes with data loss will be retried).</li>
<li>2.3.3 It is guaranteed that the write takes place before the device is considered fully recovered again and other transfers are allowed (cf. <a class="el" href="spec_execption_handling.html#a_3_1">3.1</a>).</li>
</ul>
</li>
<li><a class="anchor" id="a_2_4"></a>2.4 In case of exceptions, there is no guaranteed realtime behaviour, not even for "non-blocking" transfers. <a class="el" href="spec_execption_handling.html#comment_a_2_4">(*)</a></li>
</ul>
</li>
<li>3. The framework tries to resolve an exception state by periodically re-opening the faulty device.<ul>
<li><a class="anchor" id="a_3_1"></a>3.1 After successfully re-opening the device, a recovery procedure is executed before allowing any read/write operations from the AppliactionModules and FanOuts again. This recovery procedure involves:<ul>
<li>3.1.1 the execution of so-called initialisation handlers (see <a class="el" href="spec_execption_handling.html#a_3_2">3.2</a>), and</li>
<li><a class="anchor" id="a_3_1_2"></a>3.1.2 restoring all registers that have been written since the start of the application with their latest values. The register values are restored in the same order they were written. <a class="el" href="spec_execption_handling.html#comment_a_3_1_2">(*)</a></li>
<li><a class="anchor" id="a_3_1_3"></a>3.1.3 Finally, <code>Devices/&lt;alias&gt;/deviceBecameFunctional</code> is written to inform any module subscribing this variable about the finished recovery. <a class="el" href="spec_execption_handling.html#comment_a_3_1_3">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="a_3_2"></a>3.2 Any number of initialisation handlers can be added to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> in the user code. Initialisation handlers are callback functions which will be executed when a device is opened for the first time and after a device recovers from an exception, before any process variables are written. See <a class="el" href="class_chimera_t_k_1_1_device_module.html#ab30bf1b235913143d45bb5da7d84052c" title="Add initialisation handlers to the device. ">DeviceModule::addInitialisationHandler()</a>.</li>
</ul>
</li>
<li>4. The behaviour at application start (when all devices are still closed at first) is similar to the case of a later received exception. The only differences are mentioned in <a class="el" href="spec_execption_handling.html#a_4_2">4.2</a>.<ul>
<li>4.1 Even if some devices are initially in a persisting error state, the part of the application which does not interact with the faulty devices starts and works normally.</li>
<li><a class="anchor" id="a_4_2"></a>4.2 Initial values are correctly propagated after a device is opened. See the <a class="el" href="spec_initial_value_propagation.html">Technical specification: propagation of initial values</a>. Especially, all read operations (even readNonBlocking/readLatest) will be frozen until an initial value has been received. <a class="el" href="spec_execption_handling.html#comment_a_4_2">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="a_5"></a>5. Any <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> can explicitly report a problem with the device by calling <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception. ">DeviceModule::reportException()</a>. This allows the reinitialisation of a device e.g. after a reboot of the device which didn't result in a exception (e.g. because it was too quick to be noticed, or rebooting the device takes place without interrupting the communication).</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_behaviour_comments"></a>
(*) Comments</h2>
<ul>
<li><a class="anchor" id="comment_a_1_1"></a><a class="el" href="spec_execption_handling.html#a_1_1">1.1</a> In future, maybe logic_errors are also handled, so configuration errors can nicely be presented to the control system. This may be important especially since logic_errors may depend also on the configuration of external components (devices). If e.g. a device is changed (e.g. device is another control system application which has been modified), logic_errors may be thrown in the recovery phase, despite the device had been successfully initialsed previously.</li>
<li><a class="anchor" id="comment_a_2_2_4"></a><a class="el" href="spec_execption_handling.html#a_2_2_4">2.2.4</a> Preventing the device to send data before the recovery is complete is not trivial in the general case for asynchronous transfers (i.e. wait_for_new_data). Race conditions might occur if the transport layer does not guarantee the order of packets (e.g. UDP), in which case unsubscribing a variable might not guarantee that no more data arrives which has been sent before unsubscribing. Hence it was decided not to specify a mechanism which would guarantee that no asychronous data transfers take place before the recovery has completed.</li>
<li><a class="anchor" id="comment_a_2_2_5"></a><a class="el" href="spec_execption_handling.html#a_2_2_5">2.2.5</a> Not defining the behaviour here avoids a conflict with 1.2 without requiring a complicated implementation which does not freeze in this case. Implementing this would not present any gain for the application. If there are many exceptions on the same device in a short period of time, the number of faulty data updates seen by the application modules will always depend on the speed the module is attempting to read data (unless we require every exception to be visible to every module, but this will have complex effects, too). It might break consistency of the number of updates sent through different paths in an application, but applications should anyway not rely on that and use a DataConsistencyGroup to synchronise instead. Hence, the implementation will freeze always if a blocking read sees an exception after the last read of the same accessor had seen an exception (the same or a different one) as well.</li>
<li><a class="anchor" id="comment_a_2_3"></a><a class="anchor" id="comment_a_3_1_3"></a><a class="el" href="spec_execption_handling.html#a_2_3">2.3</a> / <a class="el" href="spec_execption_handling.html#a_3_1_3">3.1.3</a> If timing is important for write operations (e.g. must not write a sequence of registers too fast), or if multiple values need to be written to the same register in sequence, the application cannot fully rely on the framework's recovery procedure. The framework hence provides the process variable <code>Devices/&lt;alias&gt;/deviceBecameFunctional</code> for each device, which will be written each time the recovery procedure is completed (cf. <a class="el" href="spec_execption_handling.html#a_3_1_3">3.1.3</a>). ApplicationModules which implement such timed sequence need to receive this variable and restart the entire sequence after the recovery.</li>
<li><a class="anchor" id="comment_a_2_4"></a><a class="el" href="spec_execption_handling.html#a_2_4">2.4</a> Even read without wait_for_new_data and write operations are not truely non-blocking, since they are still synchronous. The "non-blocking" guarantee only means that the operation does not block until new data has arrived, and that it is not frozen until the device is recovered. For the duration of the recovery procedure and of course for timeout periods these operations may still block. readNonBlocking() and readLatest() with wait_for_new_data could in theory be truely lock-free and wait-free, but the synchronisation mechanism in case of exceptions are not implemented as such. In case of exceptions, the application usually anway does not behave normally any more. If needed, this limitation could be lifted with a more complicated implementation in the future.</li>
<li><a class="anchor" id="comment_a_3_1_2"></a><a class="el" href="spec_execption_handling.html#a_3_1_2">3.1.2</a> For some applications, the order of writes may be important, e.g. if firmware expects this. Please note that the VersionNumber is insufficient as a sorting criteria, since many writes may have been done with the same VersionNumber (in an <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a>, the VersionNumber used for the writes is determined by the largest VersionNumber of the inputs).</li>
<li><a class="anchor" id="comment_a_4_2"></a><a class="el" href="spec_execption_handling.html#a_4_2">4.2</a> DataValidity::faulty is initially set by default, so there is no need to propagate this flag initially. To prevent race conditions and undefined behaviour (especially in automated tests), it even needs to be made sure that the flag is not propagated unnecessarily. The behaviour of non-blocking reads presents a slight asymmetry between the initial device opening and a later recovery. This will in particular be visible when restarting a server while a device is offline. If a module only uses readLatest()/readNonBlocking() (= read() for poll-type inputs) for the offline device, the module was still running before the server restart using the last known values for the dysfunctional registers (and flagging all outputs as faulty). After the restart, the module has to wait for the initial value and hence will not run until the device becomes functional again. To make this behaviour symmetric, one would need to persist the values of device inputs. Since this only affects a corner case in which likely no usable output is produced anyway, this slight inconsistency is considered acceptable.</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_high_level_implmentation"></a>
B. Implementation</h1>
<p>A so-called <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> is placed around all device register accessors (used in ApplicationModules and FanOuts). It is responsible for catching the exceptions and implementing most of the behaviour described in <a class="el" href="spec_execption_handling.html#a_2">A.2</a>, and its implementation is described in <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_decorator">B.2</a>. It has to work closely with the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> and there is a complex synchronisation and locking scheme, which is described in <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_interface">B.1</a>. The sequence executed in the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> is described in <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_deviceModule">B.3</a>.</p>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_interface"></a>
B.1 Internal interface between ExceptionHandlingDecorator and DeviceModule</h2>
<p>Note: This section defines the internal interface on a low level. Helper functions, like getters and setters, are intenionally not mentioned here, since those are (in this context) unimportant details which can be chosen at will to structure the code conveniently. The entire interface between the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> and the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> should be protected and the two classes should be friends, to prevent interference with the interface from other entities. Only <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception. ">DeviceModule::reportException()</a> is public, see <a class="el" href="spec_execption_handling.html#a_5">A.5</a>.</p>
<ul>
<li>1.1 The boolean flag <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a><ul>
<li>1.1.1 is used by the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> to detect prevailing error conditions, to know when transfers have to be skipped, frozen or delayed (cf. <a class="el" href="spec_execption_handling.html#b_2_3">2.3</a> and <a class="el" href="spec_execption_handling.html#b_2_4">2.4</a>).</li>
<li>1.1.2 The access is protected by the <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4e61eb7f0c5215a0579f83ee65d0c889" title="Mutex for errorCondVar. ">DeviceModule::errorMutex</a>:<ul>
<li>shared lock allows to read</li>
<li>unique lock allows to read and write</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="b_1_2"></a>1.2 The atomic DeviceModule::transferCounter <a class="el" href="spec_execption_handling.html#comment_b_1_2">(*)</a><ul>
<li>1.2.1 tracks the number of on-going (synchronous) transfers, and</li>
<li>1.2.2 is used by the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> to wait until they are all terminated (<a class="el" href="spec_execption_handling.html#b_3_3_14">3.3.14</a>).</li>
</ul>
</li>
<li><a class="anchor" id="b_1_3"></a>1.3 The <a class="el" href="class_chimera_t_k_1_1_device_module.html#aa5e37e4eeac6bf7ee83c5043e9fd9545" title="List of TransferElements to be written after the device has been recovered. ">DeviceModule::recoveryHelpers</a> list elements<ul>
<li>1.3.1 are used to delay write operations and to restore the last-written values during recovery.</li>
<li><a class="anchor" id="b_1_3_2"></a>1.3.2 are protected by the DeviceModule::recoveryMutex:<ul>
<li>shared lock allows to update the application buffer of <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> and to update the other members of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> structure <a class="el" href="spec_execption_handling.html#comment_b_1_3_2">(*)</a></li>
<li>unique lock allows to call RecoveryHelper::accessor.write() and to read/write the other members of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> structure</li>
</ul>
</li>
</ul>
</li>
<li>1.4 The cppext::future_queue <a class="el" href="class_chimera_t_k_1_1_device_module.html#a81936a1ddd5c7bf141124aa599181a03" title="Queue used for communication between reportException() and the moduleThread. ">DeviceModule::errorQueue</a><ul>
<li>1.4.1 is used by the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> to inform the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> about new exceptions.</li>
</ul>
</li>
<li>1.5 The following mutexes govern critical sections (besides variable access listed above):<ul>
<li><a class="anchor" id="b_1_5_1"></a>1.5.1 <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4e61eb7f0c5215a0579f83ee65d0c889" title="Mutex for errorCondVar. ">DeviceModule::errorMutex</a> protects <a class="el" href="spec_execption_handling.html#comment_b_1_5_1">(*)</a><ul>
<li>the (positive) decision to start a transfer followed by incrementing the DeviceModule::transferCounter in <a class="el" href="spec_execption_handling.html#b_2_3_1">2.3.1</a> to <a class="el" href="spec_execption_handling.html#b_2_3_3">2.3.3</a>, against</li>
<li>setting <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> flag in <a class="el" href="spec_execption_handling.html#b_2_6_1">2.6.1</a>.</li>
</ul>
</li>
<li><a class="anchor" id="b_1_5_2"></a>1.5.2 DeviceModule::recoveryMutex protects <a class="el" href="spec_execption_handling.html#comment_b_1_5_2">(*)</a><ul>
<li>writing the <a class="el" href="class_chimera_t_k_1_1_device_module.html#aa5e37e4eeac6bf7ee83c5043e9fd9545" title="List of TransferElements to be written after the device has been recovered. ">DeviceModule::recoveryHelpers</a> to the device and clearing the <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> flag in <a class="el" href="spec_execption_handling.html#b_3_3_6">3.3.6</a> to <a class="el" href="spec_execption_handling.html#b_3_3_8">3.3.8</a>, against</li>
<li>updating the <a class="el" href="class_chimera_t_k_1_1_device_module.html#aa5e37e4eeac6bf7ee83c5043e9fd9545" title="List of TransferElements to be written after the device has been recovered. ">DeviceModule::recoveryHelpers</a> in <a class="el" href="spec_execption_handling.html#b_2_2">2.2</a>.</li>
</ul>
</li>
<li><a class="anchor" id="b_1_5_3"></a>1.5.3 DeviceModule::initialValueMutex protects <a class="el" href="spec_execption_handling.html#comment_b_1_5_3">(*)</a><ul>
<li>the start of a read operation in <a class="el" href="spec_execption_handling.html#b_2_4_4">2.4.4</a>, against</li>
<li>the setup phase of a device until it has been opened and recovered for the very first time in <a class="el" href="spec_execption_handling.html#b_3_1">3.1</a> to <a class="el" href="spec_execption_handling.html#b_3_3_9">3.3.9</a>.</li>
</ul>
</li>
</ul>
</li>
<li>1.6 DeviceModule::listOfReadRegisters resp. DeviceModule::listOfWriteRegisters<ul>
<li>1.6.1 are used to check that all used registers are existing and have the right direction after (re-)opening the device.</li>
<li>1.6.2 No lock for accessing is required, since the lists are filled in the constructors of the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> and in the following only used by the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_interface_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_b_1_2"></a><a class="el" href="spec_execption_handling.html#b_1_2">1.2</a> Reason for not using an (exclusive) lock: Incrementing and decrementing the counter is done in the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> for each operation, even if there is no exception or error state. Concurrent operations must not exclude each other, to allow lockfree operation in the no-exception case (if the backend supports it) and to avoid priority inversion, if different application threads have different priorities.</li>
<li><a class="anchor" id="comment_b_1_3_2"></a><a class="el" href="spec_execption_handling.html#b_1_3_2">1.3.2</a> A shared lock (in contrast to an exclusive lock) is used for the same reasons as in <a class="el" href="spec_execption_handling.html#b_1_2">1.2</a>.</li>
<li><a class="anchor" id="comment_b_1_5_1"></a><a class="el" href="spec_execption_handling.html#b_1_5_1">1.5.1</a> This prevents a race condition in <a class="el" href="spec_execption_handling.html#b_3_3_14">3.3.14</a>. If a (synchronous) transfer might be started after <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> has been set, the barrier for new transfers in <a class="el" href="spec_execption_handling.html#b_3_3_14">3.3.14</a> would not be effective and the transfer might be even executed only after the device has been re-openend (<a class="el" href="spec_execption_handling.html#b_3_3_1">3.3.1</a>) but before the recovery is complete.</li>
<li><a class="anchor" id="comment_b_1_5_2"></a><a class="el" href="spec_execption_handling.html#b_1_5_2">1.5.2</a> This prevents data loss due to a race condition. If the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> would update the corresponding DeviceModule::RecoveryHelpers list entry only after it has been written to the device in <a class="el" href="spec_execption_handling.html#b_3_3_6">3.3.6</a>, but the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> would decide not to execute the write operation (<a class="el" href="spec_execption_handling.html#b_2_3">2.3</a>) because the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread is still before <a class="el" href="spec_execption_handling.html#b_3_3_8">3.3.8</a>, the data would not be written to the device at all.</li>
<li><a class="anchor" id="comment_b_1_5_3"></a><a class="el" href="spec_execption_handling.html#b_1_5_3">1.5.3</a> This implements freezing reads until the initial value can be read, cf. <a class="el" href="spec_execption_handling.html#a_4_2">A.4.2</a>.</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_decorator"></a>
B.2 ExceptionHandlingDecorator</h2>
<ul>
<li><a class="anchor" id="b_2_1"></a>2.1 A second, undecorated copy of each writeable device register accessor <a class="el" href="spec_execption_handling.html#comment_b_2_1">(*)</a>, the so-called recovery accessor, is stored in the <a class="el" href="class_chimera_t_k_1_1_device_module.html#aa5e37e4eeac6bf7ee83c5043e9fd9545" title="List of TransferElements to be written after the device has been recovered. ">DeviceModule::recoveryHelpers</a>. These recoveryHelpers are used to set the initial values of registers when the device is opened for the first time and to recover the last written values during the recovery procedure.<ul>
<li><a class="anchor" id="b_2_1_1"></a>2.1.1 The <a class="el" href="class_chimera_t_k_1_1_device_module.html#aa5e37e4eeac6bf7ee83c5043e9fd9545" title="List of TransferElements to be written after the device has been recovered. ">DeviceModule::recoveryHelpers</a> is a list of <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> objects, which each contain:<ul>
<li><a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>, the recovery accessor itself,</li>
<li><a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, the VersionNumber of the (potentially unwritten) data stored in the value buffer of the accessor,</li>
<li>RecoveryHelper::writeOrder, an ordering parameter which determines the order of write opereations during recovery.</li>
<li>RecoveryHelper::wasWritten, a flag which indicates whether the data in the value buffer of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> has already been written to the device. <a class="el" href="spec_execption_handling.html#comment_b_2_1_1">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="b_2_1_2"></a>2.1.2 Ordering can be done per device <a class="el" href="spec_execption_handling.html#comment_b_2_1_2">(*)</a>, hence each <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> has one 64-bit atomic counter DeviceModule::writeCounter which is incremented for each write operation and the value is stored in RecoveryHelper::writeOrder.</li>
<li>2.1.3 The <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> objects may be accessed only under a lock, see <a class="el" href="spec_execption_handling.html#b_1_3">1.3</a>.</li>
</ul>
</li>
<li><a class="anchor" id="b_2_2"></a>2.2 In doPreWrite() the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> is updated while holding a shared lock on DeviceModule::recoveryMutex:<ul>
<li><a class="anchor" id="b_2_2_1"></a>2.2.1 These steps needs to be done unconditionally at the very beginning of doPreWrite(), before <a class="el" href="spec_execption_handling.html#b_2_3">2.3</a> and before delegating to preWrite(). <a class="el" href="spec_execption_handling.html#comment_b_2_2_1">(*)</a></li>
<li>2.2.2 If the RecoveryHelper::wasWritten flag was previously not set, the return value of doWriteTransfer() must be forced to true (data lost).</li>
<li>2.2.3 Update the value buffer of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>, update the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, set the RecoveryHelper::writeOrder to the DeviceModule::writeCounter after (atomically) incrementing it, and clear the RecoveryHelper::wasWritten flag.</li>
<li><a class="anchor" id="b_2_2_4"></a>2.2.4 The check whether to skip the transfer (cf. <a class="el" href="spec_execption_handling.html#b_2_3">2.3</a>) has to be done without releasing the lock between the update of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> and the check. <a class="el" href="spec_execption_handling.html#comment_b_2_2_4">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="b_2_3"></a>2.3 In doPreRead()/doPreWrite(), it must be decided whether to execute xxxTransferYyy(). This part requires a shared lock on the <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4e61eb7f0c5215a0579f83ee65d0c889" title="Mutex for errorCondVar. ">DeviceModule::errorMutex</a>.<ul>
<li><a class="anchor" id="b_2_3_1"></a>2.3.1 xxxTransferYyy() is <em>not</em> executed, if <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> == true and either:<ul>
<li>it is a write transfer (cf. <a class="el" href="spec_execption_handling.html#a_2_3">A.2.3</a>), or</li>
<li>it is a read transfer and AccessMode::wait_for_new_data is not set (cf. <a class="el" href="spec_execption_handling.html#a_2_2_3">A.2.2.3</a>), or</li>
<li>it is a read transfer and AccessMode::wait_for_new_data is set and <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html#a1c1ca495827f5fdb4ec6dae83bb8aa3e">ExceptionHandlingDecorator::previousReadFailed</a> == false (cf. <a class="el" href="spec_execption_handling.html#a_2_2_4">A.2.2.4</a>, <a class="el" href="spec_execption_handling.html#b_2_5_2">2.5.2</a> and <a class="el" href="spec_execption_handling.html#b_2_6_3_1">2.6.3.1</a>). Otherwise xxxTransferYyy() is executed (potentially after it is frozen, see <a class="el" href="spec_execption_handling.html#b_2_4">2.4</a>).</li>
</ul>
</li>
<li>2.3.2 If xxxTransferYyy() is not executed, none of the pre/transfer/post functions must be delegated to the target accessor.</li>
<li><a class="anchor" id="b_2_3_3"></a>2.3.3 If xxxTransferYyy() is executed, and it is <em>not</em> a read transfer with AccessMode::wait_for_new_data set, the DeviceModule::transferCounter must be incremented.</li>
</ul>
</li>
<li><a class="anchor" id="b_2_4"></a>2.4 In doPreRead() certain read operations are frozen (only <a class="el" href="spec_execption_handling.html#a_4_2">A.4.2</a>; <a class="el" href="spec_execption_handling.html#a_2_2_4">A.2.2.4</a> does not require an implementation here <a class="el" href="spec_execption_handling.html#comment_b_2_4">(*)</a>):<ul>
<li>2.4.1 The shared lock on the <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4e61eb7f0c5215a0579f83ee65d0c889" title="Mutex for errorCondVar. ">DeviceModule::errorMutex</a> acquired in <a class="el" href="spec_execption_handling.html#b_2_3">2.3</a> is still kept.</li>
<li>2.4.2 Decide, whether freezing is done (don't freeze yet). Freezing is done if no initial value has been read yet (getCurretVersion() == {nullptr}) and <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> == true.</li>
<li>2.4.3 Release the <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4e61eb7f0c5215a0579f83ee65d0c889" title="Mutex for errorCondVar. ">DeviceModule::errorMutex</a>.</li>
<li><a class="anchor" id="b_2_4_4"></a>2.4.4 If the read should be frozen, acquire a shared lock on the DeviceModule::initialValueMutex. <a class="el" href="spec_execption_handling.html#comment_b_2_4_4">(*)</a></li>
</ul>
</li>
<li>2.5 In doPostRead()/doPostWrite():<ul>
<li>2.5.1 Delegate to postRead() / postWrite() (see <a class="el" href="spec_execption_handling.html#b_2_6">2.6</a>)</li>
<li><a class="anchor" id="b_2_5_2"></a>2.5.2 If there was no exception, set <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html#a1c1ca495827f5fdb4ec6dae83bb8aa3e">ExceptionHandlingDecorator::previousReadFailed</a> = false (cf. <a class="el" href="spec_execption_handling.html#b_2_3_1">2.3.1</a> and <a class="el" href="spec_execption_handling.html#b_2_6_3_1">2.6.3.1</a>).</li>
<li><a class="anchor" id="b_2_5_3"></a>2.5.3 In doPostWrite() the RecoveryHelper::wasWritten flag is set (while holding a shared lock on DeviceModule::recoveryMutex) if the write was successful (no exception thrown; data lost flag does not matter here). <a class="el" href="spec_execption_handling.html#comment_b_2_5_3">(*)</a></li>
<li><a class="anchor" id="b_2_5_4"></a>2.5.4 If the DeviceModule::transferCounter was incremented in <a class="el" href="spec_execption_handling.html#b_2_3_3">2.3.3</a>, decrement it. <a class="el" href="spec_execption_handling.html#comment_b_2_5_4">(*)</a></li>
<li><a class="anchor" id="b_2_5_5"></a>2.5.5 In doPostRead(), if no exception was thrown, end overriding the DataValidity returned by the accessor (cf. <a class="el" href="spec_execption_handling.html#b_2_6_2">2.6.2</a>).</li>
</ul>
</li>
<li><a class="anchor" id="b_2_6"></a>2.6 In doPostRead()/doPostWrite(), any runtime_error exception thrown by the delegated postRead()/postWrite() is caught <a class="el" href="spec_execption_handling.html#comment_b_2_6">(*)</a>. The following actions are executed in case of an exception:<ul>
<li><a class="anchor" id="b_2_6_1"></a>2.6.1 The error is reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> via <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception. ">DeviceModule::reportException()</a> (cf. <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_reportException">B.4</a>). This automatically sets <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> to true. From this point on, no new transfers will be started. <a class="el" href="spec_execption_handling.html#comment_b_2_6_1">(*)</a></li>
<li><a class="anchor" id="b_2_6_2"></a>2.6.2 For readable accessors: the DataValidity returned by the accessor is overridden to faulty until next successful read operation (cf. <a class="el" href="spec_execption_handling.html#b_2_5_5">2.5.5</a>).<ul>
<li>2.6.2.1 The code instantiating the decorator (<a class="el" href="class_chimera_t_k_1_1_application.html#ace062becb6e35520147524dfec914a10" title="Perform the actual connection of an accessor to a device register. ">Application::createDeviceVariable()</a>) has to make sure that the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> is "inside" the <a class="el" href="class_chimera_t_k_1_1_meta_data_propagating_register_decorator.html" title="NDRegisterAccessorDecorator which propagates meta data attached to input process variables through th...">MetaDataPropagatingRegisterDecorator</a>, so the overriden DataValidity flag in case of an exception is properly propagated to the owning module/fan out.</li>
</ul>
</li>
<li>2.6.3 Action depending on the calling operation:<ul>
<li><a class="anchor" id="b_2_6_3_1"></a>2.6.3.1 All read operations: The <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> remembers that it is in an exception state by setting <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html#a1c1ca495827f5fdb4ec6dae83bb8aa3e">ExceptionHandlingDecorator::previousReadFailed</a> = true (cf. <a class="el" href="spec_execption_handling.html#b_2_3_1">2.3.1</a> and <a class="el" href="spec_execption_handling.html#b_2_5_2">2.5.2</a>)</li>
<li><a class="anchor" id="b_2_6_3_2"></a>2.6.3.2 read (push-type inputs): return immediately <a class="el" href="spec_execption_handling.html#comment_b_2_6_3_1">(*)</a></li>
<li>2.6.3.3 readNonBlocking / readLatest / read (poll-type inputs): Just return (true in readLatest() by definition in poll type). The calling module thread will continue and propagate the DataValidity::faulty flag (cf. <a class="el" href="spec_execption_handling.html#b_2_6_2">2.6.2</a>).</li>
<li>2.6.3.4 write: Write will be later executed by the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> (see <a class="el" href="spec_execption_handling.html#b_2_1">2.1</a>), hence just return.</li>
</ul>
</li>
</ul>
</li>
<li>2.7 In the constructor of the decorator, put the name of the register to DeviceModule::listOfReadRegisters resp. DeviceModule::listOfWriteRegisters depending on the direction the accessor is used.</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_decorator_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_b_2_1"></a><a class="el" href="spec_execption_handling.html#b_2_1">2.1</a> Possible future change: Output accessors can have the option not to have a <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a>. This is needed for instance for "trigger registers" which start an operation on the hardware. Also void registers don't have a <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number. ">RecoveryHelper</a> (once the void data type is supported by <a class="el" href="namespace_chimera_t_k.html" title="Generic modules for status monitoring. ">ChimeraTK</a>).</li>
<li><a class="anchor" id="comment_b_2_1_1"></a><a class="el" href="spec_execption_handling.html#b_2_1_1">2.1.1</a> The written flag cannot be replaced by comparing RecoveryHelper::accessor.getCurrentVersion() and <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, because normal writes (without exceptions) would not update the version number of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>. The written flag could also be made atomic to avoid acquiring the shared lock in postWrite(), but since the shared lock will never block there (if acquired before counting down the DeviceModule::transferCounter) is probably no benifit in using an atomic here.</li>
<li><a class="anchor" id="comment_b_2_1_2"></a><a class="el" href="spec_execption_handling.html#b_2_1_2">2.1.2</a> The ordering guarantee cannot work across DeviceModules anyway. Different devices may go offline and recover at different times. Even in case of two DeviceModules which actually refer to the same hardware device there is no synchronisation mechanism which ensures the recovering procedure is done in a defined order.</li>
<li><a class="anchor" id="comment_b_2_2_1"></a><a class="el" href="spec_execption_handling.html#b_2_2_1">2.2.1</a> Updating the recoveryHelper first ensures that no data is lost, even if the write operation attempt is concurrent with a recovery. See <a class="el" href="spec_execption_handling.html#b_1_5_2">1.5.2</a>.</li>
<li><a class="anchor" id="comment_b_2_2_4"></a><a class="el" href="spec_execption_handling.html#b_2_2_4">2.2.4</a> Extending the duration of the lock until the decision whether to skip the transfer will prevent unncessary duplicate writes, which otherwise could occur if the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> went through the whole critical section <a class="el" href="spec_execption_handling.html#b_3_3_5">3.3.5</a> to <a class="el" href="spec_execption_handling.html#b_3_3_10">3.3.10</a> in between.</li>
<li><a class="anchor" id="comment_b_2_4"></a><a class="el" href="spec_execption_handling.html#b_2_4">2.4</a> In A.2.2.4 it was stated that also in case AccessMode::wait_for_new_data is set blocking read transfers are frozen on the second operation. Nothing is to be implemented for this case, the freezing simply relies on having an empty queue in the accessor. Once the device sends data again, the operation is intrinsically unfrozen.</li>
<li><a class="anchor" id="comment_b_2_4_4"></a><a class="el" href="spec_execption_handling.html#b_2_4_4">2.4.4</a> The transferCounter is already incremeted at this point. It is acceptable to freeze anyway in this case by waiting on the initialValueMutex, because the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> release the mutex after the first successful recovery and never obtains it again, and this happens before it waits for the transferCounter to become 0 in <a class="el" href="spec_execption_handling.html#b_3_3_14">3.3.14</a>.</li>
<li><a class="anchor" id="comment_b_2_5_3"></a><a class="el" href="spec_execption_handling.html#b_2_5_3">2.5.3</a> The RecoveryHelper::wasWritten flag is used to report loss of data. If the loss of data is already reported directly, it should not later be reported again. Hence the written flag is set even if there was a loss of data in this context. Setting the flag is ideally done before decrementing the DeviceModule::transferCounter in <a class="el" href="spec_execption_handling.html#b_2_5_4">2.5.4</a>, because this eliminates the possibility that acquiring the shared lock on the DeviceModule::recoveryMutex could block (exclusive lock is only acquired during recovery, which cannot start before DeviceModule::transferCounter == 0)</li>
<li><a class="anchor" id="comment_b_2_5_4"></a><a class="el" href="spec_execption_handling.html#b_2_5_4">2.5.4</a> The state of <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> does not matter here. The counter always MUST be decreased after a transfer (if it has been incremented in the corresponding preXxx()), whether the transfer failed or not.</li>
<li><a class="anchor" id="comment_b_2_6"></a><a class="el" href="spec_execption_handling.html#b_2_6">2.6</a> Remember: exceptions from other phases are redirected to the post phase by the TransferElement base class.</li>
<li><a class="anchor" id="comment_b_2_6_1"></a><a class="el" href="spec_execption_handling.html#b_2_6_1">2.6.1</a> No transfers will be started in any of the accessors of the device, including this one. This is important to avoid the race condition described in the comment to <a class="el" href="spec_execption_handling.html#b_1_5_1">1.5.1</a></li>
<li><a class="anchor" id="comment_b_2_6_3_1"></a><a class="el" href="spec_execption_handling.html#b_2_6_3_2">2.6.3.2</a> The freezing is done in doPreRead(), see <a class="el" href="spec_execption_handling.html#b_2_4">2.4</a>.</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_deviceModule"></a>
B.3 DeviceModule</h2>
<ul>
<li><a class="anchor" id="b_3_1"></a>3.1 The application always starts with all devices as closed. For each device, the initial value for <code>Devices/&lt;alias&gt;/status</code> is set to 1 and the initial value for <code>Devices/&lt;alias&gt;/message</code> is set to an error that the device has not been opened yet (the message will be overwritten with the real error message if the first attempt to open fails, see <a class="el" href="spec_execption_handling.html#b_3_3_1">3.3.1</a>).</li>
<li><a class="anchor" id="b_3_2"></a>3.2 The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> locks the DeviceModule::initialValueMutex (cf. <a class="el" href="spec_execption_handling.html#b_2_4">2.4</a>). This happens before launching any module and fan out threads.</li>
<li>3.3 In the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> thread, the following procedure is executed (in a loop until termination):<ul>
<li><a class="anchor" id="b_3_3_1"></a>3.3.1 The <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> tries to open the device until it succeeds and Device::isFunctional() returns true.<ul>
<li>3.3.1.1 If the very first attempt to open the device after the application start fails, the error message of the exception is used to overwrite the content of <code>Devices/&lt;alias&gt;/message</code>. Otherwise error messages of exceptions thrown by Device::open() are not visible.</li>
</ul>
</li>
<li><a class="anchor" id="b_3_3_2"></a>3.3.2 The queue of reported exceptions is cleared. <a class="el" href="spec_execption_handling.html#comment_b_3_3_2">(*)</a></li>
<li>3.3.3 Check that all registers on DeviceModule::listOfReadRegisters are isReadable() and all registers on DeviceModule::listOfWriteRegisters are isWriteable().<ul>
<li>3.3.3.1 This involves obtaining an accessor for the register first, which is discarded after the check.</li>
<li>3.3.3.2 If there is an exception, update <code>Devices/&lt;alias&gt;/message</code> with the error message and go back to <a class="el" href="spec_execption_handling.html#b_3_3_1">3.3.1</a>.</li>
<li>3.3.3.3 If one of the accessors does not meet this condition, throw a ChimeraTK::logic_error.</li>
</ul>
</li>
<li>3.3.4 The device is initialised by iterating <a class="el" href="class_chimera_t_k_1_1_device_module.html#a9a605306e90d268b7091e6bad6c334f5">DeviceModule::initialisationHandlers</a> list and executing the functors.<ul>
<li>3.3.4.1 If there is an exception, update <code>Devices/&lt;alias&gt;/message</code> with the error message and go back to <a class="el" href="spec_execption_handling.html#b_3_3_1">3.3.1</a>.</li>
</ul>
</li>
<li><a class="anchor" id="b_3_3_5"></a>3.3.5 Obtain unique lock on DeviceModule::recoveryMutex.</li>
<li><a class="anchor" id="b_3_3_6"></a>3.3.6 Call write() on all valid <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>, in the ascending order of the RecoveryHelper::writeOrder.<ul>
<li>3.3.6.1 A <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> is considered "valid", if it has already received a value, i.e. <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a> != {nullptr}</li>
<li>3.3.6.2 If there is an exception, update <code>Devices/&lt;alias&gt;/message</code> with the error message, release the lock and go back to <a class="el" href="spec_execption_handling.html#b_3_3_1">3.3.1</a>.</li>
</ul>
</li>
<li>3.3.7 <code>Devices/&lt;alias&gt;/status</code> is set to 0 and <code>Devices/&lt;alias&gt;/message</code> is set to an empty string. <code>Devices/&lt;alias&gt;/deviceBecameFunctional</code> is written.</li>
<li><a class="anchor" id="b_3_3_8"></a>3.3.8 Clear the <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> flag to allow the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> to execute read/write operations again (cf. <a class="el" href="spec_execption_handling.html#b_3_3_12">3.3.12</a>)</li>
<li><a class="anchor" id="b_3_3_9"></a>3.3.9 Release the DeviceModule::initialValueMutex, if this point is passed for the very first time (was obtained in <a class="el" href="spec_execption_handling.html#b_3_2">3.2</a>, cf. <a class="el" href="spec_execption_handling.html#b_2_4_4">2.4.4</a>).</li>
<li><a class="anchor" id="b_3_3_10"></a>3.3.10 Release lock on DeviceModule::recoveryMutex (was obtained in <a class="el" href="spec_execption_handling.html#b_3_3_5">3.3.5</a>).</li>
<li>3.3.11 The DeviceModuleThread waits for the next reported exception.</li>
<li><a class="anchor" id="b_3_3_12"></a>3.3.12 An exception is received. The call to reportException (cf. <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_reportException">B.4</a>) in the other thread has already set deviceHasError to true <a class="el" href="spec_execption_handling.html#comment_b_3_3_12">(*)</a>. From this point on, no new transfers will be started.</li>
<li>3.3.13 <code>Devices/&lt;alias&gt;/status</code> is set to 1 and <code>Devices/&lt;alias&gt;/message</code> is set to the first received exception message.</li>
<li><a class="anchor" id="b_3_3_14"></a>3.3.14 The device module waits until all running read and write operations of ExceptionHandlingDecorators have ended (wait until DeviceModule::activeTransfers == 0). <a class="el" href="spec_execption_handling.html#comment_b_3_3_14">(*)</a></li>
<li>3.3.15 The thread goes back to <a class="el" href="spec_execption_handling.html#b_3_3_1">3.3.1</a> and tries to re-open the device.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_deviceModule_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_b_3_3_2"></a><a class="el" href="spec_execption_handling.html#b_3_3_2">3.3.2</a> The exact place when this is done does not matter, as long as it is done after <a class="el" href="spec_execption_handling.html#b_3_3_14">3.3.14</a> (no ongoing synchronous transfers) and before <a class="el" href="spec_execption_handling.html#b_3_3_8">3.3.8</a> (resetting deiveHasError). As soon as deviceHasError is cleared new exceptions can be reported, which would be lost if the list was cleared afterwards. Moving it as early as possible after the device has been reopenend has the (slight) advantage, that exceptions which might be reported by asynchronous transfers during the recovery are not discarded, even if the recovery itself does't catch them for some reason. Since exceptions reported by asynchronous transfers are subject to race conditions with the recovery procedure, there cannot be strict guarantees about the behaviour. The optimal place where to reset the queue (to minimise unnecessary recoveries while minimising the probability of rejecting true errors which then need to be found instead later by other transfers) might need to be found in real-life experiments later.</li>
<li><a class="anchor" id="comment_b_3_3_12"></a><a class="el" href="spec_execption_handling.html#b_3_3_12">3.3.12</a> Setting the <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> flag has to be done in the application thread which has caught the exception. If you just send a message and let the device module do both setting and clearing of the flag you can have a race condition: A blocking read would inform the <a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a> about an exception and continue. The next call to the blocking read is supposed to freeze, but pre-read might not detect this because the device module thread has not woken up yet to set the error flag.</li>
<li><a class="anchor" id="comment_b_3_3_14"></a><a class="el" href="spec_execption_handling.html#b_3_3_14">3.3.14</a> The backend has to take care that all operations, also the blocking/asynchronous reads with "waitForNewData", terminate when an exception is thrown, so recovery can take place (see DeviceAccess TransferElement specification).</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_reportException"></a>
B.4 DeviceModule::reportException()</h2>
<ul>
<li>4.1 Acquire unique lock on <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4e61eb7f0c5215a0579f83ee65d0c889" title="Mutex for errorCondVar. ">DeviceModule::errorMutex</a>.</li>
<li>4.2 Just return, if <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> is already true.</li>
<li>4.3 Set <a class="el" href="class_chimera_t_k_1_1_device_module.html#ad329aeca005a9b591168360ec1b068a6" title="The error flag (predicate) for the conditionVariable. ">DeviceModule::deviceHasError</a> to true.</li>
<li>4.4 Write exception message to <a class="el" href="class_chimera_t_k_1_1_device_module.html#a81936a1ddd5c7bf141124aa599181a03" title="Queue used for communication between reportException() and the moduleThread. ">DeviceModule::errorQueue</a>.</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_known_issues"></a>
C. Known issues</h1>
<p>TODO </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li>
    <li class="footer">Generated on Tue May 12 2020 03:53:53 for ChimeraTK-ApplicationCore by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
