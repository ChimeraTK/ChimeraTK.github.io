<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: doc/spec_exceptionHandling.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec__exception_handling_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/spec_exceptionHandling.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="spec__exception_handling_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// put the namespace around the doxygen block so we don&#39;t have to give it all the time in the code to get links</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;namespace ChimeraTK {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/**</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;\page spec_execptionHandling Technical specification: Exception handling for device runtime errors</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;b&gt;DRAFT VERSION, WRITE-UP IN PROGRESS!&lt;/b&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;\section spec_execptionHandling_changes Recent changes</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;This section lists bigger recent changes, which might be hard to track due to restructuring the document at the same time. This section will go away once the changes have been reviewed.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;- Write never blocks in case of exceptions. The following spec points (with discussion why) were hence &lt;b&gt;removed/replaced&lt;/b&gt;. See also the mattermost channel.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  - &lt;strike&gt;Write operations will block immediately until the device has been recovered and the write operation has been completed. [TBD: is this really a good idea? &lt;b&gt;COMMENT&lt;/b&gt;: The order of write operations is still not guaranteed through the recovery accessors (which maybe should be changed), and blocking writes has some severe drawbacks. Not only in fan outs but also in normal ApplicationModules blocking writes will prevent propagation of DataValidity flags! Blocking writes might help if a sequence of values is written to the same register - this is not handled by the recovery accessor. But if a handshake register is read back in between the writes, the situation can already be handled properly (check DataValidity flag, restart sequence after recovery). Maybe blocking writes create more probelms then they solve!? On the other hand, how does the application then know that a write() has no effect yet? E.g. a PI controller might wind-up if actuator and sensor are on different devices and the actuator fails. Then again, how is this different a failing actuator hardware without breaking the communication? Some form of a status readback of the actuator again cures the situation. I think I am in favour of &quot;fire-and-forget&quot; writes.].&lt;/strike&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    - &lt;strike&gt;Write should not block in case of an exception for the outputs of ThreadedFanOut / TriggerFanOut.&lt;/strike&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    - &lt;strike&gt;According to \link spec_initialValuePropagation \endlink, writes in ApplicationModules do not block before the first successful read in the main loop.&lt;/strike&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;- The order of writes during recovery (through recoveryAccessors) is now guaranteed to be the same as the original writes.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;- Direct access to the DataFaultCounter is not necessary. Since the spec says the behavior should be transparent whether a connection is directly made to the device or another ApplicationModule/FanOut is in between, it is sufficient to override the flag returned by ExceptionHandlingDecorator::dataValidity() in case of an exception state. This greatly simplifies the implementation and does not change the behavior.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;\section spec_execptionHandling_intro Introduction</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;Exceptions are handled by ApplicationCore in a way that the application developer does not need to care much about it.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;ChimeraTK::runtime_error exceptions are caught by the framework and are reported to the DeviceModule. The DeviceModule handles this exception and periodically tries to open the device. Communication with the faulty device is frozen or delayed until the device is functional again. In case of several devices only the faulty device is frozen. Faulty devices do not prevent the application from starting, only the parts of the application that depend on the fault device are waiting for the device to come up.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;Input variables of ApplicationModules which cannot be read due to a faulty device will set and propagate the DataValidity::faulty flag (see also \link spec_dataValidityPropagation \endlink).</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;When the device is functional, it be (re)initialised by using application-defined initialisation handlers and also recover the last known values of its process variables.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;\subsection spec_exceptionHandling_intro_terminology Special terminology used in this document</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;- An read operation might be &quot;skipped&quot;. It means, the operation will not take place at all. Instead, the data is marked as DataValidity::faulty. Note: This term is also used, if the a running operation is interrupted by an exception.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;- An read operation might be &quot;frozen&quot;. This means, the function called will not return until the fault state is resolved and the operation is executed. Freezing always happens before the actual operation is executed and hence will always act on pre-existing fault states only.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;- An write operation might be &quot;delayed&quot;. This means, the operation will not be executed immediately and the calling thread continues. The operation will be asynchronosuly executed when the fault state is resolved. Note that the VersionNumber specified in the write operation will be retained and also used for the delayed write operation.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;- Whenever a write operation or a call to write() is mentioned, destructive writes via writeDestructively() are included. The destructive write optimisation makes no difference for the exception handling.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;\section spec_execptionHandling_behavior A. Behavioural description</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;- 1. All ChimeraTK::runtime_error exceptions thrown by device register accessors are handled by the framework and are never exposed to user code in ApplicationModules.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  - 1.1 ChimeraTK::logic_error exceptions are left unhandled and will terminate the application. These errors may only occur in the initialisation phase (up to the point where all devices are opened and initialised) and point to a severe configuration error which is not recoverable. (*)</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  - 1.2 Exception handling and DataValidity flag propagation is implemented such that it is transparent to a module whether it is directly connected to a device, or whether a fanout or another application module is in between.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;- 2. When an exception has been received by the framework (thrown by a device register accessor):</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  - 2.1 The exception status is published as a process variable together with an error message.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    - 2.1.1 The variable Devices/&lt;alias&gt;/status contains a boolean flag whether the device is in an error state</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    - 2.1.2 The variable Devices/&lt;alias&gt;/message contains an error message, if the device is in an error state, or an empty string otherwise.</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  - 2.2 Read operations will propagate the DataValidity::faulty flag to the owning module / fan out (without changing the actual value):</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    - 2.2.1 The normal module algorithm code will be continued, to allow this flag to propagate to the outputs in the same way as if it had been received through the process variable itself (c.f. 1.2).</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    - 2.2.2 The DataValidity::faulty flag resulting from the fault state is propagated once, even if the variable had the a DataValidity::faulty flag already set previously for another reason.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    - 2.2.3 readLatest() (including any read operation without AccessMode::wait_for_new_data) will be skipped. The return value will be false (no new data), if the fault flag has been read once already by the same accessor and hence is already propagated (regardless of the type of the first read), true otherwise.</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    - 2.2.4 Read operations with AccessMode::wait_for_new_data (read(), readNonBlocking() and readAsync()) will be skipped, if the DataValidity::faulty flag has not yet been propagated by the same accessor (which counts as new data, i.e. readNonBlocking() will return true). Otherwise, it will behave like there is no new data: Blocking operations will be frozen, non-blocking operations will be skipped. When the frozen operation is finally executed, another exception might be thrown, in which case the previously frozen operation is finally skipped.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    - 2.2.5 If the fault state had been resolved in between two read operations (regardless of the type) and the device had become faulty again before the second read is executed, it is not defined whether the second operation will frozen/skipped (depending on the type) or not. The second operation might behave either like it is a new exception or like the same fault state would still prevail. (*)</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  - 2.3 Write operations will be delayed. In case of a fault state (new or persisting), the actual write operation will take place asynchronously when the device is recovering. The same mechanism as used for 3.1.2 is used here, hence the order of write operations is guaranteed across accessors, but only the latest written value of each accessor prevails. (*)</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    - 2.3.1 The return value of write() indicates whether data was lost in the transfer. If the write has to be delayed due to an exception, the return value will be true, if a previously delayed and not-yet written value is discarded in the process, false otherwise.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    - 2.3.2 When the delayed value is finally written to the device during the recovery procedure, it is guaranteed that no data loss happens (writes with data loss will be retried).</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    - 2.3.3 It is guaranteed that the write takes place before the device is considered fully recovered again and other transfers are allowed (cf. 3.1).</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  - 2.4 In case of exceptions, there is no guaranteed realtime behavior, not even for &quot;non-blocking&quot; transfers. (*)</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;- 3. The framework tries to resolve an exception state by periodically re-opening the faulty device.</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  - 3.1 After successfully re-opening the device, a recovery procedure is executed before allowing any read/write operations from the AppliactionModules and FanOuts again. This recovery procedure involves:</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    - 3.1.1 the execution of so-called initialisation handlers (see 3.2), and</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    - 3.1.2 restoring all registers that have been written since the start of the application with their latest values. The register values are restored in the same order they were written. (*)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    - 3.1.3 Finally, Devices/&lt;alias&gt;/deviceBecameFunctional is written to inform any module subscribing this variable about the finished recovery. (*)</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  - 3.2 Any number of initialisation handlers can be added to the DeviceModule in the user code. Initialisation handlers are callback function which will be executed when a device is opened for the first time and after a device recovers from an exception, before any process variables are written. See DeviceModule::addInitialisationHandler().</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;- 4. The behavior at application start (when all devices are still closed at first) is similar to the case of a later received exception. The only differences are mentioned in 4.2.</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  - 4.1 Even if some devices are initially in a persisting error state, the part of the application which does not interact with the faulty devices starts and works normally.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  - 4.2 Initial values are correctly propagated after a device is opened. See \link spec_initialValuePropagation \endlink. Especially, all read operations (even readNonBlocking/readLatest) will be frozen until an initial value has been received. (*)</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;\subsection spec_execptionHandling_behavior_comments (*) Comments</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;- 1.1 In future, maybe logic_errors are also handled, so configuration errors can nicely be presented to the control system. This may be important especially since logic_errors may depend also on the configuration of external components (devices). If e.g. a device is changed (e.g. device is another control system application which has been modified), logic_errors may be thrown in the recovery phase, despite the device had been successfully initialsed previously.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;- 2.2.5 Not defining the behavior here avoids a conflict with 1.2 without requiring a complicated implementation which does not block in this case. Implementing this would not present any gain for the application. If there are many exceptions on the same device in a short period of time, the number of faulty data updates seen by the application modules will always depend on the speed the module is attempting to read data (unless we require every exception to be visible to every module, but this will have complex effects, too). It might break consistency of the number of updates sent through different paths in an application, but applications should anyway not rely on that and use a DataConsistencyGroup to synchronise instead. Hence, the implementation will block always if a blocking read sees a known exception</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;- 2.3 / 3.1.3 If timing is important for write operations (e.g. must not write a sequence of registers too fast), or if multiple values need to be written to the same register in sequence, the application cannot fully rely on the framework&#39;s recovery procedure. The framework hence provides the process variable Devices/&lt;alias&gt;/deviceBecameFunctional for each device, which will be written each time the recovery procedure is completed (cf. 3.1.3). ApplicationModules which implement such timed sequence need to receive this variable and restart the entire sequence after the recovery.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;- 2.4 Even non-blocking read and write operations are not truely non-blocking, since they are still synchronous. The &quot;non-blocking&quot; guarantee only means that the operation does not block until new data has arrived, and that it is not frozen until the device is recovered. For the duration of the recovery procedure and of course for timeout periods these operations may still block.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;- 3.1.2 For some applications, the order of writes may be important, e.g. if firmware expects this. Please note that the VersionNumber is insufficient as a sorting criteria, since many writes may have been done with the same VersionNumber (in an ApplicationModule, the VersionNumber used for the writes is determined by the largest VersionNumber of the inputs).</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;- 4.2 DataValidity::faulty is initially set by default, so there is no need to propagate this flag initially. To prevent race conditions and undefined behavior, it even needs to be made sure that the flag is not propagated unnecessarily. The behavior of non-blocking reads presents a slight asymmetry between the initial device opening and a later recovery. This will in particular be visible when restarting a server while a device is offline. If a module only uses readLatest()/readNonBlocking() (= read() for poll-type inputs) for the offline device, the module was still running before the server restart using the last known values for the dysfunctional registers (and flagging all outputs as faulty). After the restart, the module has to wait for the initial value and hence will not run until the device becomes functional again. To make this behavior symmetric, one would need to persist the values of device inputs. Since this only affects a corner case in which anyway no usable output is produced, this slight inconsistency is considered acceptable.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;\section spec_execptionHandling_high_level_implmentation B. Implementation</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;\subsection spec_execptionHandling_high_level_implmentation_TransferElement B.0 Requirements to the DeviceAccess TransferElement</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;Note: This section should be integrated into the TransferElement specification and then removed here. Requirements which are already met by the TransferElement specifciation are not mentioned here.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;- 0.1 readAsync() may only be called if AccessMode::wait_for_new_data is set. It will throw a ChimeraTK::logic_error otherwise.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;- 0.2 If AccessMode::wait_for_new_data is set, the TransferFuture is initialised in the constructor. All read implementations except readLatest() are then using always the TransferFuture.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;- 0.3 readLatest() never uses the TransferFuture. Its implementation is identical to the one read implementation when AccessMode::wait_for_new_data is not set. The return value of readLatest() is changed to void.</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;- 0.4 readTransferAsync() and doReadTransferAsync() are obsolete and hence removed from the interface.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;- 0.5 readAsync() always returns the same TransferFuture in subsequent calls.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;- 0.6 TransferFuture::wait() and TransferFuture::hasNewData(), as well as ReadAnyGroup::waitAny(), call TransferElement::preRead() at the beginning (keep in mind that extra calls to preRead() are ignored) before the transferFutureWaitCallback is called. This makes sure that preRead() and postRead() are always called in pairs.</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;- 0.7 Due to the nature of asynchronous transfers, backends must not expect preRead() to be called before new data arrives and is filled into the cppext::future_queue. Hence, doPreRead() of asynchronous accessor implementations will usually be empty. The call to preRead() is still necessary also for asynchronous transfers, since decorators might have important tasks to be done there.</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;- 0.8 There is no need to call readAsync() for each read transfer again. If the TransferFuture has been obtained once it can simply be used over and over again. Hence, readAsync() will just return the TransferFuture (which had been created in the constructor already) only. It does not call preRead() - this is done by the TransferFuture (see 0.6), and it doesn&#39;t have any side effects. (Maybe it should be renamed into getTransferFuture()).</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;\subsection spec_execptionHandling_high_level_implmentation_decorator B.1 ExceptionHandlingDecorator</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;A so-called ExceptionHandlingDecorator is placed around all device register accessors (used in ApplicationModules and FanOuts). It is responsible for catching the exceptions and implementing most of the behavior described in A.2.</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;- 1.1 A second, undecorated copy of each writeable device register accessor (*) is used as a so-called recoveryAccessor by the ExceptionHandlingDecorator and the DeviceModule. These recoveryAccessor are used to set the initial values of registers when the device is opened for the first time and to recover the last written values during the recovery procedure.</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  - 1.1.1 The recoveryAccessor is stored by the DeviceModule with additional meta data in a so-called RecoveryHelper data structure, which contains:</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    - the recoveryAccessor itself,</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    - the VersionNumber of the (potentially unwritten) data stored in the accessor,</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    - an ordering parameter which determines the order of write opereations during recovery.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    - a flag which indicates whether the value in the recoveryAccessor has already been written to data. (*)</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  - 1.1.2 Ordering can be done per device (*), hence each DeviceModule has one 64-bit atomic counter which is incremented for each write operation and the is value stored in the ordering parameter for the recoveryAccessor.</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  - 1.1.3 The RecoveryHelper object may be accessed only under a lock to prevent concurrent access during recovery. The lock shall be shared to allow concurrent write operations of different registers - only the DeviceModule needs to obtain an exclusive lock during recovery. The lock is obained by the ExceptionHandlingDecorators via DeviceModule::getRecoverySharedLock().</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  </div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;- 1.2 In doPreRead()/doPreWrite(), it is checked whether the fault state already prevails (check DeviceModule::deviceHasError while holding the recovery shared lock).</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  - 1.2.1 If yes, the actual transfer will be skipped. (cf. 2.2 or 2.3.14)</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  - 1.2.2 If the transfer will not be skipped, atomically increment DeviceModule::activeTransfers while still (!) holding the recovery shared lock.</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  - 1.2.3 write: The check for a prevailing fault state has to be done without releasing the lock between the write to the recoveryAccessor and the check. (*)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  - 1.2.4 For skipped transfers, none of the pre/transfer/post functions must be delegated to the target accessor.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  - 1.2.5 If an asynchronous read transfer is skipped, a pseudo value needs to be written to the cppext::future_queue of the TransferFuture. This will cause the TransferFuture to be ready immediatly, so postRead() is called (*).</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;- 1.3 In doPreWrite() the recoveryAccessor with the version number and ordering parameter is updated, and the written flag is cleared.</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  - 1.3.1 If the written flag was previously not set, the return value of doWriteTransfer() must be forced to true (data lost).</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;- 1.4 In doPreRead() certain read operations are frozen in case of a fault state (see A.2.2):</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  - 1.4.1 Obtain the recovery lock through DeviceModule::getRecoverySharedLock(), to prevent interference with an ongoing recovery procedure.</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  - 1.4.2 Decide, whether freezing is done (don&#39;t freeze yet). Freezing is done if one of the following conditions is met:</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    - read type is blocking and AccessMode::wait_for_new_data is set, previousReadFailed == true, and DeviceModule::deviceHasError == true (cf. A.2.2.4), or</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    - no initial value has been read yet (getCurretVersion() == {nullptr}) and DeviceModule::deviceHasError == true (cf. A.4.2).</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  - 1.4.3 Obtain the DeviceModule::errorLock. Only then release the recovery lock. (*)</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  - 1.4.4 Wait on DeviceModule::errorIsReportedCondVar.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  - 1.4.5 When the DeviceModule reports the recovery through the condition variable, delegate preRead() and continue with the transfer normally.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  - 1.4.6 If an asynchronous read transfer is frozen, instead of 1.4.3 thorugh 1.4.5 the following actions are executed:</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    - 1.4.6.1 Register the asynchronous read transfer with the DeviceModule::asynchronousReadQueue by placing a shared_pointer to this on it.</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    - 1.4.6.2 Do not delegate to preRead() and readTransferAsync() - both functions are called by the DeviceModule instead.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    </div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  </div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;- 1.5 In doPostRead()/doPostWrite():</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  - 1.5.1 If there was no exception, set previousReadFailed = false.</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  - 1.5.2 If in 1.2.2 the DeviceModule::activeTransfers counter was incremented, atomically decrement it.</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  - 1.5.3 In doPostWrite() the recoveryAccessor&#39;s written flag is set if the write was successful (no exception thrown; data lost flag does not matter here). (*)</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  - 1.5.4 In doPostRead(), if no exception was thrown, end overriding the DataValidity returned by the accessor (cf. 1.6.2).</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;- 1.6 In doPostRead()/doPostWrite(), any runtime_error exception thrown by the delegated postRead()/postWrite() is caught (*). The following actions are in case of an exception:</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  - 1.6.1 The error is reported to the DeviceModule via DeviceModule::reportException().</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  - 1.6.2 For readable accessors: the DataValidity returned by the accessor is overridden to faulty until next successful read operation (cf. 1.5.4).</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    - 1.6.2.1 The code instantiating the decorator (Application::createDeviceVariable()) has to make sure that the ExceptionHandlingDecorator is &quot;inside&quot; the MetaDataPropagatingRegisterDecorator, so the overriden DataValidity flag in case of an exception is properly propagated to the owning module/fan out.</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  - 1.6.3 Action depending on the calling operation:</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    - 1.6.3.1 All read operations: The ExceptionHandlingDecorator remembers that it is in an exception state by setting previousReadFailed = true</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    - 1.6.3.1 read (push-type inputs): return immediately (*)</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    - 1.6.3.2 readNonBlocking / readLatest / read (poll-type inputs): Just return false (no new data). The calling module thread will continue and propagate the DataValidity::faulty flag (cf. 1.6.2).</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    - 1.6.3.3 write: Do not block. Write will be later executed by the DeviceModule (see 1.1)</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    </div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;- 1.6 In the constructor of the decorator, put the name of the register to DeviceModule::listOfReadRegisters resp. DeviceModule::listOfWriteRegisters depending on the direction the accessor is used.</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;\subsection spec_execptionHandling_high_level_implmentation_deviceModule B.2 DeviceModule</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;- 2.1 The application always starts with all devices as closed. For each device, the initial value for Devices/&lt;alias&gt;/status is set to 1 and the initial value for Devices/&lt;alias&gt;/message is set to an error that the device has not been opened yet (the message will be overwritten with the real error message if the first attempt to open fails, see 2.3.1).</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;- 2.2 The DeviceModule takes care that ExceptionHandlingDecorators initally do not perform any read or write operations, but freeze (cf. 1.4). This happens before running any prepare() of an ApplicationModule, where the first write calls to ExceptionHandlingDecorators might be done.</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;- 2.3 In the DeviceModule thread, the following procedure is executed (in a loop until termination):</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  - 2.3.1 The DeviceModule tries to open the device until it succeeds and isFunctional() returns true.</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    - 2.3.1.1 If the very first attempt to open the device after the application start fails, the error message of the exception is used to overwrite the content of Devices/&lt;alias&gt;/message. Otherwise error messages of exceptions thrown by Device::open() are not visible.</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  - 2.3.2 Obtain lock for accessing recoveryAccessors.</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  - 2.3.3 Check that all registers on DeviceModule::listOfReadRegisters are isReadable() and all registers on DeviceModule::listOfWriteRegisters are isWriteable().</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    - 2.3.3.1 This involves obtaining an accessor for the register first, which is discarded after the check.</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    - 2.3.3.2 If there is an exception, update Devices/&lt;alias&gt;/message with the error message, release the lock and go back to 2.3.1.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    - 2.3.3.3 If one of the accessors does not meet this condition, throw a ChimeraTK::logic_error.</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  - 2.3.4 Device is initialised by iterating initialisationHandlers list.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    - 2.3.4.1 If there is an exception, update Devices/&lt;alias&gt;/message with the error message, release the lock and go back to 2.3.1.</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  - 2.3.5 All valid recoveryAccessors are written in the same order they were originally written.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    - 2.3.5.1 A recoveryAccessor is considered &quot;valid&quot;, if it has already received a value, i.e. its current version number is not {nullptr} any more.</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    - 2.3.5.2 If there is an exception, update Devices/&lt;alias&gt;/message with the error message, release the lock and go back to 2.3.1.</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  - 2.3.6 The queue of reported exceptions is cleared. (*)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  - 2.3.7 Devices/&lt;alias&gt;/status is set to 0 and Devices/&lt;alias&gt;/message is set to an empty string.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  - 2.3.8 DeviceModule allows ExceptionHandlingDecorators to execute reads and writes again (cf. 2.3.14)</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  - 2.3.9 All frozen read operations (cf. 1.4.4) are notified via DeviceModule::errorIsReportedCondVar.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  - 2.3.10 Release lock for recoveryAccessors.</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  - 2.3.11 The DeviceModuleThread waits for the next reported exception.</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  - 2.3.12 An exception is received.</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  - 2.3.13 Devices/&lt;alias&gt;/status is set to 1 and Devices/&lt;alias&gt;/message is set to the first received exception message.</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  - 2.3.14 Set DeviceModule::deviceHasError = true under exclusive recovery lock (cf. 1.2). From this point on, no new transfers will be started.</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  - 2.3.15 The device module waits until all running read and write operations of ExceptionHandlingDecorators have ended (wait until DeviceModule::activeTransfers == 0). (*)</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  - 2.3.16 The thread goes back to 2.3.1 and tries to re-open the device.</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;\subsection spec_execptionHandling_high_level_implmentation_comments (*) Comments</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;- 1.6 Remember: exceptions from other phases are redirected to the post phase by the TransferElement base class.</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;- 1.6.3.1 The freezing is done in doPreRead(), see 1.4.</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;- 1.1 Possible future change: Output accessors can have the option not to have a recovery accessor. This is needed for instance for &quot;trigger registers&quot; which start an operation on the hardware. Also void registers don&#39;t have recovery accessors (once the void data type is supported).</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;- 1.1.1 The written flag cannot be replaced by comparing the version number of the recoveryAccessor and the version number stored in the RecoveryHelper, because normal writes (without exceptions) would not update the version number of the recoveryAccessor.</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;- 1.1.2 The ordering guarantee cannot work across DeviceModules anyway. Different devices may go offline and recover at different times. Even in case of two DeviceModules which actually refer to the same hardware device there is no synchronisation mechanism which ensures the recovering procedure is done in a defined order.</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;- 1.2.5 The cppext::future_queue in the TransferFuture is a notification queue and hence of the type void. So we don&#39;t have to &quot;invent&quot; any value. Also this injection of values is legal, since the queue is multi-producer but single-consumer. This means, potentially concurrent injection of values while the actual accessor might also write to the queue is allowed. Also, the application is the only receiver of values of this queue, so injecting values cannot disturb the backend in any way.</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;- 1.5.3 The written flag for the recoveryAccessor is used to report loss of data. If the loss of data is already reported directly, it should not later be reported again. Hence the written flag is set even if there was a loss of data in this context.</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;- 1.4.3 The order of locks is important here. The recovery lock prevents the DeviceModule from entering the section 2.3.2 to 2.3.10, which includes the notification through the DeviceModule::errorIsReportedCondVar at 2.3.9. The mutex DeviceModule::errorLock is the mutex used for the condition variable. Since the ExceptionHandlingDecorator obtains it before the DeviceModule can start the notification, it is guaranteed that the decorator does not miss the notification. Note that the DeviceModule::errorLock is not a shared lock, so concurrent ExceptionHandlingDecorator::preRead() will mutually exclude, but the mutex is held only for a short time until errorIsReportedCondVar.wait() is called.</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;- 1.6.3 The lock excludes that the DeviceModule is between 2.3.2 and 2.3.10. If it is right before, the device is still in fault state and the value written to the recoveryAccessor is guaranteed to be written in 2.3.5. If it is right after, the exception state has already been resolved and the real write transfer will be attempted by the ExceptionHandlingDecorator.</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;- 2.3.6 The exact place when this is done does not matter, as long as it is done under the lock for the recoveryAccessors.</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;- 2.3.15 The backend has to take care that all operations, also the blocking/asynchronous reads with &quot;waitForNewData&quot;, terminate when an exception is thrown, so recovery can take place (see DeviceAccess TransferElement specification).</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;\section spec_execptionHandling_known_issues Known issues - OUTDATED (numbers don&#39;t even match)</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;&lt;strike&gt;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;- 11.1 In step 2.1: The initial value of deviceError is not set to 1.</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;- 11.2 In step 2.2.3: is not correctly fulfilled as we are only waiting for device to be opened and don&#39;t wait for it to be correctly initialised. The lock 4.2.3 is not implemented at all.</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;- 11.3 In step 2.3.5: is currently being set before initialisationHandlers and writeAfterOpen.</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;- 11.4 Check the documentation of DataValidity. ...&#39;Note that if the data is distributed through a triggered FanOut....&#39;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;- 11.5 Data validity is currently propagated through the &quot;owner&quot;, which conceptually does not always work. A DataFaultCounter needs to be introduced and used at the correct places.</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;- 11.6 In comment to 1.g: recovery accessors are not optional at the moment.</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;- 11.7 In 1.c: Currently data is transported even if the &quot;value after construction&quot; is still in.</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;- 11.8 In 1.i, 6: ThreadedFanout and TriggerFanout do not use non-blocking write because it does not exist yet</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;- 11.9 In 1.j, 2.5.3: Not implemented like that. The first read blocks, and a special mechanism to propagate the flags is triggered only in the next module.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;- 11.10 In 2.3: The device module has a special &quot;first opening&quot; sequence. This is not necessary any more. The &quot;writeAfterOpen&quot; list is obsolete. You can always use the recovery accessors.</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;- 11.11 In 2.3.4: Recovery accessors are always written. It is not checked whether there is valid data (not &quot;value after construction&quot;)</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;- 11.12 In 2.4.1.1: Write probably re-executed after recovery. This should not happen because the recovery accessor has already done it.</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;- 11.13 In 2.5.3: The non-blocking read functions always block on exceptions. They should not (only if there is no initial value).</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;- 11.14 In 2.5.2, 5.1: writeWithoutErrorBlocking is not implemented yet</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;- 11.15 Asynchronous reads are not working with the current implementation, incl. readAny.</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;- 11.16 In 3: DeviceAccess : RegisterAccessors throw in doReadTransfer now.</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;- 11.17 In 4.2.1: reportException does block (should not)</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;- 11.18 In 4.2.2: blocking wait function does not exist (not needed in current implementation as reportException blocks)</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;- 11.19 In 5.2.1: Exceptions are caught in doXxxTransfer instead of doPostXxx.</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;- 11.20 In 5.3.1.2, 5.3.2.1: Decoration of doXxxTransfer does not acquire the lock (which does not even exist yet, see 4.2.3)</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;- 11.21 In 3.2: Decorators might have to try-catch because they usually can only do their task after calling the delegated postXxx.</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;- 11.22 In 3.4: The TransferType is not known. Needs to be implemented in TransferElement</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;- 11.23 In 3.5: PostRead is currently skipped if readNonBlocking or readLatest does not have new data</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;- 11.24 In 3.6: The waitForNewData calls in the DoocsBackend (using zmq) are currently not interruptible</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;&lt;/strike&gt;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;*/</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;} // end of namespace ChimeraTK</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="spec__exception_handling_8md.html">spec_exceptionHandling.md</a></li>
    <li class="footer">Generated on Tue May 5 2020 03:53:33 for ChimeraTK-ApplicationCore by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
