<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ChimeraTK-ControlSystemAdapter: ChimeraTK Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DESY_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ControlSystemAdapter
   &#160;<span id="projectnumber">01.00.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ChimeraTK Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_chimera_t_k_1_1csa__helpers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k_1_1csa__helpers.html">csa_helpers</a></td></tr>
<tr class="memdesc:namespace_chimera_t_k_1_1csa__helpers"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sub-namespace in order not to expose the classes to the <a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a> namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_chimera_t_k_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_application_base.html">ApplicationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for applications.  <a href="class_chimera_t_k_1_1_application_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_bidirectional_process_array.html">BidirectionalProcessArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the process array that transports data in both directions.  <a href="class_chimera_t_k_1_1_bidirectional_process_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for process variables on the control-system side.  <a href="class_chimera_t_k_1_1_control_system_p_v_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_control_system_synchronization_utility.html">ControlSystemSynchronizationUtility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for synchronizing process variables on the control-system side.  <a href="class_chimera_t_k_1_1_control_system_synchronization_utility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_decorator_factory.html">DecoratorFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_decorator_type_holder.html">DecoratorTypeHolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for process variables on the device side.  <a href="class_chimera_t_k_1_1_device_p_v_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_device_synchronization_utility.html">DeviceSynchronizationUtility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for synchronizing process variables on the device side.  <a href="class_chimera_t_k_1_1_device_synchronization_utility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_manual_time_stamp_source.html">ManualTimeStampSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The code manually has to set a time stamp, which is then disctributed to the connected PVs.  <a href="class_chimera_t_k_1_1_manual_time_stamp_source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_persistent_data_storage.html">PersistentDataStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent data storage for process variables.  <a href="class_chimera_t_k_1_1_persistent_data_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array version of the ProcessVariable.  <a href="class_chimera_t_k_1_1_process_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html">ProcessVariableListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listener receiving event notifications for a process variable.  <a href="class_chimera_t_k_1_1_process_variable_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_p_v_manager.html">PVManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_decorator.html">TypeChangingDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strictly this is not a real decorator.  <a href="class_chimera_t_k_1_1_type_changing_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator.html">TypeChangingDirectCastDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decorator does not do mathematical rounding and range checking, but directly assigns the data types (C-style direct conversion).  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_t_00_01std_1_1string_01_4.html">TypeChangingDirectCastDecorator&lt; T, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialisation for strings as impl type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_t_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator.html">TypeChangingRangeCheckingDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decorator uses the boost numeric converter which performs two tasks:  <a href="class_chimera_t_k_1_1_type_changing_range_checking_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01_t_00_01std_1_1string_01_4.html">TypeChangingRangeCheckingDecorator&lt; T, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator.html">TypeChangingStringImplDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is intended as a base class.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_t_00_01std_1_1string_01_4.html">TypeChangingStringImplDecorator&lt; T, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for strings as impl type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_t_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_unidirectional_process_array.html">UnidirectionalProcessArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the process array that transports data in a single direction.  <a href="class_chimera_t_k_1_1_unidirectional_process_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a192dc5dbf7ebc07b1c012381df066b4e"><td class="memItemLeft" align="right" valign="top">typedef ChimeraTK::TransferElement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a192dc5dbf7ebc07b1c012381df066b4e">ProcessVariable</a></td></tr>
<tr class="separator:a192dc5dbf7ebc07b1c012381df066b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7e41ad56888f34fba9598d89cc6bbcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcc">SynchronizationDirection</a> { <a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbccaf9e549c34240abf3968507bace5b56c0">controlSystemToDevice</a>, 
<a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcca00c4c082a5e21df9647ed09777d2b179">deviceToControlSystem</a>, 
<a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcca6f92933a01a85d64cc42bccfd4d0c458">bidirectional</a>
 }<tr class="memdesc:aa7e41ad56888f34fba9598d89cc6bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direction when synchronizing process variables.  <a href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa7e41ad56888f34fba9598d89cc6bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378b03423a5a360b373d3d14136c1b96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a> { <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a4c3daeb243d26d7ecb2a563fdd1de8b6">DecoratorType::range_checking</a>, 
<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224">DecoratorType::limiting</a>, 
<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a6b6318f96cdc11c6a547dcb8753e0a15">DecoratorType::C_style_conversion</a>
 }<tr class="memdesc:a378b03423a5a360b373d3d14136c1b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are three types of TypeChanging decorators which do different data conversions from the user data type to the implementation data type.  <a href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a378b03423a5a360b373d3d14136c1b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b53f55bb55bb18e13425b8d79adef97"><td class="memItemLeft" align="right" valign="top">std::pair&lt; shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> &gt;, shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a1b53f55bb55bb18e13425b8d79adef97">createPVManager</a> ()</td></tr>
<tr class="memdesc:a1b53f55bb55bb18e13425b8d79adef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a PV manager and returns a pair containing references to its <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> and <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> interfaces.  <a href="#a1b53f55bb55bb18e13425b8d79adef97">More...</a><br /></td></tr>
<tr class="separator:a1b53f55bb55bb18e13425b8d79adef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad681512f03c43202cd2eb8e890dacfdc"><td class="memItemLeft" align="right" valign="top">std::map&lt; boost::shared_ptr&lt; ChimeraTK::TransferElement &gt;, boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#ad681512f03c43202cd2eb8e890dacfdc">getGlobalDecoratorMap</a> ()</td></tr>
<tr class="memdesc:ad681512f03c43202cd2eb8e890dacfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quasi singleton to have a unique, global map across UserType templated factories.  <a href="#ad681512f03c43202cd2eb8e890dacfdc">More...</a><br /></td></tr>
<tr class="separator:ad681512f03c43202cd2eb8e890dacfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b513f257155d9245ebed197db95a8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a3b513f257155d9245ebed197db95a8fc">setEnableProcessArrayThreadSafetyCheck</a> (bool enable)</td></tr>
<tr class="memdesc:a3b513f257155d9245ebed197db95a8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally enable or disable the thread safety check on each read/write.  <a href="#a3b513f257155d9245ebed197db95a8fc">More...</a><br /></td></tr>
<tr class="separator:a3b513f257155d9245ebed197db95a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e0912ab9f0f8f1f601a7e698834b9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a885e0912ab9f0f8f1f601a7e698834b9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a885e0912ab9f0f8f1f601a7e698834b9">createBidirectionalSynchronizedProcessArray</a> (std::size_t size, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, T initialValue=T(), std::size_t numberOfBuffers=3, <a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a> sendNotificationListener1=<a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>(), <a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a> sendNotificationListener2=<a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>(), const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:a885e0912ab9f0f8f1f601a7e698834b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bidirectional synchronized process array.  <a href="#a885e0912ab9f0f8f1f601a7e698834b9">More...</a><br /></td></tr>
<tr class="separator:a885e0912ab9f0f8f1f601a7e698834b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9332782c583b0e9e570779a581fdda"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a9332782c583b0e9e570779a581fdda"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a1a9332782c583b0e9e570779a581fdda">createBidirectionalSynchronizedProcessArray</a> (const std::vector&lt; T &gt; &amp;initialValue, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, std::size_t numberOfBuffers=3, <a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a> sendNotificationListener1=<a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>(), <a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a> sendNotificationListener2=<a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>(), const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:a1a9332782c583b0e9e570779a581fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bidirectional synchronized process array.  <a href="#a1a9332782c583b0e9e570779a581fdda">More...</a><br /></td></tr>
<tr class="separator:a1a9332782c583b0e9e570779a581fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8690be421cfecbc1fe176cc019c12060"><td class="memTemplParams" colspan="2">template&lt;class UserType &gt; </td></tr>
<tr class="memitem:a8690be421cfecbc1fe176cc019c12060"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; ChimeraTK::NDRegisterAccessor&lt; UserType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a8690be421cfecbc1fe176cc019c12060">getDecorator</a> (const boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &amp;transferElement, <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a> decoratorType=<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a4c3daeb243d26d7ecb2a563fdd1de8b6">DecoratorType::range_checking</a>)</td></tr>
<tr class="memdesc:a8690be421cfecbc1fe176cc019c12060"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factory function for type changing decorators.  <a href="#a8690be421cfecbc1fe176cc019c12060">More...</a><br /></td></tr>
<tr class="separator:a8690be421cfecbc1fe176cc019c12060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d842c2ce81692303eb38cd42326c30c"><td class="memTemplParams" colspan="2">template&lt;class UserType &gt; </td></tr>
<tr class="memitem:a4d842c2ce81692303eb38cd42326c30c"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; ChimeraTK::NDRegisterAccessor&lt; UserType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a4d842c2ce81692303eb38cd42326c30c">getDecorator</a> (ChimeraTK::TransferElementAbstractor &amp;transferElement, <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a> decoratorType=<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a4c3daeb243d26d7ecb2a563fdd1de8b6">DecoratorType::range_checking</a>)</td></tr>
<tr class="separator:a4d842c2ce81692303eb38cd42326c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5b0302f184e900059436a6b362fcf4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c5b0302f184e900059436a6b362fcf4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a3c5b0302f184e900059436a6b362fcf4">createSynchronizedProcessArray</a> (std::size_t size, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, T initialValue=T(), std::size_t numberOfBuffers=3, bool maySendDestructively=false, <a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a> sendNotificationListener=<a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>(), const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:a3c5b0302f184e900059436a6b362fcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a synchronized process array.  <a href="#a3c5b0302f184e900059436a6b362fcf4">More...</a><br /></td></tr>
<tr class="separator:a3c5b0302f184e900059436a6b362fcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b412ba3ec2f7e8b1e16a45ac87c598"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a22b412ba3ec2f7e8b1e16a45ac87c598"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a22b412ba3ec2f7e8b1e16a45ac87c598">createSynchronizedProcessArray</a> (const std::vector&lt; T &gt; &amp;initialValue, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, std::size_t numberOfBuffers=3, bool maySendDestructively=false, <a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a> sendNotificationListener=<a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>(), const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:a22b412ba3ec2f7e8b1e16a45ac87c598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a synchronized process array.  <a href="#a22b412ba3ec2f7e8b1e16a45ac87c598">More...</a><br /></td></tr>
<tr class="separator:a22b412ba3ec2f7e8b1e16a45ac87c598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af8e5d0ad0f55f729e288d6cdec860a60"><td class="memItemLeft" align="right" valign="top">std::map&lt; boost::shared_ptr&lt; ChimeraTK::TransferElement &gt;, boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#af8e5d0ad0f55f729e288d6cdec860a60">globalDecoratorMap</a></td></tr>
<tr class="separator:af8e5d0ad0f55f729e288d6cdec860a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a192dc5dbf7ebc07b1c012381df066b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ChimeraTK::TransferElement <a class="el" href="namespace_chimera_t_k.html#a192dc5dbf7ebc07b1c012381df066b4e">ChimeraTK::ProcessVariable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_process_variable_8h_source.html#l00007">7</a> of file <a class="el" href="_process_variable_8h_source.html">ProcessVariable.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a378b03423a5a360b373d3d14136c1b96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">ChimeraTK::DecoratorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are three types of TypeChanging decorators which do different data conversions from the user data type to the implementation data type. </p>
<ul>
<li>range_checking This decorator checks the limits and throws an exception of the range is exceeced (for instance if you cast a negative integer to an unsiged int, or 500 to int8_t). This decorator does proper rounding from floating point types t o integer (e.g. 6.7 to 7). </li>
<li>limiting This decorator limits the data to the maximum possible in the target data type (for instance 500 will result in 127 in int8_t and 255 in uint8_t, -200 will be -128 in int8t, 0 in uint8_t). This decorator also does correct rounding from floating point to integer type. </li>
<li>C_style_conversion This decorator does a direct cast like an assigment in C/C++ does it. For instance 500 (=0x1f4) will result in 0xf4 for an 8 bit integer, which is interpreted as 244 in uint8_t and -12 in int8_t. Digits after the decimal point are cut when converting a floating point value to an integer type. This decorator can be useful to display unsigned integers which use the full dynamic range in a control system which only supports signed data types (the user has to correctly interpret the 'wrong' representation), of for bit fields where it is acceptable to lose the higher bits. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a378b03423a5a360b373d3d14136c1b96a4c3daeb243d26d7ecb2a563fdd1de8b6"></a>range_checking&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224"></a>limiting&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a378b03423a5a360b373d3d14136c1b96a6b6318f96cdc11c6a547dcb8753e0a15"></a>C_style_conversion&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_type_changing_decorator_8h_source.html#l00021">21</a> of file <a class="el" href="_type_changing_decorator_8h_source.html">TypeChangingDecorator.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa7e41ad56888f34fba9598d89cc6bbcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcc">ChimeraTK::SynchronizationDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direction when synchronizing process variables. </p>
<p>A process variable may be synchronized from the device library to the control system (input) or from the control system to the device library (output). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa7e41ad56888f34fba9598d89cc6bbccaf9e549c34240abf3968507bace5b56c0"></a>controlSystemToDevice&#160;</td><td class="fielddoc">
<p>Synchronize from the control system to the device library. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa7e41ad56888f34fba9598d89cc6bbcca00c4c082a5e21df9647ed09777d2b179"></a>deviceToControlSystem&#160;</td><td class="fielddoc">
<p>Synchronize from the device library to the control system. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa7e41ad56888f34fba9598d89cc6bbcca6f92933a01a85d64cc42bccfd4d0c458"></a>bidirectional&#160;</td><td class="fielddoc">
<p>Synchronize in both directions. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_synchronization_direction_8h_source.html#l00011">11</a> of file <a class="el" href="_synchronization_direction_8h_source.html">SynchronizationDirection.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a885e0912ab9f0f8f1f601a7e698834b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createBidirectionalSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>&#160;</td>
          <td class="paramname"><em>sendNotificationListener1</em> = <code><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>&#160;</td>
          <td class="paramname"><em>sendNotificationListener2</em> = <code><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bidirectional synchronized process array. </p>
<p>A bidirectional synchronized process array works as a pair of two process arrays, where changes written on either side can be read on the respective other side.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the two coupled process arrays can safely be used by different threads without a mutex. However, both process arrays each only support a single thread. This means that access to each process array have to be protected with a mutex if more than one thread wants to access it.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between. The specified number of buffers is used for each direction.</p>
<p>The specified time-stamp sources are used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used. The first specified time-stamp source is used when sending values from the first returned process array and the second specified time-stamp source is used when sending values from the second returned process array.</p>
<p>The optional send-notification listeners are notified every time one of the process array's ProcessArray::write() method is called. These listeners can be used to queue a request for the receiver's readNonBlocking() method to be called. The process variable passed to the listener is the receiver and not the sender. The first listener is notified when the first of the returned process arrays is sent (and is passed the second of the returned process arrays). The second listener is notified when the second of the returned process arrays is sent (and is passed the first of the returned process arrays).</p>
<p>The specified initial value is used for all the elements of the array.</p>
<p>Of the two returned process arrays, only the first one can take an optional persistent data storage. Trying to set a persistent data storage on the first one results in an exception.</p>
<p>Note: biderectional process arrays are still experimental, so experimental features must be enable when using this function (see ChimeraTK::ExperimentalFeatures in DeviceAccess). </p>

<p>Definition at line <a class="el" href="_bidirectional_process_array_8h_source.html#l00497">497</a> of file <a class="el" href="_bidirectional_process_array_8h_source.html">BidirectionalProcessArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1a9332782c583b0e9e570779a581fdda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createBidirectionalSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>&#160;</td>
          <td class="paramname"><em>sendNotificationListener1</em> = <code><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>&#160;</td>
          <td class="paramname"><em>sendNotificationListener2</em> = <code><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bidirectional synchronized process array. </p>
<p>A bidirectional synchronized process array works as a pair of two process arrays, where changes written on either side can be read on the respective other side.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the two coupled process arrays can safely be used by different threads without a mutex. However, both process arrays each only support a single thread. This means that access to each process array have to be protected with a mutex if more than one thread wants to access it.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between. The specified number of buffers is used for each direction.</p>
<p>The specified time-stamp source is used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used.</p>
<p>The optional send-notification listeners are notified every time one of the process array's ProcessArray::write() method is called. These listeners can be used to queue a request for the receiver's readNonBlocking() method to be called. The process variable passed to the listener is the receiver and not the sender. The first listener is notified when the first of the returned process arrays is sent (and is passed the second of the returned process arrays). The second listener is notified when the second of the returned process arrays is sent (and is passed the first of the returned process arrays).</p>
<p>The array's size is set to the number of elements stored in the vector provided for initialization and all elements are initialized with the values provided by this vector.</p>
<p>Of the two returned process arrays, only the first one can take an optional persistent data storage. Trying to set a persistent data storage on the first one results in an exception.</p>
<p>Note: biderectional process arrays are still experimental, so experimental features must be enable when using this function (see ChimeraTK::ExperimentalFeatures in DeviceAccess). </p>

<p>Definition at line <a class="el" href="_bidirectional_process_array_8h_source.html#l00535">535</a> of file <a class="el" href="_bidirectional_process_array_8h_source.html">BidirectionalProcessArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b53f55bb55bb18e13425b8d79adef97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> &gt; &gt; ChimeraTK::createPVManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a PV manager and returns a pair containing references to its <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> and <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> interfaces. </p>
<p>The <a class="el" href="namespace_chimera_t_k.html#a1b53f55bb55bb18e13425b8d79adef97">createPVManager()</a> function is used to instantiate a <a class="el" href="class_chimera_t_k_1_1_p_v_manager.html">PVManager</a>.</p>
<p>The <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> is only intended for use by the device-library thread and the <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> is only intended for use by the control-system thread. </p>

<p>Definition at line <a class="el" href="_p_v_manager_8cc_source.html#l00041">41</a> of file <a class="el" href="_p_v_manager_8cc_source.html">PVManager.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5b0302f184e900059436a6b362fcf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maySendDestructively</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>&#160;</td>
          <td class="paramname"><em>sendNotificationListener</em> = <code><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a synchronized process array. </p>
<p>A synchronized process array works as a pair of two process arrays, where one process array acts as a sender and the other one acts as a receiver.</p>
<p>The sender allows full read-write access. Changes that have been made to the sender can be sent to the receiver through the ProcessArray::write() method. The receiver can be updated with these changes by calling its readNonBlocking() method.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the sender and the receiver can safely be used by different threads without a mutex. However, both the sender and receiver each only support a single thread. This means that the sender or the receiver have to be protected with a mutex if more than one thread wants to access either of them.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between.</p>
<p>If the <code>maySendDestructively</code> flag is <code>true</code> (it is <code>false</code> by default), the <a class="el" href="class_chimera_t_k_1_1_process_array.html#a9b2548beb21a137be9e8016e29cb4fb6">ProcessArray::writeDestructively()</a> method may be used to transfer values without copying but losing them on the sender side.</p>
<p>The specified time-stamp source is used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used.</p>
<p>The optional send-notification listener is notified every time the sender's ProcessArray::write() method is called. It can be used to queue a request for the receiver's readNonBlocking() method to be called. The process variable passed to the listener is the receiver and not the sender.</p>
<p>The specified initial value is used for all the elements of the array. </p>

<p>Definition at line <a class="el" href="_unidirectional_process_array_8h_source.html#l00636">636</a> of file <a class="el" href="_unidirectional_process_array_8h_source.html">UnidirectionalProcessArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a22b412ba3ec2f7e8b1e16a45ac87c598"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maySendDestructively</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>&#160;</td>
          <td class="paramname"><em>sendNotificationListener</em> = <code><a class="el" href="class_chimera_t_k_1_1_process_variable_listener.html#a7dd2ecde88627d53af6e92941ad54f06">ProcessVariableListener::SharedPtr</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a synchronized process array. </p>
<p>A synchronized process array works as a pair of two process arrays, where one process array acts as a sender and the other one acts as a receiver.</p>
<p>The sender allows full read-write access. Changes that have been made to the sender can be sent to the receiver through the ProcessArray::write() method. The receiver can be updated with these changes by calling its readNonBlocking() method.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the sender and the receiver can safely be used by different threads without a mutex. However, both the sender and receiver each only support a single thread. This means that the sender or the receiver have to be protected with a mutex if more than one thread wants to access either of them.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between.</p>
<p>If the <code>maySendDestructively</code> flag is <code>true</code> (it is <code>false</code> by default), the <a class="el" href="class_chimera_t_k_1_1_process_array.html#a9b2548beb21a137be9e8016e29cb4fb6">ProcessArray::writeDestructively()</a> method may be used to transfer values without copying but losing them on the senderdoWriteTransfer side.</p>
<p>The specified time-stamp source is used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used.</p>
<p>The optional send-notification listener is notified every time the sender's ProcessArray::write() method is called. It can be used to queue a request for the receiver's readNonBlocking() method to be called. The process variable passed to the listener is the receiver and not the sender.</p>
<p>The array's size is set to the number of elements stored in the vector provided for initialization and all elements are initialized with the values provided by this vector. </p>

<p>Definition at line <a class="el" href="_unidirectional_process_array_8h_source.html#l00653">653</a> of file <a class="el" href="_unidirectional_process_array_8h_source.html">UnidirectionalProcessArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8690be421cfecbc1fe176cc019c12060"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; ChimeraTK::NDRegisterAccessor&lt; UserType &gt; &gt; ChimeraTK::getDecorator </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>transferElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a>&#160;</td>
          <td class="paramname"><em>decoratorType</em> = <code><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a4c3daeb243d26d7ecb2a563fdd1de8b6">DecoratorType::range_checking</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The factory function for type changing decorators. </p>
<p>TypeChanging decorators take a transfer element (usually NDRegisterAccessor&lt;ImplType&gt;) and wraps it in an NDRegisterAccessor&lt;UserType&gt;. It automatically performs the right type conversion (configurable as argument of the factory function). The decorator has it's own buffer of type UserType and synchronises it in the preWrite() and postRead() functions with the implementation. You don't have to care about the implementation type of the transfer element. The factory will automatically create the correct decorator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transferElement</td><td>The TransferElement to be decorated. It can either be an NDRegisterAccessor (usually the case) or and NDRegisterAccessorBridge (but here the user already picks the type he wants). </td></tr>
    <tr><td class="paramname">decoratorType</td><td>The type of decorator you want (see description of DecoratorType) </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>eliminate this cast and change map to hold <a class="el" href="class_chimera_t_k_1_1_decorator_type_holder.html">DecoratorTypeHolder</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>eliminate this cast and change map to hold <a class="el" href="class_chimera_t_k_1_1_decorator_type_holder.html">DecoratorTypeHolder</a> </dd></dl>

<p>Definition at line <a class="el" href="_type_changing_decorator_8h_source.html#l00352">352</a> of file <a class="el" href="_type_changing_decorator_8h_source.html">TypeChangingDecorator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d842c2ce81692303eb38cd42326c30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;ChimeraTK::NDRegisterAccessor&lt;UserType&gt; &gt; ChimeraTK::getDecorator </td>
          <td>(</td>
          <td class="paramtype">ChimeraTK::TransferElementAbstractor &amp;&#160;</td>
          <td class="paramname"><em>transferElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a>&#160;</td>
          <td class="paramname"><em>decoratorType</em> = <code><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a4c3daeb243d26d7ecb2a563fdd1de8b6">DecoratorType::range_checking</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_changing_decorator_8h_source.html#l00039">39</a> of file <a class="el" href="_type_changing_decorator_8h_source.html">TypeChangingDecorator.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad681512f03c43202cd2eb8e890dacfdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; boost::shared_ptr&lt; ChimeraTK::TransferElement &gt;, boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &gt; &amp; ChimeraTK::getGlobalDecoratorMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quasi singleton to have a unique, global map across UserType templated factories. </p>
<p>We need it to loop up if a decorator has already been created for the transfer element, and return this if so. Multiple decorators for the same transfer element don't work. </p>

<p>Definition at line <a class="el" href="_type_changing_decorator_8cc_source.html#l00010">10</a> of file <a class="el" href="_type_changing_decorator_8cc_source.html">TypeChangingDecorator.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3b513f257155d9245ebed197db95a8fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::setEnableProcessArrayThreadSafetyCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Globally enable or disable the thread safety check on each read/write. </p>
<p>This will throw an assertion if the thread id has been changed since the last read/write operation which has been executed with the safety check enabled. This will only have an effect if debug compiler flags are enabled. </p>

<p>Definition at line <a class="el" href="_unidirectional_process_array_8cc_source.html#l00007">7</a> of file <a class="el" href="_unidirectional_process_array_8cc_source.html">UnidirectionalProcessArray.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="af8e5d0ad0f55f729e288d6cdec860a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; boost::shared_ptr&lt;ChimeraTK::TransferElement&gt;, boost::shared_ptr&lt;ChimeraTK::TransferElement&gt; &gt; ChimeraTK::globalDecoratorMap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_changing_decorator_8cc_source.html#l00007">7</a> of file <a class="el" href="_type_changing_decorator_8cc_source.html">TypeChangingDecorator.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 19 2019 06:53:17 for ChimeraTK-ControlSystemAdapter by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
