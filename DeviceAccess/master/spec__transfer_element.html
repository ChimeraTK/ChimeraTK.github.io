<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: Technical specification: TransferElement V1.0RC2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec__transfer_element.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Technical specification: <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> V1.0RC2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>**This is a release candidate in implementation.</p>
</blockquote>
<p>The official V1.0 release will be done once the implementation is ready and we know that the specified behavious is working as intended.**</p>
<blockquote class="doxtable">
<p><b>NOTICE FOR FUTURE RELEASES: AVOID CHANGING THE NUMBERING!</b> The tests refer to the sections, incl. links and unlinked references from tests or other parts of the specification. These break, or even worse become wrong, when they are not changed consistenty! </p>
</blockquote>
<h2>Introduction</h2>
<p>This documnent is currently still <b>INCOMPLETE</b>!</p>
<h2>A. Definitions</h2>
<ul>
<li>1. A <em>process variable</em> is the logical entity which is accessed through the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. Outside this document, it is sometimes also called register.<ul>
<li>1.1 A process variable can be read-only, write-only or read-write (bidirectional).</li>
<li>1.2 A process variable has a data type.</li>
<li>1.3 A process variable has a fixed <em>number of elements</em> and a <em>number of channels</em>.<ul>
<li>1.3.1 For scalars, both the number of elements and channels are 1.</li>
<li>1.3.2 For 1D arrays, the number of channels is 1.</li>
</ul>
</li>
</ul>
</li>
<li>2. A <em>device</em> is the logical entity which owns the <em>process variable</em>. The device can be a piece of hardware, another application or even the current application.<ul>
<li>2.1 The first two cases (piece of hardware and another application) are considered identical, since just different <em>backends</em> are used for the communication.</li>
<li>2.2 The third case (current application) is when using the ChimeraTK::ControlSystemAdapter::ProcessArray e.g. in ApplicationCore.</li>
<li>2.3 The application-side behavior of all three cases is identical. The requirements for the implementation are slightly different in some aspects. This will be mentioned where applicable.</li>
</ul>
</li>
<li>3. A <em>transfer</em> is the exchange of data between the application and the device, using a transfer protocol which determines the technical implementation. The protocol used for the transfer is determined by the backend and hence all details about the protocol are abstracted and not visible by the application.</li>
<li>4. An <em>operation</em> is the action taken by the application to read or write data from or to a device. An operation is related to a transfer, yet it is to be distinguished. The transfer can e.g. be initiated by the device, while the operation is always initiated by the application.</li>
<li>5.<a class="anchor" id="transferElement_A_5"></a>The <em>application buffer</em> (sometimes also called user buffer outside this document) is referring to the buffer containing the data and meta data, which is accessible to the application.<ul>
<li>5.1 It can be accessed through the following (non-virtual) functions:<ul>
<li><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ae07a53bd251a3c65105f70a05ef3ffd0" title="Get or set register accessor&#39;s buffer content (1D version). ">NDRegisterAccessor::accessData()</a> / <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ae7320f8139ee7b794743bd4e203fbb12" title="Get or set register accessor&#39;s channel vector. ">NDRegisterAccessor::accessChannel()</a> - gives access to <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ab3e9f790076370e901fd8c6079ed6770" title="Buffer of converted data elements. ">NDRegisterAccessor::buffer_2D</a></li>
<li><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e. ">TransferElement::getVersionNumber()</a> - returns content of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer. Part of the application buffer (see TransferEleme...">TransferElement::_versionNumber</a></li>
<li><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a739e4e90911c3af3fa9aef9c56b08cda" title="Return current validity of the data. ">TransferElement::dataValidity()</a> - returns content of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a39c613419eebb2f29590fecded7a96d0" title="The validity of the data in the application buffer. Part of the application buffer (see TransferEleme...">TransferElement::_dataValidity</a></li>
</ul>
</li>
<li>5.2 If not stated otherwise, the term <em>application buffer</em> refers to <b>all</b> components of the buffer.</li>
<li>5.3 The content of the buffer is filled with data from the device in read operations, and transferred to the device in write operations.</li>
<li>5.4 The content of the buffer can always be modified by the application.(*)</li>
</ul>
</li>
<li>6. Placeholders are used to summarise various function names:<ul>
<li>6.1 xxxYyy(), public, operations called by the application (through the TransfeElementAbstractor)<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">TransferElement::read()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">TransferElement::readNonBlocking()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9488e50bea018025dd4b061afdf2f52b" title="Read the latest value, discarding any other update since the last read if present. ">TransferElement::readLatest()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device. ">TransferElement::write</a>(<a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> versionNumber = {})</li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a91e44b68014588b44adea0d17ec45599" title="Just like write(), but allows the implementation to destroy the content of the user buffer in the pro...">TransferElement::writeDestructively</a>(<a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> versionNumber = {})</li>
</ul>
</li>
<li>6.2 preXxx(), public<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9d8f76450952744a6a046de7b4eb16" title="Perform any pre-read tasks if necessary. ">TransferElement::preRead(TransferType type)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa8dbf971f07658c489d452016244e1a5" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">TransferElement::preWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.3 doPreXxx(), protected virtual<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a60d3b43f03bed1cf27c57fd7e0c76127" title="Backend specific implementation of preRead(). ">TransferElement::doPreRead(TransferType type)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa6ae99999ae6548d80d9f744e93f03bd" title="Backend specific implementation of preWrite(). ">TransferElement::doPreWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.4 xxxTransferYyy(), public<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77" title="Read the data from the device but do not fill it into the user buffer of this TransferElement. ">TransferElement::readTransfer()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ac53f4e5fb0474ea69ab4ae2f6348cef0" title="Read the data from the device but do not fill it into the user buffer of this TransferElement. ">TransferElement::readTransferNonBlocking()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device. ">TransferElement::writeTransfer(VersionNumber versionNumber)</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a04427c0c30fd937a5c85a6bb60120a9e" title="Write the data to the device. ">TransferElement::writeTransferDestructively(VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.5 doXxxTransferYyy(), protected<ul>
<li>void TransferElement::doReadTransferSynchonously(), pure virtual (*)</li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aae3498d969f1eff074cb2a431a3ad687" title="Implementation version of writeTransfer(). ">TransferElement::doWriteTransfer(VersionNumber versionNumber)</a>, pure virtual</li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a98f467545b6682f18cec6b113c5898cc" title="Implementation version of writeTransferDestructively(). ">TransferElement::doWriteTransferDestructively(VersionNumber versionNumber)</a>, virtual</li>
</ul>
</li>
<li>6.6 postXxx(), public<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a71aa608f151dbe46289a6214dd5ece4b" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">TransferElement::postRead(TransferType type, bool hasNewData)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a79fface1764b83bf0f8535616dc08d02" title="Perform any post-write cleanups if necessary. ">TransferElement::postWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.7 doPostXxx(), protected virtual<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a650d977e62e54324d6fc1b281feb0ba7" title="Backend specific implementation of postRead(). ">TransferElement::doPostRead(TransferType type, bool hasNewData)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7c0a6bc5c1779ce47afe7871573ef2a1" title="Backend specific implementation of postWrite(). ">TransferElement::doPostWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
</ul>
</li>
<li>7. Virtual and non-virtual functions<ul>
<li>7.1 The non-virtual functions preXxx(), xxxTransferYyy(), and postXxx() implement common, decorating functionality like exception handling in the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> base class</li>
<li>7.2 They internally call their virtual counterparts which start with 'do'</li>
<li>7.3 The virtual do-functions are the actual implementations of the transfer or pre/post action, which are specific for each backend, decorator etc.</li>
</ul>
</li>
</ul>
<h3>(*) Comments</h3>
<ul>
<li>5.4 The buffer is accessed by the read/write operatons and must not be changed at this time. As transfer elements are not thread safe (B.1) this means the application will either perform an operation or otherwise change the buffer ad libitum.</li>
<li>6.5 doReadTransferSynchonously() is currently called doReadTransfer(). This should be renamed.</li>
</ul>
<h2>B. Behavioural specification</h2>
<ul>
<li>1. TransferElements are not thread safe</li>
<li>2. Data types [TODO]</li>
<li>3. Modes of transfers<ul>
<li>3.1 Read operations:<ul>
<li>3.1.1 The flag <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> determines whether the transfer is initiated by the device side (flag is set) or not.</li>
<li>3.1.2 If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is not set, read operations<ul>
<li>3.1.2.1 obtain the <em>current</em> value of the process variable (if possible/applicable by synchronously communicating with the device),</li>
<li>3.1.2.2 have no information whether the value has changed,</li>
<li>3.1.2.3 behave identical whether read(), readNonBlocking() or readLatest() is called,</li>
<li>3.1.2.4 readNonBlocking() and readLatest() always return true.</li>
</ul>
</li>
<li>3.1.3 If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set<ul>
<li>3.1.3.1 read() blocks until new data has arrived,</li>
<li>3.1.3.2 readNonBlocking() does not block and instead returns whether new data has arrived or not,</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_3_1_4"></a>3.1.4 readLatest() is merely a convenience function which calls readNonBlocking() until no more new data is available. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_3_1_4">T</a>]</li>
</ul>
</li>
<li>3.2 Write operations<ul>
<li>3.2.1 do not distingish on which end the transfer is initiated. The API allows for application-initiated transfers and is compatible with device-initiated transfers as well.<ul>
<li>3.2.1.2 It is guaranteed that the application buffer is still intact after calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device. ">TransferElement::write()</a>.</li>
</ul>
</li>
<li>3.2.2 can optionally be "destructively", which allows the implementation to destroy content of the application buffer in the process.<ul>
<li>3.2.2.1 Applications can allow this optimisation by using writeDestructively() instead of write().</li>
<li><a class="anchor" id="transferElement_B_3_2_2"></a>3.2.2.2 Applications are not allowed to use the content of the application buffer after writeDestructively().<a class="el" href="spec__transfer_element.html#transferElement_comment_B_3_2_2">(*)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_4"></a>4. Stages of an operation initiated by calling the public high level functions xxxYyy() (see. A.6.1) [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_sync">T</a>, <a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_async">T</a> (both except 4.3.2)]<ul>
<li>4.1 preXxx(): calls doPreXxx() of the implementation to allow preparatory work before the actual transfer. doPreXxx() can be empty if nothing is to be done (*)</li>
<li>4.2 xxxTransferYyy():<ul>
<li>4.2.1 readTransfer()<ul>
<li>If wait_for_new_data is set, it waits until new data has been received and returns</li>
<li>If wait_for_new_data is not set, it calls doReadTransferSynchrously()</li>
</ul>
</li>
<li>4.2.2 readTransferNonBlocking()<ul>
<li>If wait_for_new_data is set, it returns immediately with the information whether new data has been received</li>
<li>If wait_for_new_data is not set, it calls doReadTransferSynchrously() and returns true</li>
</ul>
</li>
<li>4.2.3 writeTransferYyy() calls the corresonding doWriteTransferYyy()</li>
<li>4.2.4 Transfer implementations do not change the application buffer</li>
</ul>
</li>
<li>4.3 postXxx(): calls doPostXxx() of the implementation to allow follow-up work after the actual transfer.<ul>
<li>4.3.1 In read transfers, doPostRead() is the only place where the application buffer may be changed (*).</li>
<li><a class="anchor" id="transferElement_B_4_3_2"></a>4.3.2 In write transfers, postWrite() updates the version number of the application buffer <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer. Part of the application buffer (see TransferEleme...">TransferElement::_versionNumber</a> to the version number provided to the write() call, if no exception is (re-)thrown in doPostWrite() (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_11_3">B.11.3</a>). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_3_2">T</a>]</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_5"></a>5. preXxx() and postXxx(), resp. doPreXxx() and doPostXxx(), are always called in pairs. (*) [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_sync">T</a>, <a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_async">T</a> (both without sub-points)]<ul>
<li><a class="anchor" id="transferElement_B_5_1"></a>5.1 This holds even if exceptions (both <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> and <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a>, and also boost::numeric::bad_numeric_cast) are thrown (see 6). <a class="el" href="spec__transfer_element.html#transferElement_comment_B_5_1">(*)</a> [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_1_sync">T</a>, <a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_1_async">T</a>]</li>
<li><a class="anchor" id="transferElement_B_5_2"></a>5.2 The implementations of preXxx() and postXxx() ignore duplicate calls, such that a call to doPreXxx() is never followed by another call to doPreXxx() before doPostXxx() has been called, and vice versa. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_2">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_6"></a>6. Exceptions thrown in preXxx() or xxxTransferYyy() are caught and delayed until postXxx() by the framework. This ensures that preXxx() and postXxx() are always called in pairs. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_6">T</a>]<ul>
<li><a class="anchor" id="transferElement_B_6_1"></a>6.1 If in preXxx() an exception is thrown, the corresponding xxxTransferYyy() is not called, instead directly postXxx() is called. [<a class="el" href="class_transfer_element_test_accessor.html#testTransferElement_B_6_1_read">T</a>, <a class="el" href="class_transfer_element_test_accessor.html#testTransferElement_B_6_1_write">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_7"></a>7. Return values of xxxTransferYyy(): [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_sync">T</a>, <a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_async">T</a> (both except 7.4)]<ul>
<li>7.1 readTransferNonBlocking() returns whether new data has been received (see 4.2.2)</li>
<li><a class="anchor" id="transferElement_B_7_2"></a>7.2 writeTransfer() and writeTransferDestructively() return whether data has been lost. If it returns true, previous data was rejected in the process of the transfer. It is always guaranteed that the data of the current transfer is not lost. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_7_2">(*)</a></li>
<li>7.3 For read operations, the return value is passed on to postRead() (via hasNewData), to allow the doPostXxx() implementations to decide the right actions. In case of readTransfer(), hasNewData is set to true.</li>
<li><a class="anchor" id="transferElement_B_7_4"></a>7.4 In case of an exception in either preRead() or readTransferYyy(), postRead() is called with hasNewData = false because there was no successful transfer. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_4_sync">T</a>, <a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_4_async">T</a>]</li>
</ul>
</li>
<li>8. Read operations with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a>:<ul>
<li>8.1 Since the transfer is initiated by the device side in this case, the transfer is asynchronous to the read operation.</li>
<li><a class="anchor" id="transferElement_B_8_2"></a>8.2 The backend fills any received values into the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> <a class="el" href="spec__transfer_element.html#transferElement_comment_B_8_2">(*)</a>, from which the read()/readNonBlocking() operations will obtain the value. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_2">T</a> (without sub-points)]<ul>
<li>8.2.1 If the queue is full, the last written value will be overwritten.</li>
<li><a class="anchor" id="transferElement_B_8_2_2"></a>8.2.2 The backend may fill a ChimeraTK::detail::DiscardValueException to the queue, which has the same effect on the application side as if no entry was filled to the queue. (*) [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_2_2">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_8_3"></a>8.3 Runtime errors like broken connections are reported by the backend by pushing <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> exceptions into the queue. The exception will then be obtained by the read operation in place of a value. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_3">T</a> (only second sentence)]</li>
<li>8.4 The backend ensures consistency of the value with the device, even if data loss may occur on the transport layer. If necessary, a heartbeat mechanism is implemented to correct any inconsistencies at regular intervals.</li>
<li>8.5 For transfer elements which are created before the device has been opened (or after the device has seen an exception, see 9.) the backend does not fill any data into the queue until the device has successfully been opened and Device::activateAsyncRead() is called (*). Also no runtime_errors are send. We call this <em>asyncronous read is not activated</em> for these transfer elements.<ul>
<li>8.5.1 When Device::activateAsyncRead() is called, it activates asyncronous read for all transfer elements where <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set (*).</li>
<li>8.5.2 When asyncronous read is activated in a transfer element, it must get an initial value synchronously and treat it as if it would have been received, i.e. push it to the queue. This must happen after the actual asynchronous sending has been turned on to make sure no update is missed. (*)</li>
<li>8.5.3 If a transfer element is created while the device is opened and functional, the asynchronous read is activated automatically (incl. sending of the initial value). This happens even if there are other transfer elements which have the asynchronous read deactivated because they have been created before opening the device and Device::activateAsyncRead() has not been called yet.</li>
<li>8.5.4 If Device::activateAsyncRead() is called while the device is not opened or has an error, this call has no effect. If it is called when no deactivated transfer element exists, this call also has no effect.</li>
<li>8.5.5 Device::activateAsyncRead() does not throw any exceptions.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_8_6"></a>8.6 Blocking <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">TransferElement::read()</a> calls can be interrupted by the application via <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Cancel any pending transfer and throw boost::thread_interrupted in its postRead. ">TransferElement::interrupt()</a>.<ul>
<li><a class="anchor" id="transferElement_B_8_6_1"></a>8.6.1 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Cancel any pending transfer and throw boost::thread_interrupted in its postRead. ">TransferElement::interrupt()</a> places a boost::thread_interrupted exception into the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_2"></a>8.6.2 This casues any read operation to complete immediately and throw the boost::thread_interrupted exception, after any unread data on the queue before the exception has been read normally. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_2">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_3"></a>8.6.3 The operation receiving the boost::thread_interrupted exception will also obey <a class="el" href="spec__transfer_element.html#transferElement_B_5">5</a>, i.e. postRead() is still called. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_3">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_4"></a>8.6.4 Calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Cancel any pending transfer and throw boost::thread_interrupted in its postRead. ">TransferElement::interrupt()</a> does not disturb the subsequent operation of the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_4">T</a> (base-class part)]</li>
<li><a class="anchor" id="transferElement_B_8_6_5"></a>8.6.5 Calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Cancel any pending transfer and throw boost::thread_interrupted in its postRead. ">TransferElement::interrupt()</a> without <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> will cause a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_5">T</a>]</li>
</ul>
</li>
</ul>
</li>
<li>9. If one transfer element of a device has seen an exception(*), all other transfer elements of the same device must also be aware of this.<ul>
<li><a class="anchor" id="transferElement_B_9_1"></a>9.1 The transfer element which detects the exception reports it to its TransferElement::exceptionBackend by calling DeviceBackend::setException <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9_1">(*)</a> (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_10_1">10.1</a>)</li>
<li><a class="anchor" id="transferElement_B_9_2"></a>9.2 TransferElements with wait_for_new_data flag<ul>
<li><a class="anchor" id="transferElement_B_9_2_1"></a>9.2.1 Each transfer element deactivates asynchronous reads so no further data is pushed into the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> until open() has been called successfully in the backend (*) and Device::activateAsyncRead() has been called</li>
<li>9.2.2 Exactly one <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> is pushed into the queue of <em>each</em> transfer elements of the backend with wait_for_new_data (*). This must happen after 9.2.1. to avoid race conditions.</li>
<li>9.2.3 The first data on the queue after the exception is the initial value send when calling Device::activateAsyncRead() (see 8.5.2).</li>
<li>9.2.4 The backend must make sure 9.2.2 is finished before a call to Device::activateAsyncRead() re-activates the asynchronous transfers again (*).</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9_3"></a>9.3 TransferElements without wait_for_new_data<ul>
<li><a class="anchor" id="transferElement_B_9_3_1"></a>9.3.1 Each call to doReadTransferSynchonously() will throw a ChimeraTK::runtime error until open() has been called successfully.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9_4"></a>9.4 Write operations will throw a ChimeraTK::runtime error in doWriteTrasferYyy() until open() has been called successfully.</li>
</ul>
</li>
<li>10. DeviceBackends<ul>
<li><a class="anchor" id="transferElement_B_10_1"></a>10.1 DeviceBackend::setException() triggers the actions described in <a class="el" href="spec__transfer_element.html#transferElement_B_9_2">9.2</a>, <a class="el" href="spec__transfer_element.html#transferElement_B_9_3">9.3</a> and <a class="el" href="spec__transfer_element.html#transferElement_B_9_4">9.4</a><ul>
<li><a class="anchor" id="transferElement_B_10_1_1"></a>10.1.1 Meta-backends like the <a class="el" href="class_chimera_t_k_1_1_logical_name_mapping_backend.html" title="Backend to map logical register names onto real hardware registers. ">LogicalNameMappingBackend</a> delegate this call to all of their target backends</li>
<li>10.1.2 Further calls to DeviceBackend::setException() have no effect until <a class="el" href="class_chimera_t_k_1_1_device.html#a0a86afbebd076b8bc1d7bc6fe87db89d" title="Re-open the device after previously closeing it by calling close(). ">Device::open()</a> has successfully been called.</li>
<li><a class="anchor" id="transferElement_B_10_1_3"></a>10.1.3 Application code can call Device::setException() to trigger the exception state <a class="el" href="spec__transfer_element.html#transferElement_comment_B_10_1_3">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_10_2"></a>10.2 TransferElements know which backend to report exceptions to<ul>
<li>10.2.1 TransferElement::exceptionBackend is set when the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is created by a backend</li>
<li>10.2.2 Meta-backends like the <a class="el" href="class_chimera_t_k_1_1_logical_name_mapping_backend.html" title="Backend to map logical register names onto real hardware registers. ">LogicalNameMappingBackend</a> can replace the exceptionBackend so the exception reporting is re-directed to the meta-backend.</li>
</ul>
</li>
</ul>
</li>
<li>11. A <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> object is attached to each data transfer.<ul>
<li>11.1 <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> objects<ul>
<li>11.1.1 can be stricly ordered by their time of creation within the application (process lifetime) using the C++ comparison operators (&lt;, ==, &gt; etc.),</li>
<li>11.1.2 additionaly contain a std::chrono::system_clock timestamp which allows to weakly order the objects even across applications/processes,</li>
<li>11.1.3 are copyable, and</li>
<li>11.1.4 can be initiallised with a {nullptr} which yields a special instance that sorts before all normal instances. All {nullptr} constructed objects are equal (==).</li>
<li>11.1.5 The default constructor creates a new <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> which is larger than all previously created VersionNumbers in a thread safe way.</li>
</ul>
</li>
<li>11.2 <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> objects are used<ul>
<li><a class="anchor" id="transferElement_B_11_2_1"></a>11.2.1 to determine which data is older <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_2_1">(*)</a>, as needed e.g. by bidirectional process variable implementations, and</li>
<li><a class="anchor" id="transferElement_B_11_2_2"></a>11.2.2 to build a consistent data set from multiple TransferElements (see <a class="el" href="class_chimera_t_k_1_1_data_consistency_group.html" title="Group several registers (= TransferElement) which ensures data consistency across multiple variables ...">DataConsistencyGroup</a>). This requires the data sources (e.g. backend implementations) to attach the same <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> to different TransferElements if the data is consistent.</li>
<li>11.2.3 From the previous two points it follows that backend implementations must create a new <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> for all data that is received or read, or associcate a known version number according to <a class="el" href="spec__transfer_element.html#transferElement_B_11_2_2">11.2.2</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_11_3"></a>11.3 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> of the last successfully written/read data of a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> can be obtained through <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e. ">TransferElement::getVersionNumber()</a> (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_4_3_2">B.4.3.2</a>). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_3">T</a>]</li>
<li>11.4 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> for a transfer is given as an optional argument to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device. ">TransferElement::write()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a91e44b68014588b44adea0d17ec45599" title="Just like write(), but allows the implementation to destroy the content of the user buffer in the pro...">TransferElement::writeDestructively()</a>. If the argument is missing, a new <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> is generated.<ul>
<li><a class="anchor" id="transferElement_B_11_4_1"></a>11.4.1 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> passed to the write call must be greater or equal to the one returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e. ">TransferElement::getVersionNumber()</a> of the same <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>, otherwise a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> is thrown by the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> base class. Write calls on different instances of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> (say <code>a</code> and <code>b</code>) do not need to follow this rule, i.e. <code>a-&gt;write(v1); b-&gt;write(v2);</code> is allowed even if <code>v2 &lt; v1</code> <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_4_1">(*)</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_4_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_11_4_2"></a>11.4.2 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> is passed on to the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> implementation via the calls <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa6ae99999ae6548d80d9f744e93f03bd" title="Backend specific implementation of preWrite(). ">TransferElement::doPreWrite()</a>, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aae3498d969f1eff074cb2a431a3ad687" title="Implementation version of writeTransfer(). ">TransferElement::doWriteTransfer()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a98f467545b6682f18cec6b113c5898cc" title="Implementation version of writeTransferDestructively(). ">TransferElement::doWriteTransferDestructively()</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7c0a6bc5c1779ce47afe7871573ef2a1" title="Backend specific implementation of postWrite(). ">TransferElement::doPostWrite()</a>, after the precondition 11.4.1 has been checked. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_4_2">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_11_5"></a>11.5 If a transfer was not successful (exception has been thrown), the <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e. ">TransferElement::getVersionNumber()</a> does not change. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_5">T</a>]</li>
<li><a class="anchor" id="transferElement_B_11_6"></a>11.6 Before the first successful transfer, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e. ">TransferElement::getVersionNumber()</a> always returns the {nullptr} constructed <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_6">T</a>]</li>
<li><a class="anchor" id="transferElement_B_11_7"></a>11.7 <em>To be decided if we only allow 11.7.2:</em> Bi-directional variables<ul>
<li><a class="anchor" id="transferElement_B_11_7_1"></a>11.7.1 <em>either</em> do not guarantee that consecutive calls to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e. ">TransferElement::getVersionNumber()</a> always return a <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> that is equal or greater than the one from the previous call <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_7_1">(*)</a></li>
<li><a class="anchor" id="transferElement_B_11_7_2"></a>11.7.2 <em>or</em> discard values with lower version numbers <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_7_2">(*)</a></li>
</ul>
</li>
</ul>
</li>
<li>12. <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a><ul>
<li>12.1 TransferGroups are only allowed for TransferElements without <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a>.</li>
<li>[TODO]</li>
</ul>
</li>
<li>13. <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers...">ReadAnyGroup</a> [TODO]</li>
<li>14. <a class="el" href="class_chimera_t_k_1_1_data_consistency_group.html" title="Group several registers (= TransferElement) which ensures data consistency across multiple variables ...">DataConsistencyGroup</a> [TODO]</li>
</ul>
<h3>(*) Comments</h3>
<ul>
<li><a class="anchor" id="transferElement_comment_B_3_2_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_3_2_2">3.2.2</a> The optimisation is still optional, backends are allowed to not make use of it. In this case, the content of the application buffer will be intact after writeDestructively(). Applications still are not allowed to use the content of the application buffer after writeDestructively().</li>
<li>4.1 preXxx() is part of the operation, not of the actual transfer. In case of reads with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> the transfer is asynchronously initiated by the device and not connected to the operation. Hence backend implementations usually have an empty doPreWrite(), but decorator-like implementations still can use it to execute preparatory tasks.</li>
<li>4.3.1 In write operations the buffer might be swapped out in doPreRead() and swapped back in doPostRead() to restore it for non-destructive read operations to avoid copying of large arrays.</li>
<li>5. Reason: It might be that the user buffer has to be swapped out during the transfer (while taking away the ownership of the calling code), and this must be restored in the postXxx action.</li>
<li><a class="anchor" id="transferElement_comment_B_5_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_5_1">5.1</a> The boost::thread_interrupted exception, which is thrown internally as described in <a class="el" href="spec__transfer_element.html#transferElement_B_8_6">8.6</a>, is treated equally.</li>
<li><a class="anchor" id="transferElement_comment_B_7_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_7_2">7.2</a> Usually, writes are implemented as synchronous transfers, in which case no previous data can be lost. In case of asynchronous write transfers (as e.g. implemented in the ControlSystemAdapter's ProcessArray), the implementation must ensure the specified behaviour e.g. by using cppext::future_queue::push_overwrite() or a similar functionality. Please keep in mind that the return value of cppext::future_queue::push_overwrite() does not guarantee which data is lost <em>only</em> if concurrent push_overwrite() calls are executed in a multi-producer environment. TransferElements are not thread safe anyway, hence push_overwrite() will always overwrite old data in this context.</li>
<li><a class="anchor" id="transferElement_comment_B_8_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_8_2">8.2</a> Conceptually. In the current implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> is a void queue, which is set up as a continuation of the data transport queue. The important point here that all described actions like exception handling are done on <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a>.</li>
<li>8.2.2 This allows to discard values inside a continuation of a cppext::future_queue. It is used e.g. by the ControlSystemAdapter's BidirectionalProcessArray. [TBD: It could be replaced by a feature of the cppext::future_queue allowing to reject values in continuations...]</li>
<li>8.5 <a class="el" href="class_chimera_t_k_1_1_device.html#a0a86afbebd076b8bc1d7bc6fe87db89d" title="Re-open the device after previously closeing it by calling close(). ">Device::open()</a> does not automatically activate the asyncronous sending because the device might need some initalisation setting to produce valid data (for example setting the correct ADC range). By delaing the activation of asyncronous reads the application has the possibility to do the initialisation before the first data is being send, and can avoid invalid initial values on the process variables.</li>
<li>8.5.1 Conceptually activating an asyncronous read is like subscribing a variable, and deactivating it is like unsubscribing a variable in a publish-subscribe pattern. The actual implementation depends on the details of the protocols.</li>
<li>8.5.2 As the asynchonous mechanism and a synchronous read are two idependent channels there are potential race condition, depending on the exact protocol. The backend has to avoid this if possible. If it cannot be avoided, the implementation must make sure that the last value in the queue is the newest value, and this is not dopped or missed, even if the values before are not in order or send twice.</li>
<li>9. It does not matter if the exception occured in an asynchronous or synchronous read, or in a write operation.</li>
<li><a class="anchor" id="transferElement_comment_B_9_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9_1">9.1</a> It depends on the implementation whether the backend already has done 9.2 and 9.3 when the transfer elements first sees the exeption and then reports it back again via DeviceBackend::setException(), or if it only happend in that function. The important part is that meta-backends and the user application can trigger this situation (see <a class="el" href="spec__transfer_element.html#transferElement_B_10_1_1">10.1.1</a> and <a class="el" href="spec__transfer_element.html#transferElement_B_10_1_3">10.1.3</a>)</li>
<li>9.2.1 Open can be called again on an already opened backend to start error recovery.</li>
<li>9.2.2 If an asynchronous read transfer is the first one to detect the exception, the implementation must make sure that it is only pushed once into the queue, and informing "all" transfer elememnts with wait_for_new data does not send it again if it was already put into the queue.</li>
<li>9.2.4 Avoid race conditions here. The call to Device::activateAsyncRead() usually is done from a different thread than the transfer which caused the exception.</li>
<li><a class="anchor" id="transferElement_comment_B_10_1_3"></a><a class="el" href="spec__transfer_element.html#transferElement_B_10_1_3">10.1.3</a> For instance a watchdog which monitors a reference register to detect firmware reboots that is not seen on the transport layer can trigger the exception state to inhibit asynchronous transfers while running a recovery procedure.</li>
<li><a class="anchor" id="transferElement_comment_B_11_2_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_2_1">11.2.1</a> This means the version number has to be created as soon as data is received, for instance in the receiver thread of a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a>, and not in the doPostRead() of the read() operation.</li>
<li><a class="anchor" id="transferElement_comment_B_11_4_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_4_1">11.4.1</a> Smaller version numbers on later write calls of a different instance can conceptionally not be avoided if the instances are used by different, unsynchronised threads. Even within the same thread, the information written to different instances can come from different sources and hence might have independent version numbers.</li>
<li><a class="anchor" id="transferElement_comment_B_11_7_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_7_1">11.7.1</a> If a write call is done there might be older data in the read queue, which results in a lower version number once a read is called.</li>
<li><a class="anchor" id="transferElement_comment_B_11_7_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_7_2">11.7.2</a> The BiDirectionalProcessArray is implemented like this.</li>
</ul>
<h2>C. Requirements for all implementations (full and decorator-like)</h2>
<ul>
<li>1. Other exceptions than <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a>, <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> and boost::numeric::bad_numeric_cast are not allowed to be thrown or passed through at any place under any circumstance (unless of course they are guaranteed to be caught before they become visible to the application, like the detail::DiscardValueException). The framework (in particular ApplicationCore) may use "uncatchable" exceptions in some places to force the termination of the application. Backend implementations etc. may not do this, since it would lead to uncontrollable behaviour.</li>
<li>2. In doPostXxx no new <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> or <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> are thrown. <em>Only</em> exceptions that were risen in doPreXxx or doXxxTransferYyy, or that were received from the queue (see B.8.3) may be rethrown. This is done by the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> base class in postXxx, so implementations should never actively throw these exceptions in doPostXxx (but decorators must expect exceptions to be thrown by delegated calls).</li>
<li>3. <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> in principle are recoverable. It is thrown, if the device (including the communication link) does not behave as expected. A later call to the same function (after the recovery has been triggered, cf. <a class="el" href="spec__transfer_element.html#transferElement_B_9_2_1">B.9.2.1</a> resp. <a class="el" href="spec__transfer_element.html#transferElement_B_9_3_1">B.9.3.1</a>) must be able to succeed (for instance if a network outage has been resolved). <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> may only be thrown in<ul>
<li>3.1 doXxxTransferYyy(). It is the only exception that can occur in this function</li>
<li>3.2 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946" title="Check if transfer element is readable. ">TransferElement::isReadable()</a>, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8" title="Check if transfer element is writeable. ">TransferElement::isWriteable()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afb77cfdfd4be6fbf76f16d9ada9d2134" title="Check if transfer element is read only, i.e. ">TransferElement::isReadOnly()</a> if there is no map file or such, and it needs to be determined from the running device.</li>
<li>3.3 doPreXxx(), if the information returned by the functions in 3.2 is not yet available and needs to be determined from the running device.</li>
</ul>
</li>
<li>4. boost::numeric::bad_numeric_cast may only be thrown in<ul>
<li>4.1 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa6ae99999ae6548d80d9f744e93f03bd" title="Backend specific implementation of preWrite(). ">TransferElement::doPreWrite()</a></li>
<li>4.2 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a650d977e62e54324d6fc1b281feb0ba7" title="Backend specific implementation of postRead(). ">TransferElement::doPostRead()</a>, but only if hasNewData == true<ul>
<li>4.2.1 As the transfer is successful at this point, the currentVersionNumber must be updated as if the whole operation was successful before throwing the exception.</li>
</ul>
</li>
<li>4.3 This exception can in principle be avoided by chosing a user data type that can fit the data without overflow when reading, or small enough so the process variable can hold the data without overflow when writing. New implementations should not throw this exception. Instead a check should be done in the constructor and a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> should be thrown (see 5.2.4) (*).</li>
</ul>
</li>
<li>5. <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> must follow strict conditions. It is thrown, if the application (including its configuration files) does not behave as expected.<ul>
<li>5.1 logic_errors must be deterministic. They must always be avoidable by calling the corresponding test functions before executing a potentially failing action (*), and must occur if the logical condition is not fulfilled and the function is called anyway.</li>
<li>5.2 Any <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">logic_error</a> must be thrown as early as possible(*). They are thrown <b>if and only if</b> one of the following conditions are met:<ul>
<li>5.2.1 A register does not exists my that name<ul>
<li>5.2.1.1 Can be checked in the catalogue (*)</li>
<li>5.2.1.2 Thrown in the constructor if possible (*), otherwise in doPreXxx(), isReadable(), isWriteable() and isReadOnly().</li>
</ul>
</li>
<li>5.2.2 The size or dimension of the requested <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is too large (*)<ul>
<li>5.2.2.1 Can be checked in the catalogue.</li>
<li>5.2.2.2 Thrown in the constructor if possible, otherwise in doPreXxx().</li>
</ul>
</li>
<li>5.2.3 The wrong AccessMode flags are provided<ul>
<li>5.2.3.1 Can be checked in the catalogue.</li>
<li>5.2.3.2 Thrown in the constructor if possible, otherwise in doPreXxx(), isReadable(), isWriteable() and isReadOnly().</li>
</ul>
</li>
<li>5.2.4 The requested user data type is too small to hold the data without range overflow when reading, or too big when writing (*)<ul>
<li>5.2.4.1 ToDo: cannot be checked in the catalogue to a sufficient degree</li>
<li>5.2.4.2 Thrown in the constructor if possible, otherwise in doPreXxx()</li>
</ul>
</li>
<li>5.2.5 A read/write operation is started while the backend is still closed<ul>
<li>5.2.5.1 Check with <a class="el" href="class_chimera_t_k_1_1_device_backend.html#a877f0db7d0c63becf2bd8b8fb0955e60" title="Return whether a device has been opened or not. ">DeviceBackend::isOpen()</a>.</li>
<li>5.2.5.2 Thrown in doPreXxx() (*)</li>
</ul>
</li>
<li>5.2.6 A read operation is executed on a transfer element that cannot be read<ul>
<li>5.2.6.1 Check with <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946" title="Check if transfer element is readable. ">TransferElement::isReadable()</a>.</li>
<li>5.2.6.2 Thrown in doPreRead()</li>
</ul>
</li>
<li>5.2.7 A write operation is executed on a transfer element that cannot be written<ul>
<li>5.2.7.1 Check with <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8" title="Check if transfer element is writeable. ">TransferElement::isWriteable()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afb77cfdfd4be6fbf76f16d9ada9d2134" title="Check if transfer element is read only, i.e. ">TransferElement::isReadOnly()</a></li>
<li>5.2.7.2 Thrown in doPreWrite()</li>
</ul>
</li>
</ul>
</li>
<li>5.3 The information mentioned in 5.2 which determines whether a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> is thrown is considered to be constant under normal circumstances. Only when open() is called (either for the first time or to recover form a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a>) the information might change and applications are expected to check it again.<ul>
<li><a class="anchor" id="transferElement_C_5_3_1"></a>5.3.1 If a device is changing this information on its own (e.g. makes a register read-only which was readable before), and the application hence performes an operation which is no longer possible, a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> must be thrown (unexpected behaviour of the device). <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_3_1">(*)</a></li>
</ul>
</li>
<li>5.4 Two remarks about how to follow these rules:<ul>
<li>5.4.1 If there is an error in the map file and the backend does not want to fail on this in backend creation, the register must be hidden from the catalogue.</li>
<li>5.4.2 isReadable(), isWriteable() and isReadOnly() might have to check for the existance of the register from a running backend (in case there is no map file). This implies that these calls may throw <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a> and <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a> exceptions.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>(*) Comments</h3>
<ul>
<li>4.3 If there is no map file or such, the information about the target data types must be deretmined from the device. This cannot be done in the constructor if the backend is still closed. In this case the overflow check can happen at runtime and result in a boost::numeric::bad_numeric_cast.</li>
<li>5.1 Test functions do not yet exist for everything. This needs to be changed!</li>
<li>5.2 Especially no <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">logic_error</a> must be thrown in doXxxTransferYyy() or doPostXxx(). All tests for logical consistency must be done in doPreXxx() latest.</li>
<li>5.2.1.1 It is legal to provide "hidden" registers not present in the catalogue, but a register listed in the catalogue must always work.</li>
<li>5.2.1.2 If a backend cannot decide the existence of a register in the accessor's constructor (because there is no map file or such, and the backend might be closed), it needs to check the presence later. If the information is available in the constructor, the check has to be done there.</li>
<li>5.2.2 This also includes that the offset in a one dimensional case is so large that there are not enough elements left to provide the requested data.</li>
<li>5.2.4 Some backends currenty throw a boost::numeric::bad_numeric_cast instead as described in 5.</li>
<li>5.2.5.2 The generic tests if a backend is opened, or if an accessor readable or writeable are intentionally not implemented in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> because they would invovle additional virtual function calls. To avoid these each implementation has to implement the checks in doPreXxx().</li>
<li><a class="anchor" id="transferElement_comment_C_5_3_1"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_3_1">5.3.1</a> To recover from the <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">ChimeraTK::runtime_error</a>, the application must call open(). At that point, the information is allowed to be changed. If the application fails to recheck the information, a retry of the failed operation will result in a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured. ">ChimeraTK::logic_error</a>. This behaviour follows the requirement to throw logic_errors only in doPreXxx(): if during a transfer the backend discovers that the operation is no longer allowed, a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured. ">runtime_error</a> must be thrown.</li>
</ul>
<h2>D. Requirements for full implementations (e.g. in backends)</h2>
<ul>
<li>1. If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is specified:<ul>
<li>1.1 The <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> is a cppext::future_queue of type 'void' which exists in each transfer element. For transfer elements with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> it usually is the continuation queue of another future_queue which is transporting the data. The data type is implementation dependent. Common functionality like exception handling and waiting for new data is implemented on <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a>.</li>
<li>1.2 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> is initialised in the constructor. [TBD: Allow setting the queue length through the public API?]</li>
<li>1.3 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> is pushed whenever new data has arrived. If important for the implementation, the return value of cppext::future_queue::push_overwirte() will tell whether data has been discarded (*).</li>
<li>1.4 In case an exception is detected during an asychronous transfer (for instance in a separate thread), the exception must be stored on the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a>. The <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> will then make sure that the exception is properly rethrown in postRead (just like for synchronous transfers).</li>
</ul>
</li>
</ul>
<h3>(*) Comments</h3>
<p>1.3 Either the currently pushed data or older data on the queue might be discarded. In any case there will be one call less to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a650d977e62e54324d6fc1b281feb0ba7" title="Backend specific implementation of postRead(). ">TransferElement::doPostRead()</a>, because the number of entries in the queue could not be increased because it was full </p><h2>E. Requirements for decorator-like implementations</h2>
<ul>
<li>1. If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is specified, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a> is initialised in the constructor with a copy of the readQueue of the target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.<ul>
<li>1.1 Decorator-like implementations with multiple targets must provide a readQueue e.g. by using cppext::future_queue::when_any() or cppext::future_queue::when_all().</li>
</ul>
</li>
<li>2. All functions doPreXxx, doXxxTransferYyy and doPostXxx must delegate to their non-do counterparts (preXxx, xxxTransferYyy and postXxx). Never delegate to the do... of the target implementation functions directly.</li>
<li>3. If a function of the same instance should be called, e.g. if doWriteTransferDestructively() should redirect to doWriteTransfer(), or if doPostRead() should call doPostRead() of a base class, call to do-version of the function. This is merely to avoid code duplication, hence the surrounding logic of the non-do function is not wanted here.</li>
<li>4. Decorators must merely delegate doXxxTransferYyy, never add any functionalty there. Reason: <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> might effectively bypass the decorator implementation of these functions.</li>
<li>5. All real decorators are in fact decorators of NDRegisterAccessors&lt;USER_TYPE&gt;. Each decoration level contains one NDRegisterAccessors&lt;USER_TYPE&gt;::buffer_2D. The decorator implementation must make sure that its buffer is correctly synchronised with the target's buffer.(*)</li>
</ul>
<h3>(*) Comments</h3>
<ul>
<li>5. The <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" title="Base class for decorators of the NDRegisterAccessor. ">NDRegisterAccessorDecorator</a> base class already contains an implementation which does this in doPreXxx() and doPostXxx(). You usually call it from the Decorators implementation, as mentioned in 3.</li>
</ul>
<h2><a class="el" href="struct_f.html">F</a>. Implementation in the framework (e.g. class <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> itself)</h2>
<p>Note:** This section is biased by the current implementation and mostly lists parts that needs to be changed!</p>
<ul>
<li>1. The <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> will be removed. According to D.1.1 all common functionality is implemented with <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a>, so the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> provides no added value and even complicates the implementation.</li>
<li>2. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a><ul>
<li>2.1 TransferElement::readAsync() will be removed (not deprecated because it would have to return the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a>, which will be removed), (together with readTransferAsync() and doReadTransferAsync()).</li>
<li>2.2 readTransferLatest() and doReadTransferLatest() will be removed.</li>
<li>2.3 doReadTransferNonBlockin() will be removed. The implementation of readTransferNonBlocking will use the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asyncronous read transfers. ">TransferElement::_readQueue</a>.</li>
<li>2.4 readLatest() is directly calling readNonBlocking() in a loop (see B.3.1.4)</li>
<li>2.5 Add function ChimeraTK::detail::getFutureQueueFromTransferElement(), replacing ChimeraTK::detail::getFutureQueueFromTransferFuture().</li>
</ul>
</li>
<li>3. <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers...">ReadAnyGroup</a><ul>
<li>3.1 Use the new ChimeraTK::detail::getFutureQueueFromTransferElement() (or make <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers...">ReadAnyGroup</a> friend of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>?)</li>
</ul>
</li>
<li>4. ApplicationCore<ul>
<li>4.1 For the TestableModeAccessorDecorator: TransferElement::transferFutureWaitCallback() does no longer exist. Instead preRead() will now be called. In case of readAny, multiple calls to preRead() on different accessors will be made on the first call to readAny - the decorator has to deal with that properly. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jun 11 2020 03:53:12 for ChimeraTK-DeviceAccess by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
