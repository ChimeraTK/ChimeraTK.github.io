<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ChimeraTK-DeviceAccess: ChimeraTK::TransferElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a></li><li class="navelem"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_chimera_t_k_1_1_transfer_element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ChimeraTK::TransferElement Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for register accessors which can be part of a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>.  
 <a href="class_chimera_t_k_1_1_transfer_element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ChimeraTK::TransferElement:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_chimera_t_k_1_1_transfer_element.png" usemap="#ChimeraTK::TransferElement_map" alt=""/>
  <map id="ChimeraTK::TransferElement_map" name="ChimeraTK::TransferElement_map">
<area href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. " alt="ChimeraTK::NDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1072,112,1598,136"/>
<area href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends, responsible for the underlying..." alt="ChimeraTK::NumericAddressedLowLevelTransferElement" shape="rect" coords="1608,112,2134,136"/>
<area href="class_chimera_t_k_1_1_n_d_register_accessor.html" alt="ChimeraTK::NDRegisterAccessor&lt; T &gt;" shape="rect" coords="3216,112,3742,136"/>
<area href="class_chimera_t_k_1_1_n_d_register_accessor.html" alt="ChimeraTK::NDRegisterAccessor&lt; TargetUserType &gt;" shape="rect" coords="3752,112,4278,136"/>
<area href="class_async_test_dummy_1_1_accessor.html" alt="AsyncTestDummy::Accessor&lt; UserType &gt;" shape="rect" coords="0,168,526,192"/>
<area href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html" title="Do not use directly, use NDRegisterAccessorDecorator instead! " alt="ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, TargetUserType &gt;" shape="rect" coords="536,168,1062,192"/>
<area href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl_3_01_user_type_00_01_user_type_01_4.html" alt="ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, UserType &gt;" shape="rect" coords="1072,168,1598,192"/>
<area href="class_chimera_t_k_1_1_multiplexed_data_accessor.html" alt="ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;" shape="rect" coords="1608,168,2134,192"/>
<area href="class_chimera_t_k_1_1_sync_n_d_register_accessor.html" title="NDRegisterAccessor for backends with only synchronous transfers (so readAsync() must be implemented w..." alt="ChimeraTK::SyncNDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="2144,168,2670,192"/>
<area href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html" alt="ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; T, T &gt;" shape="rect" coords="3216,168,3742,192"/>
<area href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html" alt="ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; TargetUserType, TargetUserType &gt;" shape="rect" coords="3752,168,4278,192"/>
<area href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" title="Base class for decorators of the NDRegisterAccessor. " alt="ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;" shape="rect" coords="536,224,1062,248"/>
<area href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html" alt="ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;" shape="rect" coords="2680,224,3206,248"/>
<area href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html" alt="ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;" shape="rect" coords="2680,280,3206,304"/>
<area href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html" alt="ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;" shape="rect" coords="2680,336,3206,360"/>
<area href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for multiplexd 2D registers..." alt="ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;" shape="rect" coords="2680,392,3206,416"/>
<area href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for scalar and 1D registers..." alt="ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;" shape="rect" coords="2680,448,3206,472"/>
<area href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" alt="ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;" shape="rect" coords="3216,224,3742,248"/>
<area href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" alt="ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;" shape="rect" coords="3752,224,4278,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5a3283a433fa427031456d9a68878a51"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a5a3283a433fa427031456d9a68878a51">SharedPtr</a></td></tr>
<tr class="memdesc:a5a3283a433fa427031456d9a68878a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for more compact syntax.  <a href="#a5a3283a433fa427031456d9a68878a51">More...</a><br /></td></tr>
<tr class="separator:a5a3283a433fa427031456d9a68878a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc7612bddb9d77191b295b5919ed8eb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acc7612bddb9d77191b295b5919ed8eb0">TransferElement</a> (std::string const &amp;name=std::string(), std::string const &amp;unit=std::string(<a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af4c7678155e4598ca95a4f900b9dfced">unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:acc7612bddb9d77191b295b5919ed8eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer element with the specified name.  <a href="#acc7612bddb9d77191b295b5919ed8eb0">More...</a><br /></td></tr>
<tr class="separator:acc7612bddb9d77191b295b5919ed8eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90287ea25d81da5a74b41c04a89851c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a90287ea25d81da5a74b41c04a89851c4">TransferElement</a> (const <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a90287ea25d81da5a74b41c04a89851c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying and moving is not allowed.  <a href="#a90287ea25d81da5a74b41c04a89851c4">More...</a><br /></td></tr>
<tr class="separator:a90287ea25d81da5a74b41c04a89851c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9c4064e91701c64ececb079179dd70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acf9c4064e91701c64ececb079179dd70">TransferElement</a> (<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:acf9c4064e91701c64ececb079179dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fec2fb2b11be04d6ecad5bdd97d116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a03fec2fb2b11be04d6ecad5bdd97d116">operator=</a> (const <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;other)=delete</td></tr>
<tr class="separator:a03fec2fb2b11be04d6ecad5bdd97d116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a803da60e750f4f734fb7dee3d18a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a40a803da60e750f4f734fb7dee3d18a8">operator=</a> (<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a40a803da60e750f4f734fb7dee3d18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc9b96f43bbf9ca3dec8311fe3e6039"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adbc9b96f43bbf9ca3dec8311fe3e6039">~TransferElement</a> ()</td></tr>
<tr class="memdesc:adbc9b96f43bbf9ca3dec8311fe3e6039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <a href="#adbc9b96f43bbf9ca3dec8311fe3e6039">More...</a><br /></td></tr>
<tr class="separator:adbc9b96f43bbf9ca3dec8311fe3e6039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982337d1951826bb7805f52eaf360793"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a982337d1951826bb7805f52eaf360793">getName</a> () const </td></tr>
<tr class="memdesc:a982337d1951826bb7805f52eaf360793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#a982337d1951826bb7805f52eaf360793">More...</a><br /></td></tr>
<tr class="separator:a982337d1951826bb7805f52eaf360793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff50f318e05a14f70b178e4435be4ef"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2ff50f318e05a14f70b178e4435be4ef">getUnit</a> () const </td></tr>
<tr class="memdesc:a2ff50f318e05a14f70b178e4435be4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#a2ff50f318e05a14f70b178e4435be4ef">More...</a><br /></td></tr>
<tr class="separator:a2ff50f318e05a14f70b178e4435be4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268645180ba07fcf08cd1db21daf71b7"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a268645180ba07fcf08cd1db21daf71b7">getDescription</a> () const </td></tr>
<tr class="memdesc:a268645180ba07fcf08cd1db21daf71b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#a268645180ba07fcf08cd1db21daf71b7">More...</a><br /></td></tr>
<tr class="separator:a268645180ba07fcf08cd1db21daf71b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3294a87f9047329f289dce49edb09db2"><td class="memItemLeft" align="right" valign="top">virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3294a87f9047329f289dce49edb09db2">getValueType</a> () const =0</td></tr>
<tr class="memdesc:a3294a87f9047329f289dce49edb09db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#a3294a87f9047329f289dce49edb09db2">More...</a><br /></td></tr>
<tr class="separator:a3294a87f9047329f289dce49edb09db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d2e84da7325bb205fb4bc51e660aa4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a93d2e84da7325bb205fb4bc51e660aa4">getAccessModeFlags</a> () const =0</td></tr>
<tr class="memdesc:a93d2e84da7325bb205fb4bc51e660aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling. ">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a93d2e84da7325bb205fb4bc51e660aa4">More...</a><br /></td></tr>
<tr class="separator:a93d2e84da7325bb205fb4bc51e660aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21ae3855a6df0e877865702df066f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e">read</a> ()</td></tr>
<tr class="memdesc:aa21ae3855a6df0e877865702df066f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#aa21ae3855a6df0e877865702df066f5e">More...</a><br /></td></tr>
<tr class="separator:aa21ae3855a6df0e877865702df066f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5dce57ab971b6fc68bc13fbd00401c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:a0e5dce57ab971b6fc68bc13fbd00401c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#a0e5dce57ab971b6fc68bc13fbd00401c">More...</a><br /></td></tr>
<tr class="separator:a0e5dce57ab971b6fc68bc13fbd00401c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9488e50bea018025dd4b061afdf2f52b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9488e50bea018025dd4b061afdf2f52b">readLatest</a> ()</td></tr>
<tr class="memdesc:a9488e50bea018025dd4b061afdf2f52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#a9488e50bea018025dd4b061afdf2f52b">More...</a><br /></td></tr>
<tr class="separator:a9488e50bea018025dd4b061afdf2f52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00999178a215bc11d9c1377c6427c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ad00999178a215bc11d9c1377c6427c23">readAsync</a> ()</td></tr>
<tr class="memdesc:ad00999178a215bc11d9c1377c6427c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#ad00999178a215bc11d9c1377c6427c23">More...</a><br /></td></tr>
<tr class="separator:ad00999178a215bc11d9c1377c6427c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a9be48fa8f5cab72e62ce20d99004b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:ae9a9be48fa8f5cab72e62ce20d99004b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#ae9a9be48fa8f5cab72e62ce20d99004b">More...</a><br /></td></tr>
<tr class="separator:ae9a9be48fa8f5cab72e62ce20d99004b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45ffbd50d1903b1ae425d68a2044b26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa45ffbd50d1903b1ae425d68a2044b26">getVersionNumber</a> () const </td></tr>
<tr class="memdesc:aa45ffbd50d1903b1ae425d68a2044b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#aa45ffbd50d1903b1ae425d68a2044b26">More...</a><br /></td></tr>
<tr class="separator:aa45ffbd50d1903b1ae425d68a2044b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb77cfdfd4be6fbf76f16d9ada9d2134"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afb77cfdfd4be6fbf76f16d9ada9d2134">isReadOnly</a> () const =0</td></tr>
<tr class="memdesc:afb77cfdfd4be6fbf76f16d9ada9d2134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <a href="#afb77cfdfd4be6fbf76f16d9ada9d2134">More...</a><br /></td></tr>
<tr class="separator:afb77cfdfd4be6fbf76f16d9ada9d2134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9045dd72e498456e821811ef551b9946"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946">isReadable</a> () const =0</td></tr>
<tr class="memdesc:a9045dd72e498456e821811ef551b9946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#a9045dd72e498456e821811ef551b9946">More...</a><br /></td></tr>
<tr class="separator:a9045dd72e498456e821811ef551b9946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfe1aea9752501fd25381d3e3bdbee8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8">isWriteable</a> () const =0</td></tr>
<tr class="memdesc:accfe1aea9752501fd25381d3e3bdbee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#accfe1aea9752501fd25381d3e3bdbee8">More...</a><br /></td></tr>
<tr class="separator:accfe1aea9752501fd25381d3e3bdbee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab70efc5651769deb2bb6c5d4cb5453"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0ab70efc5651769deb2bb6c5d4cb5453">doReadTransfer</a> ()=0</td></tr>
<tr class="memdesc:a0ab70efc5651769deb2bb6c5d4cb5453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a0ab70efc5651769deb2bb6c5d4cb5453">More...</a><br /></td></tr>
<tr class="separator:a0ab70efc5651769deb2bb6c5d4cb5453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dcdfeb3d4d849cb9d6232727031e51"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae1dcdfeb3d4d849cb9d6232727031e51">doReadTransferNonBlocking</a> ()=0</td></tr>
<tr class="memdesc:ae1dcdfeb3d4d849cb9d6232727031e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ae1dcdfeb3d4d849cb9d6232727031e51">More...</a><br /></td></tr>
<tr class="separator:ae1dcdfeb3d4d849cb9d6232727031e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630bcd4b15d5579c0a97f9beb9b63a22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a630bcd4b15d5579c0a97f9beb9b63a22">doReadTransferLatest</a> ()=0</td></tr>
<tr class="memdesc:a630bcd4b15d5579c0a97f9beb9b63a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a630bcd4b15d5579c0a97f9beb9b63a22">More...</a><br /></td></tr>
<tr class="separator:a630bcd4b15d5579c0a97f9beb9b63a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0ba112ccb6eb9e556710d1151c1602"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afe0ba112ccb6eb9e556710d1151c1602">doReadTransferAsync</a> ()=0</td></tr>
<tr class="memdesc:afe0ba112ccb6eb9e556710d1151c1602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the actual asynchronous read transfer.  <a href="#afe0ba112ccb6eb9e556710d1151c1602">More...</a><br /></td></tr>
<tr class="separator:afe0ba112ccb6eb9e556710d1151c1602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fee71a4c9407193fa021c44aca9f5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d">preRead</a> ()</td></tr>
<tr class="memdesc:a68fee71a4c9407193fa021c44aca9f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any pre-read tasks if necessary.  <a href="#a68fee71a4c9407193fa021c44aca9f5d">More...</a><br /></td></tr>
<tr class="separator:a68fee71a4c9407193fa021c44aca9f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a9f486a967295eacca7f3f78d025bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb">postRead</a> ()</td></tr>
<tr class="memdesc:a19a9f486a967295eacca7f3f78d025bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed.  <a href="#a19a9f486a967295eacca7f3f78d025bb">More...</a><br /></td></tr>
<tr class="separator:a19a9f486a967295eacca7f3f78d025bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51a59d6d5eee3de298f1b3449bb29e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa51a59d6d5eee3de298f1b3449bb29e5">transferFutureWaitCallback</a> ()</td></tr>
<tr class="memdesc:aa51a59d6d5eee3de298f1b3449bb29e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> before entering a potentially blocking wait().  <a href="#aa51a59d6d5eee3de298f1b3449bb29e5">More...</a><br /></td></tr>
<tr class="separator:aa51a59d6d5eee3de298f1b3449bb29e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbf89e74a5db146db0992dfa6c48554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554">preWrite</a> ()</td></tr>
<tr class="memdesc:a2bbf89e74a5db146db0992dfa6c48554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed.  <a href="#a2bbf89e74a5db146db0992dfa6c48554">More...</a><br /></td></tr>
<tr class="separator:a2bbf89e74a5db146db0992dfa6c48554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92f7bd2db9827c3db3c1ff0e29ab581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae92f7bd2db9827c3db3c1ff0e29ab581">postWrite</a> ()</td></tr>
<tr class="memdesc:ae92f7bd2db9827c3db3c1ff0e29ab581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any post-write cleanups if necessary.  <a href="#ae92f7bd2db9827c3db3c1ff0e29ab581">More...</a><br /></td></tr>
<tr class="separator:ae92f7bd2db9827c3db3c1ff0e29ab581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4370c5db79886ac21390f2fa781f2f9c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a4370c5db79886ac21390f2fa781f2f9c">doWriteTransfer</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})=0</td></tr>
<tr class="memdesc:a4370c5db79886ac21390f2fa781f2f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a4370c5db79886ac21390f2fa781f2f9c">More...</a><br /></td></tr>
<tr class="separator:a4370c5db79886ac21390f2fa781f2f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b2f94e5064726b3a93232b3e44207"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9b2f94e5064726b3a93232b3e44207">mayReplaceOther</a> (const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;other) const </td></tr>
<tr class="memdesc:a3b9b2f94e5064726b3a93232b3e44207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> can be used in places where the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> "other" is currently used, e.g.  <a href="#a3b9b2f94e5064726b3a93232b3e44207">More...</a><br /></td></tr>
<tr class="separator:a3b9b2f94e5064726b3a93232b3e44207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40240c8934daf47b9759c5dff3ced91b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a40240c8934daf47b9759c5dff3ced91b">getHardwareAccessingElements</a> ()=0</td></tr>
<tr class="memdesc:a40240c8934daf47b9759c5dff3ced91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a40240c8934daf47b9759c5dff3ced91b">More...</a><br /></td></tr>
<tr class="separator:a40240c8934daf47b9759c5dff3ced91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e099c5ca8a011c59611a17d176719"><td class="memItemLeft" align="right" valign="top">virtual std::list&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a513e099c5ca8a011c59611a17d176719">getInternalElements</a> ()=0</td></tr>
<tr class="memdesc:a513e099c5ca8a011c59611a17d176719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a513e099c5ca8a011c59611a17d176719">More...</a><br /></td></tr>
<tr class="separator:a513e099c5ca8a011c59611a17d176719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e1fa9b9d530997644bcd3a7bd20ff4"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ad2e1fa9b9d530997644bcd3a7bd20ff4">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:ad2e1fa9b9d530997644bcd3a7bd20ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ad2e1fa9b9d530997644bcd3a7bd20ff4">More...</a><br /></td></tr>
<tr class="separator:ad2e1fa9b9d530997644bcd3a7bd20ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791a4902b649e859fbadea20cc90ede2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; newElement)</td></tr>
<tr class="memdesc:a791a4902b649e859fbadea20cc90ede2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a791a4902b649e859fbadea20cc90ede2">More...</a><br /></td></tr>
<tr class="separator:a791a4902b649e859fbadea20cc90ede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848d53a7e57619f8322a8ba3dcf5614"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9848d53a7e57619f8322a8ba3dcf5614">makeCopyRegisterDecorator</a> ()=0</td></tr>
<tr class="memdesc:a9848d53a7e57619f8322a8ba3dcf5614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html" title="Decorator for NDRegisterAccessors which makes a copy of the data from the target accessor. ">CopyRegisterDecorator</a> of the right type decorating this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a9848d53a7e57619f8322a8ba3dcf5614">More...</a><br /></td></tr>
<tr class="separator:a9848d53a7e57619f8322a8ba3dcf5614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d4c154c564848bfb6b08992cdf7059"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a70d4c154c564848bfb6b08992cdf7059">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;)</td></tr>
<tr class="memdesc:a70d4c154c564848bfb6b08992cdf7059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a70d4c154c564848bfb6b08992cdf7059">More...</a><br /></td></tr>
<tr class="separator:a70d4c154c564848bfb6b08992cdf7059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175db832ed1ef931143c16d72461616a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a175db832ed1ef931143c16d72461616a">getId</a> () const </td></tr>
<tr class="memdesc:a175db832ed1ef931143c16d72461616a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique ID for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>, see <a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">TransferElementID</a> for details.  <a href="#a175db832ed1ef931143c16d72461616a">More...</a><br /></td></tr>
<tr class="separator:a175db832ed1ef931143c16d72461616a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b78c177bc98923a78a0d4faaf9e05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05">interrupt</a> ()</td></tr>
<tr class="memdesc:af92b78c177bc98923a78a0d4faaf9e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any pending transfer and throw boost::thread_interrupted in its postRead.  <a href="#af92b78c177bc98923a78a0d4faaf9e05">More...</a><br /></td></tr>
<tr class="separator:af92b78c177bc98923a78a0d4faaf9e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af4c7678155e4598ca95a4f900b9dfced"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af4c7678155e4598ca95a4f900b9dfced">unitNotSet</a> [] = &quot;n./a.&quot;</td></tr>
<tr class="memdesc:af4c7678155e4598ca95a4f900b9dfced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant string to be used as a unit when the unit is not provided or known.  <a href="#af4c7678155e4598ca95a4f900b9dfced">More...</a><br /></td></tr>
<tr class="separator:af4c7678155e4598ca95a4f900b9dfced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa20629db6a741e29320765b5da3220ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa20629db6a741e29320765b5da3220ba">doPreRead</a> ()</td></tr>
<tr class="memdesc:aa20629db6a741e29320765b5da3220ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a>.  <a href="#aa20629db6a741e29320765b5da3220ba">More...</a><br /></td></tr>
<tr class="separator:aa20629db6a741e29320765b5da3220ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8c2303d9bb75b9a13a776f730c3dd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7e8c2303d9bb75b9a13a776f730c3dd6">doPostRead</a> ()</td></tr>
<tr class="memdesc:a7e8c2303d9bb75b9a13a776f730c3dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a>.  <a href="#a7e8c2303d9bb75b9a13a776f730c3dd6">More...</a><br /></td></tr>
<tr class="separator:a7e8c2303d9bb75b9a13a776f730c3dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c69edaa7d618bab49ebf38b7a87b348"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7c69edaa7d618bab49ebf38b7a87b348">doPreWrite</a> ()</td></tr>
<tr class="memdesc:a7c69edaa7d618bab49ebf38b7a87b348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a>.  <a href="#a7c69edaa7d618bab49ebf38b7a87b348">More...</a><br /></td></tr>
<tr class="separator:a7c69edaa7d618bab49ebf38b7a87b348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8c0cb33f798ad604ce6f2cdf6f7ff9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a6b8c0cb33f798ad604ce6f2cdf6f7ff9">doPostWrite</a> ()</td></tr>
<tr class="memdesc:a6b8c0cb33f798ad604ce6f2cdf6f7ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae92f7bd2db9827c3db3c1ff0e29ab581" title="Perform any post-write cleanups if necessary. ">postWrite()</a>.  <a href="#a6b8c0cb33f798ad604ce6f2cdf6f7ff9">More...</a><br /></td></tr>
<tr class="separator:a6b8c0cb33f798ad604ce6f2cdf6f7ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833c655eca8c53f5ff0d97c3d81c1376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a833c655eca8c53f5ff0d97c3d81c1376">makeUniqueId</a> ()</td></tr>
<tr class="memdesc:a833c655eca8c53f5ff0d97c3d81c1376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow generating a unique ID from derived classes.  <a href="#a833c655eca8c53f5ff0d97c3d81c1376">More...</a><br /></td></tr>
<tr class="separator:a833c655eca8c53f5ff0d97c3d81c1376"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a13235d15a13bfc43764e464f1b6fe50d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a13235d15a13bfc43764e464f1b6fe50d">_name</a></td></tr>
<tr class="memdesc:a13235d15a13bfc43764e464f1b6fe50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier uniquely identifying the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a13235d15a13bfc43764e464f1b6fe50d">More...</a><br /></td></tr>
<tr class="separator:a13235d15a13bfc43764e464f1b6fe50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fffb069722f43530cecbcaa40b7c670"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a8fffb069722f43530cecbcaa40b7c670">_unit</a></td></tr>
<tr class="memdesc:a8fffb069722f43530cecbcaa40b7c670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engineering unit.  <a href="#a8fffb069722f43530cecbcaa40b7c670">More...</a><br /></td></tr>
<tr class="separator:a8fffb069722f43530cecbcaa40b7c670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f52cb447c14f6e01f716c3d040238e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a66f52cb447c14f6e01f716c3d040238e">_description</a></td></tr>
<tr class="memdesc:a66f52cb447c14f6e01f716c3d040238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of this variable/register.  <a href="#a66f52cb447c14f6e01f716c3d040238e">More...</a><br /></td></tr>
<tr class="separator:a66f52cb447c14f6e01f716c3d040238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a42fc668a7d9243dd024729737f35a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a1a42fc668a7d9243dd024729737f35a7">_id</a></td></tr>
<tr class="memdesc:a1a42fc668a7d9243dd024729737f35a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a1a42fc668a7d9243dd024729737f35a7">More...</a><br /></td></tr>
<tr class="separator:a1a42fc668a7d9243dd024729737f35a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fafaaed44dd2c55bcd8a24a99e3e86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa5fafaaed44dd2c55bcd8a24a99e3e86">isInTransferGroup</a></td></tr>
<tr class="memdesc:aa5fafaaed44dd2c55bcd8a24a99e3e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not.  <a href="#aa5fafaaed44dd2c55bcd8a24a99e3e86">More...</a><br /></td></tr>
<tr class="separator:aa5fafaaed44dd2c55bcd8a24a99e3e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e0da1696dcfda8b285a818e6555f2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa5e0da1696dcfda8b285a818e6555f2d">readTransactionInProgress</a> {false}</td></tr>
<tr class="memdesc:aa5e0da1696dcfda8b285a818e6555f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether a read transaction is in progress.  <a href="#aa5e0da1696dcfda8b285a818e6555f2d">More...</a><br /></td></tr>
<tr class="separator:aa5e0da1696dcfda8b285a818e6555f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed11ca7a5de19b71ce48c00a13ad9a6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aed11ca7a5de19b71ce48c00a13ad9a6f">writeTransactionInProgress</a> {false}</td></tr>
<tr class="memdesc:aed11ca7a5de19b71ce48c00a13ad9a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether a write transaction is in progress.  <a href="#aed11ca7a5de19b71ce48c00a13ad9a6f">More...</a><br /></td></tr>
<tr class="separator:aed11ca7a5de19b71ce48c00a13ad9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d4de78e82adea96f87d98ef828ad9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae38d4de78e82adea96f87d98ef828ad9">hasActiveFuture</a> {false}</td></tr>
<tr class="memdesc:ae38d4de78e82adea96f87d98ef828ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether there is a valid activeFuture or not.  <a href="#ae38d4de78e82adea96f87d98ef828ad9">More...</a><br /></td></tr>
<tr class="separator:ae38d4de78e82adea96f87d98ef828ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60ec6ab982e620f5bfdc3b5bbed9928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af60ec6ab982e620f5bfdc3b5bbed9928">activeFuture</a></td></tr>
<tr class="memdesc:af60ec6ab982e620f5bfdc3b5bbed9928"><td class="mdescLeft">&#160;</td><td class="mdescRight">last future returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afe0ba112ccb6eb9e556710d1151c1602" title="Start the actual asynchronous read transfer. ">doReadTransferAsync()</a> (valid if hasActiveFuture == true)  <a href="#af60ec6ab982e620f5bfdc3b5bbed9928">More...</a><br /></td></tr>
<tr class="separator:af60ec6ab982e620f5bfdc3b5bbed9928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5bdf5501b097a054a0be0bd5c8332ef3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a5bdf5501b097a054a0be0bd5c8332ef3">TransferGroup</a></td></tr>
<tr class="separator:a5bdf5501b097a054a0be0bd5c8332ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6cb788c9f76a35a66d7b6266e94c70"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aba6cb788c9f76a35a66d7b6266e94c70">TransferFuture</a></td></tr>
<tr class="separator:aba6cb788c9f76a35a66d7b6266e94c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for register accessors which can be part of a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00043">43</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5a3283a433fa427031456d9a68878a51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a5a3283a433fa427031456d9a68878a51">ChimeraTK::TransferElement::SharedPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typedef for more compact syntax. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00062">62</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc7612bddb9d77191b295b5919ed8eb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElement::TransferElement </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>std::string(<a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af4c7678155e4598ca95a4f900b9dfced">unitNotSet</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transfer element with the specified name. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00048">48</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90287ea25d81da5a74b41c04a89851c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElement::TransferElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying and moving is not allowed. </p>

</div>
</div>
<a class="anchor" id="acf9c4064e91701c64ececb079179dd70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElement::TransferElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adbc9b96f43bbf9ca3dec8311fe3e6039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElement::~TransferElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstract base classes need a virtual destructor. </p>

<p>Definition at line <a class="el" href="_transfer_element_8cc_source.html#l00014">14</a> of file <a class="el" href="_transfer_element_8cc_source.html">TransferElement.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7e8c2303d9bb75b9a13a776f730c3dd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::doPostRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> will call this function, but it will make sure that it gets called only once per transfer. </p>

<p>Reimplemented in <a class="el" href="struct_counting_decorator.html#af17dba8c6c952e86fabcce3ee97740b6">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a1e8355eb4b787c2e2af7450bbc993119">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a07414dec4d2597c6f619ce1a2ed3e86b">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_fixed_point_converting_decorator.html#a1ae97538123e1ae2cf968d1053612566">ChimeraTK::FixedPointConvertingDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a9d04d68bf54ee0904aac8c80f5a600e1">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a1e29174e15c277fc01b87b95d5402837">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#ae9bcbcb5186bd5f2f3efaf81571b22c7">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#ae26fa6a9d2ccc331bd6789d4ab5d759b">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a2fdf9f5b975380f165a35af1f639cf44">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl_3_01_user_type_00_01_user_type_01_4.html#a71ddec8d518eb2fad90bdf0f3a7d4dde">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#afe4e74b6ad65f5f44295f03b9fb38be4">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html#a5f2ec18ce09d8eecf92f5cdef6aacab0">ChimeraTK::CopyRegisterDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#acb122ec59eba02df0aa57ba26b0ed56b">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#acb122ec59eba02df0aa57ba26b0ed56b">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; TargetUserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#acb122ec59eba02df0aa57ba26b0ed56b">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; T, T &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a1e8355eb4b787c2e2af7450bbc993119">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00284">284</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6b8c0cb33f798ad604ce6f2cdf6f7ff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::doPostWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae92f7bd2db9827c3db3c1ff0e29ab581" title="Perform any post-write cleanups if necessary. ">postWrite()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae92f7bd2db9827c3db3c1ff0e29ab581" title="Perform any post-write cleanups if necessary. ">postWrite()</a> will call this function, but it will make sure that it gets called only once per transfer. </p>

<p>Reimplemented in <a class="el" href="struct_counting_decorator.html#a0dbbb8724d6fb430a7273384038ec9b7">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a7d18bc583205ecd4b20a140f0940956f">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a41d7fd3417c44c29c1bdde957996ecb0">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_fixed_point_converting_decorator.html#a61178421f9b40c1a7eab9b7b1424b93c">ChimeraTK::FixedPointConvertingDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a0271abadd9baf96701ce0ad833eb0695">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#ac9b6232398ce5c2ff9de4dd1fa26f3ec">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a9db230877a82c5e0f86a3d46d6346173">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl_3_01_user_type_00_01_user_type_01_4.html#a0a3260e66724803d64704fe9b6a6c12e">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a7d18bc583205ecd4b20a140f0940956f">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#ad8f9507a9d339100fd6a0bd32a334784">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#ad8f9507a9d339100fd6a0bd32a334784">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; TargetUserType, TargetUserType &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#ad8f9507a9d339100fd6a0bd32a334784">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; T, T &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00329">329</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa20629db6a741e29320765b5da3220ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::doPreRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a> will call this function, but it will make sure that it gets called only once per transfer. </p>

<p>Reimplemented in <a class="el" href="struct_counting_decorator.html#a7ec5a1b19ea552e9dc2cfe6631d669ff">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a036928797b3dddf595212ac5f47defaf">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a036928797b3dddf595212ac5f47defaf">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a036928797b3dddf595212ac5f47defaf">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_fixed_point_converting_decorator.html#ada633abd1697fa1bcbf42d7d8d4e59ba">ChimeraTK::FixedPointConvertingDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#ac8b9ce4e557100e337f400f5d86bae60">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#acd485fb4bfec8051a8f0bc758bfb4207">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a13dfec9e5ab10343550dec9032a51782">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl_3_01_user_type_00_01_user_type_01_4.html#ae81914760d4dfd1dd7d85aa586d04ca8">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#a067d374a7ee40e39bee3211de1d05070">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#a067d374a7ee40e39bee3211de1d05070">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; TargetUserType, TargetUserType &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#a067d374a7ee40e39bee3211de1d05070">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; T, T &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00265">265</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c69edaa7d618bab49ebf38b7a87b348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::doPreWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> will call this function, but it will make sure that it gets called only once per transfer. </p>

<p>Reimplemented in <a class="el" href="struct_counting_decorator.html#a6fcd156803f71ef2c5af4baddf8b9488">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a60ad2f0bffeb4b1a58010b34afaea44e">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a581ca08228fff93c63689223b734a767">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_fixed_point_converting_decorator.html#a6c3662426ecf07adf7118f0d41085068">ChimeraTK::FixedPointConvertingDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a6f06a6825cf0df140f9dab67b8a2a87a">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a347c5464edd647d9a0d55d13cad32dfd">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#af560f1a8d4830b633b8d21bdb023a2ff">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl_3_01_user_type_00_01_user_type_01_4.html#a7a9035d74ec9fbe8c806675554865214">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#aa67ef3fd7e75b0a4cafd13f56ad18515">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#ad58eb8b41b679043e96f05891eabdcd4">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#ad58eb8b41b679043e96f05891eabdcd4">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; TargetUserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#ad58eb8b41b679043e96f05891eabdcd4">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; T, T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a60ad2f0bffeb4b1a58010b34afaea44e">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html#a2a75fe8588316be29f3db5b466dfdd9d">ChimeraTK::CopyRegisterDecorator&lt; T &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00311">311</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ab70efc5651769deb2bb6c5d4cb5453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::doReadTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function after <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a> and followed by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a>.</p>
<p>Implementation note: This function must return within ~1 second after boost::thread::interrupt() has been called on the thread calling this function. </p>

<p>Implemented in <a class="el" href="struct_counting_decorator.html#a6bce6fefb4061b6002f70e6fc0af09d6">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#aee64822ef89030905473c3877bdf1cff">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#aee64822ef89030905473c3877bdf1cff">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#aee64822ef89030905473c3877bdf1cff">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#ad5047e2e9bd8ff1ec8064b076c424630">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a98b69b7d25ee1d7ecf2954b6a2474876">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#aaa801140d135a892da24c50f76ba86e5">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#aba9aa3aa1c4c6f979cfab81aaecda544">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a118f8d727546f5a206315b222f42905a">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a2425c1512d41e860d53a8d2e4f762789">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a6dc38b2e515f220041b149d5fd6425c2">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#ae32ece34dc312d0bdfd3ef0754394ae1">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afe0ba112ccb6eb9e556710d1151c1602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> ChimeraTK::TransferElement::doReadTransferAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the actual asynchronous read transfer. </p>
<p>This function must be implemented by the backends and will be called inside <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ad00999178a215bc11d9c1377c6427c23" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>. At that point, it is guaranteed that there is no unfinished transfer still ongoing (i.e. no still-valid <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> is present) and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a> has already been called.</p>
<p>The backend must never touch the user buffer (i.e. <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a090e36fbf49720603758f0d8485c52ff" title="Buffer of converted data elements. ">NDRegisterAccessor::buffer_2D</a>) inside this function, as it may only be filled inside <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a>. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> will get called by the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> when the user calls wait().</p>
<p>Note: The <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> returned by this function must have been constructed with this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> as the transferElement in the constructor. Otherwise <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> will not be properly called! </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a2943e87c50c5c50ca445606d3ecf956a">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a2943e87c50c5c50ca445606d3ecf956a">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a2943e87c50c5c50ca445606d3ecf956a">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a1806471c7dfbce0196402a608b640452">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a651e8e50fb57977e6632481b97d4d587">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_sync_n_d_register_accessor.html#a963ae41a4d58ce06c24a7bf6fbbd8f3a">ChimeraTK::SyncNDRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="class_async_test_dummy_1_1_accessor.html#ad1f476ac5c4ddf37c392f645addb80e0">AsyncTestDummy::Accessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a630bcd4b15d5579c0a97f9beb9b63a22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::doReadTransferLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function after <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a> and followed by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9488e50bea018025dd4b061afdf2f52b" title="Read the latest value, discarding any other update since the last read if present. ">readLatest()</a>. For the return value, see <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implemented in <a class="el" href="struct_counting_decorator.html#a80477afdc92d145bf6bbe21a12e06d0a">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#ad7cdf782dd954f673b9099cbd288deec">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#ad7cdf782dd954f673b9099cbd288deec">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#ad7cdf782dd954f673b9099cbd288deec">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a4f7002f3b9a35655ab6f33cfa85e923d">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#ab7f6f5b56e5080715f54138c8828e6a5">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#aee7aeba1f2963654fc802e4e64899974">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a1fd97ea57cd4e3421131f274b48014ab">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a11887963cb58c9abf511912474089e17">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a2b7e081f467c5acce6826ab9aec1488c">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a155e171e75872b4c042830581f003d13">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#a1de3baca25098ad2eff628d8d6779213">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae1dcdfeb3d4d849cb9d6232727031e51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::doReadTransferNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function after <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a> and followed by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. For the return value, see <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implemented in <a class="el" href="struct_counting_decorator.html#a5b06f194cb4fdaabf514bba23d5380e4">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a520f730055973aed089f1934e21b6a74">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a520f730055973aed089f1934e21b6a74">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a520f730055973aed089f1934e21b6a74">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a2211e6adeecc128fe994f066e374b86f">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#aa07aa47f7178dc62c5cbefecea4e2cf3">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#af622b11dc5f9123a599472eee3737aeb">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a2e56ec89fb07d674c29d0b24aa973011">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a084a097813242ae9b6e0aae2d511fe4b">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a50de130eac1677d21d6b4b94e2488a4a">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a288f9f8fee00bf3dd59b66260d71fb20">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#ae87b15813ed949737b915c7cb6247fc6">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4370c5db79886ac21390f2fa781f2f9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::doWriteTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false.</p>
<p>Calling this function after <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> and followed by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae92f7bd2db9827c3db3c1ff0e29ab581" title="Perform any post-write cleanups if necessary. ">postWrite()</a> is exactly equivalent to a call to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device. ">write()</a>. </p>

<p>Implemented in <a class="el" href="struct_counting_decorator.html#a8a77f922cba0f713d1deddf88dc75f8b">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a3cd3bbd513f091f02f5ea4523dc93171">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a1032867d528a5c0a3605e2b482ec23ba">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a3cd3bbd513f091f02f5ea4523dc93171">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a3cd3bbd513f091f02f5ea4523dc93171">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a7e7fdeb92a3ce2c73deedbac7be08815">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#abbc304c2523ed3c8ff9b45aeb6df09bf">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#aca334fad0f5eced20984d4af5c3c8e0a">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a365ef5a2e7f4bdf9f28fcbc89c455737">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a94393d5a4740d99038307c484539094e">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#a15f0096e289f68d51127268e011bc5d5">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#ac5415f6bb9bf05adda1039268be7d21b">ChimeraTK::NumericAddressedLowLevelTransferElement</a>.</p>

</div>
</div>
<a class="anchor" id="a93d2e84da7325bb205fb4bc51e660aa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a> ChimeraTK::TransferElement::getAccessModeFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling. ">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a46dcf9bcfc9954ca8a0719d741f88d05">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a96b365f767af7bd6bb3199fc5e1d7902">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a96b365f767af7bd6bb3199fc5e1d7902">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a96b365f767af7bd6bb3199fc5e1d7902">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a7969fcf5c8f7bb62da4d3e3c990784a6">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#aeb580bda2db02aed5ac1b6fbf01c6fbb">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#abf96487a5b7f0f2bda13a00f0ff7cb9f">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a6fcefb23ff468baa1bd92cad6800ce89">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a79664336eb70c7e991a98dbf1d6e5101">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a2d58a181c1a345b0b9ab6bbf6490c428">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#ac27cea94fc839e8f3d08b7af7ee80009">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a268645180ba07fcf08cd1db21daf71b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ChimeraTK::TransferElement::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of this variable/register. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00075">75</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40240c8934daf47b9759c5dff3ced91b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; &gt; ChimeraTK::TransferElement::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implemented in <a class="el" href="struct_counting_decorator.html#a68fe403a29fbe233842f88f7f4b78eef">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a29fdbbd2a89020449614d6517d0a2596">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a50bd27e60ca0befb9df61a142f1032e0">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a64d5b5f1bd28e0eeae412ab6b3f58da6">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a98f97d88359efe4cf93c2a76a75e2936">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a98f97d88359efe4cf93c2a76a75e2936">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a98f97d88359efe4cf93c2a76a75e2936">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#ac65a1843a0eba6604a1cdf8ffe64f347">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#af553185c6c5af00ddf61bfaeb84609d7">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a4661ceb0b16b992beeb6e039af0e3964">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#a19a6f44964b671c4fb1b72ce01c9d12f">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="class_async_test_dummy_1_1_accessor.html#a28703f60adb4f23594977b7f11ceec81">AsyncTestDummy::Accessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad2e1fa9b9d530997644bcd3a7bd20ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; ChimeraTK::TransferElement::getHighLevelImplElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>For TransferElements which are itself an implementation this will directly return a shared pointer to this. If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is a user frontend, the pointer to the internal implementation is returned.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00394">394</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a175db832ed1ef931143c16d72461616a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a> ChimeraTK::TransferElement::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain unique ID for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>, see <a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">TransferElementID</a> for details. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00428">428</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a513e099c5ca8a011c59611a17d176719"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::list&lt; boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; &gt; ChimeraTK::TransferElement::getInternalElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>The function is recursive, i.e. elements used by the elements returned by this function are also added to the list. It is guaranteed that the directly used elements are first in the list and the result from recursion is appended to the list.</p>
<p>Example: A decorator would return a list with its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> followed by the result of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a513e099c5ca8a011c59611a17d176719" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a> called on its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.</p>
<p>If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is not using any other element, it should return an empty vector. Thus those elements which return a list just containing themselves in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a40240c8934daf47b9759c5dff3ced91b" title="Obtain the underlying TransferElements with actual hardware access. ">getHardwareAccessingElements()</a> will return an empty list here in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a513e099c5ca8a011c59611a17d176719" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a>.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implemented in <a class="el" href="struct_counting_decorator.html#a0345f1fda3a5b9274f8df36b14d83937">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a62a8e4fc66c10d3b0670ce68c352d516">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a7d229b2bf9beb8c7e02b7685a1457742">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a72ef0ebc001b7f789ea0d1fcd0dad548">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a61df2f48a0e4931139d7343be6791522">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a61df2f48a0e4931139d7343be6791522">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a61df2f48a0e4931139d7343be6791522">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a2158025b4a6774de59445d7e60f91d6a">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a4b785526643beb84c20d9e9f6b1fd425">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#adfb25685e5e879990164f7cc22926840">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#a0154127b0675dc52288bc3b55cb2dade">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="class_async_test_dummy_1_1_accessor.html#ad806595d720e9563e97070becad4bde9">AsyncTestDummy::Accessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a982337d1951826bb7805f52eaf360793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ChimeraTK::TransferElement::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name that identifies the process variable. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00065">65</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff50f318e05a14f70b178e4435be4ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ChimeraTK::TransferElement::getUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the engineering unit. </p>
<p>If none was specified, it will default to "n./a." </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00070">70</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3294a87f9047329f289dce49edb09db2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::type_info&amp; ChimeraTK::TransferElement::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#ad343535562496cac958357871793d2af">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a5a84f98918e4b1d9ffd3a4db3fbb2365">ChimeraTK::NDRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a5a84f98918e4b1d9ffd3a4db3fbb2365">ChimeraTK::NDRegisterAccessor&lt; T &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a5a84f98918e4b1d9ffd3a4db3fbb2365">ChimeraTK::NDRegisterAccessor&lt; TargetUserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa45ffbd50d1903b1ae425d68a2044b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> ChimeraTK::TransferElement::getVersionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version number that is associated with the last transfer (i.e. </p>
<p>last read or write). See <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">ChimeraTK::VersionNumber</a> for details. The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">VersionNumber</a> object also allows to determine the time stamp. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>FIXME Default implementation is wrong! There should be no default implementation, since the version number must be obtained in the last transfer! </dd></dl>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00204">204</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="af92b78c177bc98923a78a0d4faaf9e05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::interrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel any pending transfer and throw boost::thread_interrupted in its postRead. </p>
<p>This function can be used to shutdown a thread waiting on the transfer to complete (which might never happen due to the sending part of the application already shut down).</p>
<p>Note: there is no guarantee that the exception is actually thrown if no transfer is currently running or if the transfer completes while this function is called. Also for transfer elements which never block for an extended period of time this function may just do nothing. To really shut down the receiving thread, a interrupt request should be sent to the thread and boost::this_thread::interruption_point() shall be called after each transfer. </p>

<p>Reimplemented in <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl_3_01_user_type_00_01_user_type_01_4.html#ab58b6b856de116747497079a972b2f6a">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#a8af918a2254eedee6c801bbc2a1cfab1">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#a8af918a2254eedee6c801bbc2a1cfab1">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; TargetUserType, TargetUserType &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1detail_1_1_n_d_register_accessor_decorator_impl.html#a8af918a2254eedee6c801bbc2a1cfab1">ChimeraTK::detail::NDRegisterAccessorDecoratorImpl&lt; T, T &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00441">441</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9045dd72e498456e821811ef551b9946"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946" title="Check if transfer element is readable. ">isReadable()</a> is not true. </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a45aea3acc98c9446cf5fea0a5eca5c71">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a988485c8c10714cb990c98c49d1b1dcd">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a988485c8c10714cb990c98c49d1b1dcd">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a988485c8c10714cb990c98c49d1b1dcd">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#ab8f8df261884fd06fce0a8f1e506b267">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a1382ed522ecbecd4510de9f0c440921a">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#ad14b919209b8e0fbf04f616e27dc4320">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#af009357d3fa34665a09b4ebbf10c0012">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a98e2f35c06ed2e9de9a6ea9df581d039">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#aad320bc61778bee56737409eaebd1cb6">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#af3065bc46ec087c9b1fe4684f0c77e99">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afb77cfdfd4be6fbf76f16d9ada9d2134"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a9bdd1e03ca23a33865365bd5b3e2e042">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#ab33f87c48179e5c134991d8874471b24">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#ab33f87c48179e5c134991d8874471b24">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#ab33f87c48179e5c134991d8874471b24">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#aa03e019422f7a082f7614e672830c590">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#aa2ace4fb9d36a159599516eb177f0592">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a2e0e586818f45ffabeb8cfd9e0c83dd5">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#ab25e1f836da06b9e1d393331cb5f9a98">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a10c46943f9feb3e9488dc1ae35999c3b">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a10e01c9b8758029501ba16fe2ad00609">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#a987eec34956cfd09184be38b19b52923">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html#a762babb29356600d740f549482d50c68">ChimeraTK::CopyRegisterDecorator&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="accfe1aea9752501fd25381d3e3bdbee8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8" title="Check if transfer element is writeable. ">isWriteable()</a> is not true. </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a0e282427edb4ffcbb5ffbf582328d894">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#aecf37cd79f233aade89f616d9f236ff8">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#aecf37cd79f233aade89f616d9f236ff8">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#aecf37cd79f233aade89f616d9f236ff8">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a984adf0f9474550e5daeb4502aea5c33">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a452913af7691013c7fb2294eb3fa71f5">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#ae94d80239e06bac5719701ccabf61d61">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_multiplexed_data_accessor.html#a9274082f4cf4ad850b1331b990fb61df">ChimeraTK::MultiplexedDataAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a87b22761e0bba2539a4ddf3bdd85ea9d">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_async_test_dummy_1_1_accessor.html#a2d8e952c872e13cc1b1b04b932a750d5">AsyncTestDummy::Accessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#a759f2c8cb842adcc03178cfeb1122788">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html#af5b3281ababd53a5567e284517bf6007">ChimeraTK::CopyRegisterDecorator&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9848d53a7e57619f8322a8ba3dcf5614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; ChimeraTK::TransferElement::makeCopyRegisterDecorator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html" title="Decorator for NDRegisterAccessors which makes a copy of the data from the target accessor. ">CopyRegisterDecorator</a> of the right type decorating this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>This is used by <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a19754dfcd367d6b178e782d3fc490a85" title="Search for all underlying TransferElements which are considered identicel (see mayReplaceOther()) wit...">TransferElementAbstractor::replaceTransferElement()</a> to decouple two accessors which are replaced on the abstractor level. </p>

<p>Implemented in <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a219fae3b02a64aa355e55f891837b218">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#add81fefa0d27a7844637a7a6f4e79104">ChimeraTK::NDRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#add81fefa0d27a7844637a7a6f4e79104">ChimeraTK::NDRegisterAccessor&lt; T &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#add81fefa0d27a7844637a7a6f4e79104">ChimeraTK::NDRegisterAccessor&lt; TargetUserType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a833c655eca8c53f5ff0d97c3d81c1376"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElement::makeUniqueId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow generating a unique ID from derived classes. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00458">458</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b9b2f94e5064726b3a93232b3e44207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ChimeraTK::TransferElement::mayReplaceOther </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> can be used in places where the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> "other" is currently used, e.g. </p>
<p>to merge the two transfers. This function must be used in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> by implementations which use other TransferElements, to determine if a used <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> shall be replaced with the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> "other".</p>
<p>The purpose of this function is not to determine if at any point in the hierarchy an replacement could be done. This function only works on a single level. It is not used by the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> to determine <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> whether shall be used (it is always called). Instead this function can be used by decorators etc. inside their implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> to determine if they might swap their implementation(s).</p>
<p>Note for decorators and similar implementations: This function must not be decorated. It should only return true if this should actually be replaced with other in the call to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identicel (see sameRegister()) with t...">replaceTransferElement()</a> one level up in the hierarchy. If the replacement should be done further down in the hierarchy, simply return false. It should only return if other is fully identical to this (i.e. behaves identical in all situations but might be another instance). </p>

<p>Reimplemented in <a class="el" href="struct_counting_decorator.html#ad8459c3d0c5556f9bdf888ce046648d2">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#ac0731e48c48bc320e0ca26e718f8a101">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#adf79b759ccf91309e4fe93d9a6f3177f">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a402b08d171f384db090878e94ae21a2a">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a72756556a3ef3cf9475a1ed0a9268d08">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a075726d744c91c576842512de8a5ea5b">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#aae52da815c8c3e6e8bd11dca0cce9cfc">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00357">357</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a03fec2fb2b11be04d6ecad5bdd97d116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&amp; ChimeraTK::TransferElement::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a40a803da60e750f4f734fb7dee3d18a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&amp; ChimeraTK::TransferElement::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19a9f486a967295eacca7f3f78d025bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElement::postRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed. </p>
<p>Called by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a> etc. Also the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> will call this function after a read was executed directly on the underlying accessor. This function must be implemented to extract the read data from the underlying accessor and expose it to the user. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00274">274</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae92f7bd2db9827c3db3c1ff0e29ab581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElement::postWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any post-write cleanups if necessary. </p>
<p>If during <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> e.g. the user data buffer was swapped away, it must be swapped back in this function so the just sent data is available again to the calling program.</p>
<p>Called by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device. ">write()</a>. Also the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> will call this function after a write was executed directly on the underlying accessor. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00320">320</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a68fee71a4c9407193fa021c44aca9f5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElement::preRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any pre-read tasks if necessary. </p>
<p>Called by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a> etc. Also the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> will call this function before a read is executed directly on the underlying accessor. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00256">256</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2bbf89e74a5db146db0992dfa6c48554"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElement::preWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed. </p>
<p>Called by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device. ">write()</a>. Also the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> will call this function before a write will be executed directly on the underlying accessor. This function implemented be used to transfer the data to be written into the underlying accessor. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00302">302</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa21ae3855a6df0e877865702df066f5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElement::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00089">89</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad00999178a215bc11d9c1377c6427c23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&amp; ChimeraTK::TransferElement::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElement::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00170">170</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9488e50bea018025dd4b061afdf2f52b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00133">133</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5dce57ab971b6fc68bc13fbd00401c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00113">113</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a791a4902b649e859fbadea20cc90ede2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect. </p>

<p>Reimplemented in <a class="el" href="struct_counting_decorator.html#ad1477b27e867834befafef368047f651">CountingDecorator&lt; T &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html#a11c8f00fb0b45379c3bde8c48e153fd9">ChimeraTK::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_bit_accessor.html#a4439853c000269dd3e862e8713263be0">ChimeraTK::LNMBackendBitAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_low_level_transfer_element.html#a37713b9281070f2fb1a1ea72868c2aff">ChimeraTK::NumericAddressedLowLevelTransferElement</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_variable_accessor.html#a6539b6ca4b91c3a1aab9b31547b84b87">ChimeraTK::LNMBackendVariableAccessor&lt; UserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_l_n_m_backend_channel_accessor.html#a1a5dbcabd62608869c651225d3e94e4a">ChimeraTK::LNMBackendChannelAccessor&lt; UserType &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_muxed_register_accessor.html#afb35bdda934d74b34aa2a50e92f4f829">ChimeraTK::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00403">403</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a70d4c154c564848bfb6b08992cdf7059"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::setPersistentDataStorage </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate a persistent data storage object to be updated on each write operation of this ProcessArray. </p>
<p>If no persistent data storage as associated previously, the value from the persistent storage is read and send to the receiver.</p>
<p>Note: A call to this function will be ignored, if the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> does not support persistent data storage (e.g. read-only variables or device registers)</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000068">Todo:</a></b></dt><dd>TODO does this make sense? </dd></dl>

<p>Reimplemented in <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a4eee9c9221bf2ac861f1d734ae447a84">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a4eee9c9221bf2ac861f1d734ae447a84">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a4eee9c9221bf2ac861f1d734ae447a84">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00423">423</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa51a59d6d5eee3de298f1b3449bb29e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChimeraTK::TransferElement::transferFutureWaitCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function called by the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> before entering a potentially blocking wait(). </p>
<p>In contrast to a wait callback of a boost::future/promise, this function is not called when just checking whether the result is ready or not. Usually it is not necessary to implement this function, but decorators should pass it on. One use case is the ApplicationCore TestDecoratorRegisterAccessor, which needs to be informed before blocking the thread execution. Note: The <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers...">ReadAnyGroup</a> will trigger a call to this function of the first <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> in the group before potentially blocking. </p>

<p>Reimplemented in <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a69f550bb9961ccf7f643ba963e3c6f28">ChimeraTK::NDRegisterAccessorDecorator&lt; UserType, TargetUserType &gt;</a>, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a69f550bb9961ccf7f643ba963e3c6f28">ChimeraTK::NDRegisterAccessorDecorator&lt; T &gt;</a>, and <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html#a69f550bb9961ccf7f643ba963e3c6f28">ChimeraTK::NDRegisterAccessorDecorator&lt; TargetUserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00294">294</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a9be48fa8f5cab72e62ce20d99004b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00185">185</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aba6cb788c9f76a35a66d7b6266e94c70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00466">466</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5bdf5501b097a054a0be0bd5c8332ef3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_chimera_t_k_1_1_transfer_group.html">TransferGroup</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00465">465</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a66f52cb447c14f6e01f716c3d040238e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ChimeraTK::TransferElement::_description</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Description of this variable/register. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00452">452</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1a42fc668a7d9243dd024729737f35a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a> ChimeraTK::TransferElement::_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ID of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00455">455</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13235d15a13bfc43764e464f1b6fe50d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ChimeraTK::TransferElement::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifier uniquely identifying the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00446">446</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fffb069722f43530cecbcaa40b7c670"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ChimeraTK::TransferElement::_unit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Engineering unit. </p>
<p>Defaults to "n./a.", if none was specified </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00449">449</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="af60ec6ab982e620f5bfdc3b5bbed9928"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> ChimeraTK::TransferElement::activeFuture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>last future returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afe0ba112ccb6eb9e556710d1151c1602" title="Start the actual asynchronous read transfer. ">doReadTransferAsync()</a> (valid if hasActiveFuture == true) </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00482">482</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae38d4de78e82adea96f87d98ef828ad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::hasActiveFuture {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag whether there is a valid activeFuture or not. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00479">479</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5fafaaed44dd2c55bcd8a24a99e3e86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::isInTransferGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag whether this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00463">463</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5e0da1696dcfda8b285a818e6555f2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::readTransactionInProgress {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag whether a read transaction is in progress. </p>
<p>This flag will be set in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a68fee71a4c9407193fa021c44aca9f5d" title="Perform any pre-read tasks if necessary. ">preRead()</a> and cleared in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a19a9f486a967295eacca7f3f78d025bb" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> and is used to prevent multiple calls to these functions during a single transfer. It should also be reset before starting a new read transaction - this happens only inside the implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device. ">read()</a> etc. and in the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00472">472</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="af4c7678155e4598ca95a4f900b9dfced"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char ChimeraTK::TransferElement::unitNotSet = &quot;n./a.&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant string to be used as a unit when the unit is not provided or known. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00413">413</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed11ca7a5de19b71ce48c00a13ad9a6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElement::writeTransactionInProgress {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag whether a write transaction is in progress. </p>
<p>This flag is similar to readTransactionInProgress but affects <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a2bbf89e74a5db146db0992dfa6c48554" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae92f7bd2db9827c3db3c1ff0e29ab581" title="Perform any post-write cleanups if necessary. ">postWrite()</a>. </p>

<p>Definition at line <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html#l00476">476</a> of file <a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device_backends/include/<a class="el" href="device__backends_2include_2_transfer_element_8h_source.html">TransferElement.h</a></li>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device/src/<a class="el" href="_transfer_element_8cc_source.html">TransferElement.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 18 2018 07:53:14 for ChimeraTK-DeviceAccess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
