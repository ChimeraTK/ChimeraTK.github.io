<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: doc/spec_initialValuePropagation.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec__initial_value_propagation_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/spec_initialValuePropagation.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="spec__initial_value_propagation_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Technical specification: propagation of initial values {#spec_initialValuePropagation}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;======================================================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&gt; **DRAFT VERSION, WRITE-UP IN PROGRESS!**</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;## Introduction ##</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;This document describes how initial values are propagated from the control system persistency layer, from the devices and from application modules into the attached components (control system, devices and other application modules).</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;This specification goes beyond ApplicationCore. It has impact on other ChimeraTK libraries like DeviceAccess, the ControlSystemAdapter and even backends and adapter implementations.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;## Definitions ##</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;- Initial value: The start value of a process variable. The value is available to the receiving end of the process variable at a well defined point in time at the start. This is a logical concept. It is to be distinguished from the (often hardcoded) &quot;value after construction&quot; of the `ChimeraTK::ProcessArray` or any other `ChimeraTK::NDRegisterAccessor` implementation. The point in time when the value becomes available is well-defined, as described in the high-level requirements.</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;## High-level requirements ##</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;- Initial values must be available to all `ChimeraTK::ApplicationModule`s at the start of the `ChimeraTK::ApplicationModule::mainLoop()`. No call to `ChimeraTK::TransferElement::read()` etc. is required. This implies that the `ChimeraTK::ApplicationModule::mainLoop()` is not started until all initial values are available, including those coming from devices which might potentially be offline, or from other `ApplicationModule`s.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;- `ChimeraTK::ApplicationModule` implementations can either provide initial values for their outputs in `ChimeraTK::ApplicationModule::prepare()` (if the initial value doesn&#39;t depend on any inputs) or right after the start of the `ChimeraTK::ApplicationModule::mainLoop()` (if the initial value needs to be computed from the incoming initial values of the inputs).</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;- Since `ChimeraTK::ApplicationModule`s might wait for initial values from other `ChimeraTK::ApplicationModule`s, the modules might end up in a dead lock due to a circular connection. The circular connection is legal, but the dead lock situation needs to be broken by one `ChimeraTK::ApplicationModule` writing its initial value during `ChimeraTK::ApplicationModule::prepare()`.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;- Devices must receive the initial values as soon as possible after the device is opened and after the initialisation sequence is executed. There is no guarantee that other registers of the same device are written or read only after the initial values are written. Hence, any critical registers that need to be written before accessing other registers must be written in the initialisation sequence.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;- The control system doesn&#39;t receive &quot;initial values&quot; as such. The first value of a process variable is sent to the control system when available. This may depend even on external conditions like the availability of devices, e.g. the control system interface has to run even if devices are not available and hence cannot send an inital value.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;- Control system variables show the `ChimeraTK::DataValidity::faulty` flag until they have received the first valid value.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;- For push-type variables from devices, the initial value is the current value polled at the application start. Since the variable might not get pushed regularly, the application must not wait for a value to get pushed.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;## Detailed requirements ##</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;1. All `ChimeraTK::NDRegisterAccessor` implementations (including but not limited to the `ChimeraTK::ProcessArray`) must have the `ChimeraTK::DataValidity::faulty` flag set after construction for the receiving end. This ensures, all data is marked as `faulty` as long as no sensible initial values have been propagated. The sending end must have `ChimeraTK::DataValidity::ok` after construction, so that the first written data automatically propagates the ok state by default. For bidirectional variables, this must be the case for both directions separately.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;2. All `ChimeraTK::NDRegisterAccessor` implementations must have initially a `ChimeraTK::VersionNumber` constructed with a `nullptr`, which allows to check whether this variable is still at its &quot;value after construction&quot;, or the initial value propagation already took place.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;3. `ChimeraTK::ApplicationModule` (and `ChimeraTK::ThreadedFanOut`/`ChimeraTK::TriggerFanOut`) propagate the `ChimeraTK::DataValidity` of its outputs according to the state of all inputs. This behaviour is identical to later during normal data processing.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;4. The &quot;value after construction&quot; must not be propagated automatically during initial value propagation, not even with the `ChimeraTK::DataValidity::faulty` flag set. It must not be visible to user code in the `ChimeraTK::ApplicationModule::mainLoop()`.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;5. Control system variables:</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  1. Variables with the control-system-to-application direction must be written exactly once at application start by the control system adapter with their initial values from the persistency layer. This must be done before `ChimeraTK::ApplicationBase::run()` is called. If the persistency layer can persist the `ChimeraTK::DataValidity`, the initial value should have the correct validity. Otherwise, initial values will always have the `ChimeraTK::DataValidity::ok`.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  2. Variables with the application-to-control-system direction do not have an &quot;initial value&quot;. The first value of these variables are written at an undefined time after the `ChimeraTK::ApplicationBase::run()` has been called. The control system adapter must not expect any specific behaviour. Entities writing to these variables do not need to take any special precautions.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;6. Device variables:</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  1. Write accessors need to be written right after the device is opened and the initialisation is done, as soon as the initial value is available for that variable. Initial values can be present through 5.a, 6.b or 7.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  2. Initial values for read accessors must be read after the device is openend and the initialsation is done. The read is performed with `ChimeraTK::TransferElement::readLatest()`.</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;7. Outputs of `ChimeraTK::ApplicationModule`s:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  1. Initial values can be written in `ChimeraTK::ApplicationModule::prepare()`, if the value does not depend on any input values (since input values are not available during `prepare()`).</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  2. Alternatively, initial values can be written in `ChimeraTK::ApplicationModule::mainLoop()` before calling any `read` function. Typically, to propagate the initial values of its inputs, an `ApplicationModule` will run its computations and write its outputs first before waiting for new data with a blocking `read()` and the end of the processing loop.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  3. Since in `ChimeraTK::ApplicationModule::prepare()` all devices are still closed, any writes to device variables at this point need to be delayed until the device is open. The actual write is hence performed by the DeviceModule.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  4. An output of a `ChimeraTK::ApplicationModule` with an initial value written in `ChimeraTK::ApplicationModule::prepare()` and later never written again behaves in the same way as a constant (see 10.).</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;8. Inputs of `ChimeraTK::ApplicationModule`s:</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  1. Initial values are read before the start of `ChimeraTK::ApplicationModule::mainLoop()` (but already in the same thread which later executes the `mainLoop()`).</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  2. It depends on the data source type (i.e. the type of the feeder of the VariableNetwork) whether a blocking `read()` or non-blocking `readLatest()` needs to be used for the initial value:</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    1. *control system variable*: `ChimeraTK::TransferElement::read()`</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    2. *device register without trigger*: `ChimeraTK::TransferElement::readLatest()` (even if register is push-type). Special treatment required to block until the device is accessible.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    3. *poll-type device register with trigger (incl. `ChimeraTK::VariableNetwork::TriggerType::pollingConsumer`)*: `ChimeraTK::TransferElement::read()`</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    4. *constant*: `ChimeraTK::TransferElement::readLatest()`</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    5. *application*: `ChimeraTK::TransferElement::read()`</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;9. `ChimeraTK::ThreadedFanOut` and `ChimeraTK::TriggerFanOut` etc. (does not apply to decorator-like fan outs `ChimeraTK::FeedingFanOut` and `ChimeraTK::ConsumingFanOut` etc.)</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  1. The FanOuts should have a transparent behaviour, i.e. an entity that receives an initial value through a FanOut should see the same behaviour as if a direct connection would have been realised.</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  2. This implies that the inputs need to treated like described in 8.b.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  3. The initial value is propagated immediately to the outputs.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  4. If an output cannot be written at that point (because it writes to a device currently being unavailable), the value propagation to other targets must not be blocked. See recovery mechanism described in @ref exceptionHandlingDesign.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;10. Constants (`ChimeraTK::Application::makeConstant()`):</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  1. Values are propagated before the `ChimeraTK::ApplicationModule` threads are starting (just like initial values written in `ChimeraTK::ApplicationModule::prepare()`, see 7.d).</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  2. Special treatment for constants written to devices: They need to be written after the device is opened (see 6.a), with the same mechanism as in 7.c.</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;11. Variables with a return channel (&quot;bidirectional variables&quot;, `ChimeraTK::ScalarPushInputWB`, `ChimeraTK::ScalarOutputPushRB` and the array variants) behave like their unidirectional pendants, i.e. the existence of the return channel is ignored during the initial value propagation.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;### Comments ###</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;- To 4.: It is very important that no wrong data is transported initially. Since the &quot;value after construction&quot; of all process variables is always 0 or so, this value is basically always wrong. If it gets propagated within the application, modules will process this value (usually even if `ChimeraTK::DataValidity::faulty` is set), despite the value might present an inconsistent state with other process variables. If it gets propagated to the control system, other applications might act on an again inconsistent state.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;- To 5.: This is the responsibility of each control system adpater implementation.</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;- To 8.b: The decision whether to use blocking or non-blocking read for the initial transfer has the following reasons:</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  - 8.b.i.: Blocking reads prevent race condtion especially in cases where a ThreadedFanOut is involved.</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  - 8.b.ii.: `ChimeraTK::TransferElement::readLatest()` fetches current value instead of waiting for a new value - see high-level requirements.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  - 8.b.iii.: Blocking reads prevent race condtion.</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  - 8.b.iv.: Blocking reads on constants never return, hence the non-blocking read.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  - 8.b.v.: Blocking read required in case the sender writes the initial value during `ChimeraTK::ApplicationModule::mainLoop()`.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;## Implementation ##</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;### NDRegisterAccessor implementations ###</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;- 1. must currently be implemented by each `ChimeraTK::NDRegisterAccessor` separately. [TBD: Instead of requiring all implementations to be changed, we could also fix this in `ChimeraTK::Application::createDeviceVariable()`, but this creates an asymetry to the `ProcessArray`...]</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;- 2. must currently be implemented by each `ChimeraTK::NDRegisterAccessor` separately. All accessors should already have a `ChimeraTK::VersionNumber` data member called `currentVersion` or similar, it simply needs to be constructed with a `nullptr` as an argument.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;- The `ChimeraTK::UnidirectionalProcessArray` uses always a default start value of `DataValidity::ok`, but overwrites this with `DataValidity::faulty` for the receivers in the factory function `ChimeraTK::UnidirectionalProcessArray::createSynchronizedProcessArray()` (both implementations, see UnidirectionalProcessArray.h).</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;### ApplicationModule ###</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;- Needs to implement 3:</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  - `ChimeraTK::ApplicationModule::getDataValidity()` returns `ok` if the `faultCounter` is 0, `faulty` otherwise</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  - Hence fault counter starts with 0.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;- API documentation must contain 7</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;- Needs to implement 8 via `ChimeraTK::VariableNetworkNode::hasInitialValue()`</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;### ThreadedFanOut ###</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;- Needs to implement 3.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  - Currently just passing on the validity from the input.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  - This is probably going to change when the correct propagation of the validity flag is implemented.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;- Needs to implement 6.a abd 6.b, realised via `ChimeraTK::VariableNetworkNode::hasInitialValue()`</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;- Needs to implement 9:</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  - 9.a via `ChimeraTK::VariableNetworkNode::hasInitialValue()` -&gt; already covered with the previous point</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  - 9.b covered by the `ChimeraTK::ExceptionHandlingDecorator`</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  - 9.c requires no special precautions</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;### TriggerFanOut ###</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;- Needs to implement 3.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;- Needs to implement 6.a and 6.b, realised via `ChimeraTK::VariableNetworkNode::hasInitialValue()`</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;- Needs to implement 9:</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  - 9.a via `ChimeraTK::VariableNetworkNode::hasInitialValue()` -&gt; already covered with the previous point</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  - 9.b **not** covered by the `ChimeraTK::ExceptionHandlingDecorator` here (as the decorator is not effective with `ChimeraTK::TransferGroup`s), needs to be properly implemented</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  - 9.c requires no special precautions</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;### DeviceModule ###</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;- Needs to implement parts of 6.a:</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  - `ChimeraTK::DeviceModule::writeAfterOpen` is a list of accessors to be written after the device is opened for the first time</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  - The `ChimeraTK::ExceptionHandlingDecorator` will fill the list when necessary, see 7.c</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;- Needs to take care of 6.b partially:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  - Initial values are being read from the device by other entities, but these must be blocked until the DeviceModule wakes them up.</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  - This wake up must take place after initialisation and 6.a is complete</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;- Needs to implement 10.b, done through `ChimeraTK::DeviceModule::writeAfterOpen` -&gt; already covered by previous point.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;### ExceptionHandlingDecorator ###</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;- Needs to implement parts of 6.a:</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  - When a write happens while the application&#39;s `LifeCycleState` is not yet `run`, it must not block, because the device will not be openend, see 7.c</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  - Instead the recoveryAccessor is added to the `ChimeraTK::DeviceModule::writeAfterOpen` list</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;### VariableNetworkNode ###</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;- Implements the decision tree mentioned in 8.b in `VChimeraTK::ariableNetworkNode::hasInitialValue()`</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;### Application ###</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;(This section refers to the class `ChimeraTK::Application`, not to the user-defined application.)</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;- Need to implement 7.b:</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  - In `ChimeraTK::Application::run()`, after the calls to `ChimeraTK::ApplicationModule::prepare()` all module outputs are checked</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  - If a variable has been written during `ChimeraTK::ApplicationModule::prepare()`, the hasInitialValue flag is set in the corresponding `VariableNetworkNode`.</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  - The VersionNumber is used to determine if a variable has been written or not (cf. 2.)</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;## Known bugs ##</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;### NDRegisterAccessor implementations ###</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;- 1. is not implemented for Device implementations (only the `UnidirectionalProcessArray` is correct at the moment).</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;- 2. is not implemented for Device implementations (only the `UnidirectionalProcessArray` is correct at the moment).</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;### ExceptionHandlingDecorator ###</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;- It waits until the device is opened, but not until after the initialisation is done.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;### Documentation ###</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;- Documentation of ControlSystemAdapter should mention that implementations must take care about 5.</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;- Documentation for ApplicationModule should mention 7.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="spec__initial_value_propagation_8md.html">spec_initialValuePropagation.md</a></li>
    <li class="footer">Generated on Wed Mar 4 2020 04:53:40 for ChimeraTK-ApplicationCore by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
