<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: doc/spec_TransferElement.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec___transfer_element_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/spec_TransferElement.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="spec___transfer_element_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Technical specification: TransferElement {#spec_TransferElement}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;========================================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&gt; **DRAFT VERSION, WRITE-UP IN PROGRESS!**</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;## Introduction ##</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;This documnent is currently still **INCOMPLETE**!</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;## A. Definitions ##</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* 1. A &lt;i&gt;process variable&lt;/i&gt; is the logical entity which is accessed through the TransferElement. Outside this document, it is sometimes also called register.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  * 1.1 A process variable can be read-only, write-only or read-write (bidirectional).</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  * 1.2 A process variable has a data type.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  * 1.3 A process variable has a fixed &lt;i&gt;number of elements&lt;/i&gt; and a &lt;i&gt;number of channels&lt;/i&gt;.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    * 1.3.1 For scalars, both the number of elements and channels are 1.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    * 1.3.2 For 1D arrays, the number of channels is 1.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;* 2. A &lt;i&gt;device&lt;/i&gt; is the logical entity which owns the &lt;i&gt;process variable&lt;/i&gt;. The device can be a piece of hardware, another application or even the current application.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  * 2.1 The first two cases (piece of hardware and another application) are considered identical, since just different &lt;i&gt;backends&lt;/i&gt; are used for the communication.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  * 2.2 The third case (current application) is when using the ChimeraTK::ControlSystemAdapter::ProcessArray e.g. in ApplicationCore.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  * 2.3 The application-side behavior of all three cases is identical. The requirements for the implementation are slightly different in some aspects. This will be mentioned where applicable.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;* 3. A &lt;i&gt;transfer&lt;/i&gt; is the exchange of data between the application and the device, using a transfer protocol which determines the technical implementation. The protocol used for the transfer is determined by the backend and hence all details about the protocol are abstracted and not visible by the application.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;* 4. An &lt;i&gt;operation&lt;/i&gt; is the action taken by the application to read or write data from or to a device. An operation is related to a transfer, yet it is to be distinguished. The transfer can e.g. be initiated by the device, while the operation is always initiated by the application.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;* 5. The &lt;i&gt;application buffer&lt;/i&gt; (sometimes also called user buffer outside this document) is referring to the buffer containing the data and meta data, which is accessible to the application.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  * 5.1 It can be accessed through the following functions:</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    * ChimeraTK::NDRegisterAccessor::accessData() / ChimeraTK::NDRegisterAccessor::accessChannel()</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    * ChimeraTK::TransferElement::getVersionNumber()</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    * ChimeraTK::TransferElement::dataValidity()</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  * 5.2 If not stated otherwise, the term &lt;i&gt;application buffer&lt;/i&gt; refers to **all** components of the buffer.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  * 5.3 The content of the buffer is filled with data from the device in read operations, and transferred to the device in write operations.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  * 5.4 The content of the buffer can always be modified by the application.(*)</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;* 6. Placeholders are used to summarise various function names:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  * 6.1 xxxYyy(), public, operations called by the application</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    * ChimeraTK::TransferElement::read()</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    * ChimeraTK::TransferElement::readNonBlocking()</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    * ChimeraTK::TransferElement::readLatest()</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    * ChimeraTK::TransferElement::write()</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    * ChimeraTK::TransferElement::writeDestructively()</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  * 6.2 preXxx(), private</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    * ChimeraTK::TransferElement::preRead()</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    * ChimeraTK::TransferElement::preWrite()</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  * 6.3 doPreXxx(), virtual</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    * ChimeraTK::TransferElement::doPreRead()</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    * ChimeraTK::TransferElement::doPreWrite()</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  * 6.4 xxxTransferYyy(), private</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    * ChimeraTK::TransferElement::readTransfer()</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    * ChimeraTK::TransferElement::readTransferNonBlocking()</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    * ChimeraTK::TransferElement::writeTransfer()</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    * ChimeraTK::TransferElement::writeTransferDestructively()</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  * 6.5 doXxxTransferYyy()</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    * ChimeraTK::TransferElement::doReadTransferSynchonously(), pure virtual (*)</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    * ChimeraTK::TransferElement::doWriteTransfer(), pure virtual</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    * ChimeraTK::TransferElement::doWriteTransferDestructively(), virtual</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  * 6.6 postXxx(), private</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    * ChimeraTK::TransferElement::postRead()</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    * ChimeraTK::TransferElement::postWrite()</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  * 6.7 doPostXxx(), virtual</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    * ChimeraTK::TransferElement::doPostRead()</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    * ChimeraTK::TransferElement::doPostWrite()</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;   </div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;* 7. Private and virtual functions</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  * 7.1 The private functions preXxx(), xxxTransferYyy(), and postXxx() implement common, decorating functionality like exception handling in the TransferElement base class</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  * 7.2 They internally call their virtual counterparts which start with &#39;do&#39;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  * 7.3 The virtual do-functions are the actual implementations of the transfer or pre/post action, which are specific for each backend, decorator etc.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;### (*) Comments ###</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;* 5.4 The buffer is accessed by the read/write operatons and must not be changed at this time. As transfer elements are not thread safe (B.1) this means the application will either perform an operation or otherwise change the buffer ad libitum.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;* 6.5 doReadTransferSynchonously() is currently called doReadTransfer(). This should be renamed.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;## B. Behavioural specification ##</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;* 1. TransferElements are not thread safe</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;* 2. Data types [TODO]</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;* 3. Modes of transfers</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  * 3.1 Read operations:</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    * 3.1.1 The flag ChimeraTK::AccessMode::wait_for_new_data determines whether the transfer is initiated by the device side (flag is set) or not.</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    * 3.1.2 If ChimeraTK::AccessMode::wait_for_new_data is not set, read operations</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      * 3.1.2.1 obtain the &lt;i&gt;current&lt;/i&gt; value of the process variable (if possible/applicable by synchronously communicating with the device),</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      * 3.1.2.2 have no information whether the value has changed,</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      * 3.1.2.3 behave identical whether read(), readNonBlocking() or readLatest() is called,</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      * 3.1.2.4 readNonBlocking() and readLatest() always return true.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    * 3.1.3 If ChimeraTK::AccessMode::wait_for_new_data is set</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      * 3.1.3.1 read() blocks until new data has arrived,</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      * 3.1.3.2 readNonBlocking() does not block and instead returns whether new data has arrived or not,</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    * 3.1.4 readLatest() is merely a convenience function which calls readNonBlocking() until no more new data is available.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      </div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  * 3.2 Write operations</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    * 3.2.1 do not distingish on which end the transfer is initiated. The API allows for application-initiated transfers and is compatible with device-initiated transfers as well.</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      * 3.2.1.2 It is guaranteed that the application buffer is still intact after calling TransferElement::write().</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    * 3.2.2 can optionally be &quot;destructively&quot;, which allows the implementation to destroy content of the application buffer in the process.</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      * 3.2.2.1 Applications can allow this optimisation by using writeDestructively() instead of write().</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      * 3.2.2.2 The optimisation is still optional, backends are allowed to not make use of it. In this case, the content of the application buffer will be intact after writeDestructively(). Applications still are not allowed to use the content of the application buffer after writeDestructively().</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;* 4. Stages of an operation initiated by calling the public high level functions xxxYyy() (see. A.6.1)</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  * 4.1 preXxx(): calls doPreXxx() of the implementation to allow preparatory work before the actual transfer. doPreXxx() can be empty if nothing is to be done (*)</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  * 4.2 xxxTransferYyy():</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    * 4.2.1 readTransfer()</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      * If wait_for_new_data is set, it waits until new data has been received and returns</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      * If wait_for_new_data is not set, it calls doReadTransferSynchrously()</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    * 4.2.2 readTransferNonBlocking()</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      * If wait_for_new_data is set, it returns immediately with the information whether new data has been received</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;      * If wait_for_new_data is not set, it calls doReadTransferSynchrously() and returns true</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    * 4.2.3 writeTransferYyy() calls the corresonding doWriteTransferYyy()</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    * Transfer implementations do not change the application buffer</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  * 4.3 postXxx(): calls doPostXxx() of the implementation to allow follow-up work after the actual transfer.</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    * 4.3.1 In read transfers doPostRead() is the only place where the application buffer may be changed (*).</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;* 5. preXxx() and postXxx(), resp. doPreXxx() and doPostXxx(), are always called in pairs. (*)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  * 5.1 This holds even if exceptions (both ChimeraTK::logic_error and ChimeraTK::runtime_error, and also boost::thread_interrupted and boost::numeric::bad_numeric_cast) are thrown (see 6).</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  * 5.2 The implementations of preXxx() and postXxx() ignore duplicate calls, such that a call to doPreXxx() is never followed by another call to doPreXxx() before doPostXxx() has been called, and vice versa.</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  </div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;* 6. Exceptions thrown in preXxx() or xxxTransferYyy() are caught and delayed until postXxx() by the framework. This ensures that preXxx() and postXxx() are always called in pairs.</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  * 6.1 If in preXxx() an exception is thrown, the corresponding xxxTransferYyy() is not called, instead directly postXxx() is called.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;* 7. Return values of xxxTransferYyy():</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  * 7.1 readTransferNonBlocking() returns whether new data has been received (see 4.2.2)</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  * 7.2 writeTransfer() and writeTransferDestructively() return whether data has been lost. If it returns true, some data was rejected in the process of the transfer. It can be either the data that should have been written in the current transfer, or some older data was overwritten.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  * 7.3 The return value is passed on to the postXxx() function call (via hasNewData resp. dataLost), to allow the doPostXxx() implementations to decide the right actions.</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  * 7.4 In case of an exception in either preXxx() or xxxTransferYyy(), postXxx() receives instead the information that the transfer didn&#39;t sucessfully take place (hasNewData = false resp. dataLost = true).</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  </div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;* 8. Read operations with AccessMode::wait_for_new_data:</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  * 8.1 Since the transfer is initiated by the device side in this case, the transfer is asynchronous to the read operation.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  * 8.2 The backend fills any received values into a queue, from which the read()/readNonBlocking() operations will obtain the value.</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    * 8.2.1 If the queue is full, the last written value will be overwritten.</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    * 8.2.2 The backend may fill a ChimeraTK::detail::DiscardValueException to the queue, which has the same effect on the application side as if no entry was filled to the queue. (*)</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  * 8.3 Runtime errors like broken connections are reported by the backend by pushing ChimeraTK::runtime_error exceptions into the queue. The exception will then be obtained by the read operation in place of a value.</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  * 8.4 The backend ensures consistency of the value with the device, even if data loss may occur on the transport layer. If necessary, a heartbeat mechanism is implemented to correct any inconsistencies at regular intervals.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  * 8.5 For transfer elements which are created before the device has been opened (or after the device has seen an exception, see 9.) the backend does not fill any</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    data into the queue until the device has successfully been opened and Device::activateAsyncRead() is called (*). Also no runtime_errors are send. We call this *asyncronous read is not activated* for these transfer elements.</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;      * 8.5.1 When Device::activateAsyncRead() is called, it activates asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set (*).</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      * 8.5.2 When asyncronous read is activated in a transfer element, it must get an initial value synchronously and treat it as if it would have been received, i.e. push it to the queue. This must happen after the actual asynchronous sending has been turned on to make sure no update is missed. (*)</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;      * 8.5.3 If a transfer element is created while the device is opened and functional, the asynchronous read is activated automatically (incl. sending of the initial value). This happens even if there are other transfer elements which have the asynchronous read deactivated because they have been created before opening the device and Device::activateAsyncRead() has not been called yet.</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;      * 8.5.4 If Device::activateAsyncRead() is called while the device is not opened or has an error, this call has no effect. If it is called when no deactivated transfer element exists, this call also has no effect.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      * 8.5.5 Device::activateAsyncRead() does not throw any exceptions.</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;* 9. If one transfer element of a device has seen an exception(*), all other transfer elements of the same device must also be aware of this.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;   * 9.1 TransferElements with wait_for_new_data flag</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    * 9.1.1 Each transfer element deactivates asynchronous reads so no further data is pushed into the queue until open() has been called successfully in the backend (*) and Device::activateAsyncRead() has been called</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    * 9.1.2 Exactly one ChimeraTK::runtime_error is pushed into the queue of *each* transfer elements of the backend with wait_for_new_data (*). This must happen after 9.1.1. to avoid race conditions.</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    * 9.1.3 The first data on the queue after the exception is the initial value send when calling Device::activateAsyncRead() (see 8.5.2).</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    * 9.1.4 The backend must maken sure 9.1.2 is finished before a call to Device::activateAsyncRead() re-activates the asynchonous transfers again (*).</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;   * 9.2 TransferElements without wait_for_new_data</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;     * 9.2.1 Each call to doReadTransferSynchonously() will throw a ChimeraTK::runtime error until open() has been called successfully.</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;   * 9.3 Write operations will throw  a ChimeraTK::runtime error in doWriteTrasferYyy() until open() has been called successfully.</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;* 10. TransferGroup</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  * 10.1 TransferGroups are only allowed for TransferElements without AccessMode::wait_for_new_data.</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  *  [TODO]</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;* 11. ReadAnyGroup [TODO]</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;* 12. DataConsistencyGroup [TODO]</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;### (*) Comments ###</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;* 4.1 preXxx() is part of the operation, not of the actual transfer. In case of reads with AccessMode::wait_for_new_data the transfer is asynchonousy initiated by the device and not connected to the operation. Hence backend implementations usually have an empty doPreWrite(), but decorator-like implementations still can use it to execute preparatory tasks.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;* 4.3.1 In write operations the buffer might be swapped out in doPreRead() and swapped back in doPostRead() to restore it for non-destructive read operations to avoid copying of large arrays.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;* 5. Reason: It might be that the user buffer has to be swapped out during the transfer (while taking away the ownership of the calling code), and this must be restored in the postXxx action.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;* 8.2.2 This allows to discard values inside a continuation of a cppext::future_queue. It is used e.g. by the ControlSystemAdapter&#39;s BidirectionalProcessArray. [TBD: It could be replaced by a feature of the cppext::future_queue allowing to reject values in continuations...]</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;* 8.5 Device::open() does not automatically activate the asyncronous sending because the device might need some initalisation setting to produce valid data (for example setting the correct ADC range). By delaing the activation of asyncronous reads the application has the possibility to do the initialisation before the first data is being send, and can avoid invalid initial values on the process variables.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;* 8.5.1 Conceptually activating an asyncronous read is like subscribing a variable, and deactivating it is like unsubscribing a variable in a publish-subscribe pattern. The actual implementation depends on the details of the protocols.</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;* 8.5.2 As the asynchonous mechanism and a synchronous read are two idependent channels there are potential race condition, depending on the exact protocol.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  The backend has to avoid this if possible. If it cannot be avoided, the implementation must make sure that the last value in the queue is the newest value, and this is not dopped or missed, even if the values before are not in order or send twice.</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;* 9. It does not matter if the exception occured in an asynchronous or synchronous read, or in a write operation.</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;* 9.1.1 Open can be called again on an already opened backend to start error recovery.</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;* 9.1.2 If an asynchronous read transfer is the first one to detect the exception, the implementation must make sure that it is only pushed once into the queue, and informing &quot;all&quot; transfer elememnts with wait_for_new data does not send it again if it was already put into the queue.</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;* 9.1.4 Avoid race conditions here. The call to Device::activateAsyncRead() usually is done from a different thread than the transfer which caused the exception.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;## C. Requirements for all implementations (full and decorator-like) ##</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;* 1. Other exceptions than ChimeraTK::logic_error, ChimeraTK::runtime_error, boost::thread_interrupted and boost::numeric::bad_numeric_cast are not allowed to be thrown or passed through at any place under any circumstance (unless of course they are guaranteed to be caught before they become visible to the application, like the detail::DiscardValueException). The framework (in particular ApplicationCore) may use &quot;uncatchable&quot; exceptions in some places to force the termination of the application. Backend implementations etc. may not do this, since it would lead to uncontrollable behaviour.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;* 2. In doPostXxx no new ChimeraTK::runtime_error or ChimeraTK::logic_error are thrown. *Only* exceptions that were risen in doPreXxx or doXxxTransferYyy, or that were received from the queue (see B.8.3) may be rethrown. This is done by the TransferElement base class in postXxx, so implementations should never actively throw these exceptions in doPostXxx (but decorators must expect exceptions to be thrown by delegated calls).</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;* 3. boost::thread_interrupted may be thrown at any stage, if TransferElement::interrupt has been called.</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;* 4. ChimeraTK::runtime_error in principle are recoverable. A later call to the same function must be able to succeed (for instance if a network outage has been resolved).</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;   ChimeraTK::runtime_erro may only be thrown in </div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  * 4.1 doXxxTransferYyy(). It is the only exception that can occur in this function (except for boost::thread_interrupted)</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  * 4.2 ChimeraTK::TransferElement::isReadable(), ChimeraTK::TransferElement::isWriteable() or ChimeraTK::TransferElement::isReadOnly() if there is no map file or such, and it needs to be determined from the running device.</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;* 5. boost::numeric::bad_numeric_cast may only be thrown in</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  * 5.1 ChimeraTK::TransferElement::doPreWrite()</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  * 5.2 ChimeraTK::TransferElement::doPostRead(), but only if hasNewData == true</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;   * 5.2.1 As the transfer is successful at this point, the currentVersionNumber must be updated as if the whole operation was successful before throwing the exception.</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  * 5.3 This exception can in principle be avoided by chosing a user data type that can fit the data without overflow when reading, or small enough so the process variable can hold the data without overflow when writing. New implementations should not throw this exception. Instead a check should be done in the constructor and a ChimeraTK::logic_error should be thrown (see 6.2.4) (*).</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;* 6. ChimeraTK::logic_error must follow strict conditions.</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  * 6.1 logic_errors must be deterministic. They must always be avoidable by calling the corresponding test functions before executing a potentially failing action (*), and must occur if the logical condition is not fulfilled and the function is called anyway.</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  * 6.2 Any logic_error must be thrown as early as possible(*). They are thrown **if and only if** one of the following conditions are met:</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    * 6.2.1 A register does not exists my that name</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      * 6.2.1.1 Can be checked in the catalogue (*)</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      * 6.2.1.2 Thrown in the constructor if possible (*), otherwise in doPreXxx(), isReadable(), isWriteable() and isReadOnly().</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    * 6.2.2 The size or dimension of the requested TransferElement is too large (*)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      * 6.2.2.1 Can be checked in the catalogue.</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      * 6.2.2.2 Thrown in the constructor if possible, otherwise in doPreXxx().</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    * 6.2.3 The wrong ChimeraTK::AccessMode flags are provided</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      * 6.2.3.1 Can be checked in the catalogue.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      * 6.2.3.2 Thrown in the constructor if possible, otherwise in doPreXxx(), isReadable(), isWriteable() and isReadOnly().</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    * 6.2.4 The requested user data type is to small to hold the data without range overflow when reading, or too big when writing (*)</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      * 6.2.4.1 ToDo: cannot be checked in the catalogue to a sufficient degree</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      * 6.2.4.2 Thrown in the constructor if possible, otherwise in doPreXxx()</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    * 6.2.5 A read/write operation is started while the backend is still closed</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      * 6.2.5.1 Check with ChimeraTK::DeviceBackend::isOpen().</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      * 6.2.5.2 Thrown in doPreXxx() (*)</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    * 6.2.6 A read operation is executed on a transfer element that cannot be read</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      * 6.2.6.1 Check with TransferElement::isReadable().</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;      * 6.2.6.2 Thrown in doPreRead()</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    * 6.2.7 A write operation is executed on a transfer element that cannot be written</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      * 6.2.7.1 Check with TransferElement::isWriteable() or TransferElement::isReadOnly()</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      * 6.2.7.2 Thrown in doPreWrite()</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  * 6.3 Two remarks about how to follow these rules:</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    * 6.3.1 If there is an error in the map file and the backend does not want to fail on this in backend creation, the register must be hidden from the catalogue.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    * 6.3.2 isReadable(), isWriteable() and isReadOnly() might have to check for the existance of the register from a running backend (in case there is no map file). This implies that these calls may throw ChimeraTK::logic_error and ChimeraTK::runtime_error exceptions.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;### (*) Comments ###</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;* 5.3 If there is no map file or such, the information about the target data types must be deretmined from the device. This cannot be done in the constructor if the backend is still closed. In this case the overflow check can happen at runtime and result in a boost::numeric::bad_numeric_cast.</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;* 6.1 Test functions do not yet exist for everything. This needs to be changed!</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;* 6.2 Especially no logic_error must be thrown in doXxxTransferYyy() or doPostXxx(). All tests for logical consistency must be done in doPreXxx() latest.</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;* 6.2.1.1 It is legal to provide &quot;hidden&quot; registers not present in the catalogue, but a register listed in the catalogue must always work.</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;* 6.2.1.2 If a backend cannot decide the existence of a register in the accessor&#39;s constructor (because there is no map file or such, and the backend might be closed), it needs to check the presence later. If the information is available in the constructor, the check has to be done there.</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;* 6.2.2 This also includes that the offset in a one dimensional case is so large that there are not enough elements left to provide the requested data.</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;* 6.2.4 Some backends currenty throw a boost:::numeric::bad_numeric_cast instead as described in 5.</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;* 6.2.5.2 The generic tests if a backend is opened, or if an accessor readable or writeable are intentionally not implemented in TransferElement because they would invovle additional virtual function calls. To avoid these each implementation has to implement the checks in doPreXxx().</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;## D. Requirements for full implementations (e.g. in backends) ##</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;* 1. If ChimeraTK::AccessMode::wait_for_new_data is specified:</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  * 1.1 The ChimeraTK::TransferElement::readQueue is a cppext::future_queue of type &#39;void&#39; which exists in each transfer element. For transfer elements with AccessMode::wait_for_new_data it usually is the continuation queue of another future_queue which is transporting the data. The data type is implementation dependent. Common functionality like exception handling and waiting for new data is implemented on ChimeraTK::TransferElement::readQueue.</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  * 1.2 ChimeraTK::TransferElement::readQueue is initialised in the constructor. [TBD: Allow setting the queue length through the public API?]</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  * 1.3 ChimeraTK::TransferElement::readQueue is pushed whenever new data has arrived. If important for the implementation, the return value of cppext::future_queue::push_overwirte() will tell whether data has been discarded (*).</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  </div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  * 1.4 In case an exception is detected during an asychronous transfer (for instance in a separate thread), the exception must be stored on the ChimeraTK::TransferElement::readQueue. The TransferFuture will then make sure that the exception is properly rethrown in postRead (just like for synchronous transfers).</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;### (*) Comments ###</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;1.3 Either the currently pushed data or older data on the queue might be discarded. In any case there will be one call less to ChimeraTK::TransferElement::doPostRead(), because the number of entries in the queue could not be increased because it was full</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;## E. Requirements for decorator-like implementations ##</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;* 1. If ChimeraTK::AccessMode::wait_for_new_data is specified, ChimeraTK::TransferElement::readQueue is initialised in the constructor with a copy of the readQueue of the target TransferElement.</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  * 1.1 Decorator-like implementations with multiple targets must provide a readQueue e.g. by using cppext::future_queue::when_any() or cppext::future_queue::when_all().</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;* 2. All functions doPreXxx, doXxxTransferYyy and doPostXxx must delegate to their non-do counterparts (preXxx, xxxTransferYyy and postXxx). Never delegate to the do... of the target implementation functions directly.</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;* 3. If a function of the same instance should be called, e.g. if doWriteTransferDestructively() should redirect to doWriteTransfer(), or if doPostRead() should call doPostRead() of a base class, call to do-version of the function. This is merely to avoid code duplication, hence the surrounding logic of the non-do function is not wanted here.</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;* 4. Decorators must merely delegate doXxxTransferYyy, never add any functionalty there. Reason: TransferGroup might effectively bypass the decorator implementation of these functions.</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;* 5. All real decorators are in fact decorators of NDRegisterAccessors&lt;USER_TYPE&gt;. Each decoration level contains one NDRegisterAccessors&lt;USER_TYPE&gt;::buffer_2D. The</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;     decorator implementation must make sure that its buffer is correctly synchronised with the target&#39;s buffer.(*)</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;### (*) Comments ###</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;* 5. The NDRegisterAccessorDecorator base class already contains an implementation which does this in doPreXxx() and doPostXxx(). You usually call it from the Decorators implementation, as mentioned in 3.</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;## F. Implementation in the framework (e.g. class TransferElement itself)</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;**Note:** This section is biased by the current implementation and mostly lists parts that needs to be changed!</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;* 1. **FIXME: Might be wrong witht the re-introduction of readTransferNonBlocking:** The TransferFuture will be kept as is for now to provide backwards compatibility and as a helper to the TransferElement implementation.</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;* 2. TransferElement</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  * 2.1 ChimeraTK::TransferElement::readAsync() is deprecated</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  </div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  * 2.2 **FIXME: Might be wrong with the re-introduction of readTransferNonBlocking:** ChimeraTK::TransferElement::activeFuture is created in the first call to read(), readNonBlockig() or readAsync() from ChimeraTK::TransferElement::readQueue if ChimeraTK::AccessMode::wait_for_new_data is set.</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  </div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  * 2.3 **FIXME: This is wrong with the re-introduction of readTransferNonBlocking:** read(), readNonBlocking() first check whether ChimeraTK::AccessMode::wait_for_new_data is set.</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    * 2.3.1 If no, the sequence of preRead(), readTransfer() and postRead() is executed (cf. 3).</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    * 2.3.1 If yes, implement read() as a sequence of preRead() and activeFuture.wait(), resp. readNonBlocking() as a sequence of preRead(), followed by activeFuture.wait() only if activeFuture.hasNewData() == true.</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  </div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  * 2.4 readLatest() is directly calling readNonBlocking() in a loop.</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  </div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  * 2.5 Add function ChimeraTK::detail::getFutureQueueFromTransferElement(), replacing ChimeraTK::detail::getFutureQueueFromTransferFuture().</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  </div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;* 3. ReadAnyGroup</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  * 3.1 Use the new ChimeraTK::detail::getFutureQueueFromTransferElement().</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;* 4. ApplicationCore</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  * 4.1 For the TestableModeAccessorDecorator: TransferElement::transferFutureWaitCallback() does no longer exist. Instead preRead() will now be called. In case of readAny, multiple calls to preRead() on different accessors will be made on the first call to readAny - the decorator has to deal with that properly.</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="spec___transfer_element_8md.html">spec_TransferElement.md</a></li>
    <li class="footer">Generated on Wed May 20 2020 03:53:09 for ChimeraTK-DeviceAccess by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
