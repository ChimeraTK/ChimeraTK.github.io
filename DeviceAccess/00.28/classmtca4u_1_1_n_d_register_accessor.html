<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mtca4u-deviceaccess: mtca4u::NDRegisterAccessor&lt; UserType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DESY_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mtca4u-deviceaccess
   &#160;<span id="projectnumber">00.28.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemtca4u.html">mtca4u</a></li><li class="navelem"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmtca4u_1_1_n_d_register_accessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mtca4u::NDRegisterAccessor&lt; UserType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>N-dimensional register accessor.  
 <a href="classmtca4u_1_1_n_d_register_accessor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_forward_declarations_8h_source.html">ForwardDeclarations.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mtca4u::NDRegisterAccessor&lt; UserType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmtca4u_1_1_n_d_register_accessor.png" usemap="#mtca4u::NDRegisterAccessor_3C_20UserType_20_3E_map" alt=""/>
  <map id="mtca4u::NDRegisterAccessor_3C_20UserType_20_3E_map" name="mtca4u::NDRegisterAccessor&lt; UserType &gt;_map">
<area href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. " alt="mtca4u::TransferElement" shape="rect" coords="1102,56,1533,80"/>
<area href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html" alt="mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;" shape="rect" coords="0,168,431,192"/>
<area href="classmtca4u_1_1_l_n_m_backend_variable_accessor.html" alt="mtca4u::LNMBackendVariableAccessor&lt; UserType &gt;" shape="rect" coords="441,168,872,192"/>
<area href="classmtca4u_1_1_multiplexed_data_accessor.html" alt="mtca4u::MultiplexedDataAccessor&lt; UserType &gt;" shape="rect" coords="882,168,1313,192"/>
<area href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for multiplexd 2D registers..." alt="mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1323,168,1754,192"/>
<area href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for scalar and 1D registers..." alt="mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;" shape="rect" coords="1764,168,2195,192"/>
<area href="classmtca4u_1_1_scale_register_plugin_register_accessor.html" title="The register accessor used by the ScaleRegisterPlugin. " alt="mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;" shape="rect" coords="2205,168,2636,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c25221f86d205fd8dc1455f117cce9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a0c25221f86d205fd8dc1455f117cce9c">NDRegisterAccessor</a> (std::string const &amp;name, std::string const &amp;unit=std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">TransferElement::unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:a0c25221f86d205fd8dc1455f117cce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a> with the specified name (passed on to the transfer element).  <a href="#a0c25221f86d205fd8dc1455f117cce9c">More...</a><br /></td></tr>
<tr class="separator:a0c25221f86d205fd8dc1455f117cce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddfa3f825d640747c3897a9bf86a745"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6ddfa3f825d640747c3897a9bf86a745">NDRegisterAccessor</a> (const <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a6ddfa3f825d640747c3897a9bf86a745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying and moving is not allowed.  <a href="#a6ddfa3f825d640747c3897a9bf86a745">More...</a><br /></td></tr>
<tr class="separator:a6ddfa3f825d640747c3897a9bf86a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f1bbe0fcb7da3a47fb93f0d0827f35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ad0f1bbe0fcb7da3a47fb93f0d0827f35">NDRegisterAccessor</a> (<a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:ad0f1bbe0fcb7da3a47fb93f0d0827f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822df4071c161dcf41d509a7e6d4ed50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a822df4071c161dcf41d509a7e6d4ed50">operator=</a> (const <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> &amp;other)=delete</td></tr>
<tr class="separator:a822df4071c161dcf41d509a7e6d4ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6919cf836ec5c375b0ee4e731ea2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#afc6919cf836ec5c375b0ee4e731ea2b5">operator=</a> (<a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:afc6919cf836ec5c375b0ee4e731ea2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88f2a3b6f6621915200028bf25dd653"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab88f2a3b6f6621915200028bf25dd653">~NDRegisterAccessor</a> ()</td></tr>
<tr class="memdesc:ab88f2a3b6f6621915200028bf25dd653"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual base class needs a virtual destructor.  <a href="#ab88f2a3b6f6621915200028bf25dd653">More...</a><br /></td></tr>
<tr class="separator:ab88f2a3b6f6621915200028bf25dd653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e3389434ad8f8737ff7050788e146e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a24e3389434ad8f8737ff7050788e146e">shutdown</a> ()</td></tr>
<tr class="memdesc:a24e3389434ad8f8737ff7050788e146e"><td class="mdescLeft">&#160;</td><td class="mdescRight">All implementations must call this function in their destructor.  <a href="#a24e3389434ad8f8737ff7050788e146e">More...</a><br /></td></tr>
<tr class="separator:a24e3389434ad8f8737ff7050788e146e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee7404d3ed5c18ef973d1de0e0d51a6"><td class="memItemLeft" align="right" valign="top">UserType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a7ee7404d3ed5c18ef973d1de0e0d51a6">accessData</a> (unsigned int sample)</td></tr>
<tr class="memdesc:a7ee7404d3ed5c18ef973d1de0e0d51a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's buffer content (1D version).  <a href="#a7ee7404d3ed5c18ef973d1de0e0d51a6">More...</a><br /></td></tr>
<tr class="separator:a7ee7404d3ed5c18ef973d1de0e0d51a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb349b93ebfb50ecdd8d05acf2b817e"><td class="memItemLeft" align="right" valign="top">UserType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a5fb349b93ebfb50ecdd8d05acf2b817e">accessData</a> (unsigned int channel, unsigned int sample)</td></tr>
<tr class="memdesc:a5fb349b93ebfb50ecdd8d05acf2b817e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's buffer content (2D version).  <a href="#a5fb349b93ebfb50ecdd8d05acf2b817e">More...</a><br /></td></tr>
<tr class="separator:a5fb349b93ebfb50ecdd8d05acf2b817e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43c72b7f057bb4b5c49a2d1a18c6291"><td class="memItemLeft" align="right" valign="top">std::vector&lt; UserType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#aa43c72b7f057bb4b5c49a2d1a18c6291">accessChannel</a> (unsigned int channel)</td></tr>
<tr class="memdesc:aa43c72b7f057bb4b5c49a2d1a18c6291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's channel vector.  <a href="#aa43c72b7f057bb4b5c49a2d1a18c6291">More...</a><br /></td></tr>
<tr class="separator:aa43c72b7f057bb4b5c49a2d1a18c6291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bc3aaa9295836e9b57914c727f3fa0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ac1bc3aaa9295836e9b57914c727f3fa0">getNumberOfSamples</a> () const </td></tr>
<tr class="memdesc:ac1bc3aaa9295836e9b57914c727f3fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of elements per channel.  <a href="#ac1bc3aaa9295836e9b57914c727f3fa0">More...</a><br /></td></tr>
<tr class="separator:ac1bc3aaa9295836e9b57914c727f3fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae26e3cf0212552bbcef32d652ca794"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a1ae26e3cf0212552bbcef32d652ca794">getNumberOfChannels</a> () const </td></tr>
<tr class="memdesc:a1ae26e3cf0212552bbcef32d652ca794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of channels.  <a href="#a1ae26e3cf0212552bbcef32d652ca794">More...</a><br /></td></tr>
<tr class="separator:a1ae26e3cf0212552bbcef32d652ca794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7019d19d8f0de92b2f98aabba1a54bdb"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a7019d19d8f0de92b2f98aabba1a54bdb">getValueType</a> () const override</td></tr>
<tr class="memdesc:a7019d19d8f0de92b2f98aabba1a54bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#a7019d19d8f0de92b2f98aabba1a54bdb">More...</a><br /></td></tr>
<tr class="separator:a7019d19d8f0de92b2f98aabba1a54bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de32ce75e92adb3796e1f19605ebc1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a">read</a> () final</td></tr>
<tr class="memdesc:a9de32ce75e92adb3796e1f19605ebc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#a9de32ce75e92adb3796e1f19605ebc1a">More...</a><br /></td></tr>
<tr class="separator:a9de32ce75e92adb3796e1f19605ebc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaab0c60542dd30afbe945a4a6dd74c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6aaab0c60542dd30afbe945a4a6dd74c">readNonBlocking</a> () final</td></tr>
<tr class="memdesc:a6aaab0c60542dd30afbe945a4a6dd74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#a6aaab0c60542dd30afbe945a4a6dd74c">More...</a><br /></td></tr>
<tr class="separator:a6aaab0c60542dd30afbe945a4a6dd74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b88505d198ab828c1dd60d78f7607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#aeb9b88505d198ab828c1dd60d78f7607">readLatest</a> () final</td></tr>
<tr class="memdesc:aeb9b88505d198ab828c1dd60d78f7607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#aeb9b88505d198ab828c1dd60d78f7607">More...</a><br /></td></tr>
<tr class="separator:aeb9b88505d198ab828c1dd60d78f7607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f883f2c5a8573957dfcfe0a769218b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b">readAsync</a> () override</td></tr>
<tr class="memdesc:ab4f883f2c5a8573957dfcfe0a769218b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#ab4f883f2c5a8573957dfcfe0a769218b">More...</a><br /></td></tr>
<tr class="separator:ab4f883f2c5a8573957dfcfe0a769218b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee409160a6ae5f38fefe00fd60b74c9"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a3ee409160a6ae5f38fefe00fd60b74c9">getNInputQueueElements</a> () const </td></tr>
<tr class="memdesc:a3ee409160a6ae5f38fefe00fd60b74c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED DO NOT USE! Instead make a call to <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6aaab0c60542dd30afbe945a4a6dd74c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> and check the return value.  <a href="#a3ee409160a6ae5f38fefe00fd60b74c9">More...</a><br /></td></tr>
<tr class="separator:a3ee409160a6ae5f38fefe00fd60b74c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421728451ad214684469eda96ef2b002"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmtca4u_1_1_fixed_point_converter.html">FixedPointConverter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a421728451ad214684469eda96ef2b002">getFixedPointConverter</a> () const </td></tr>
<tr class="memdesc:a421728451ad214684469eda96ef2b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">DO NOT USE.  <a href="#a421728451ad214684469eda96ef2b002">More...</a><br /></td></tr>
<tr class="separator:a421728451ad214684469eda96ef2b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a9901e666ac60d41473a69bae04859871">TransferElement</a> (std::string const &amp;name=std::string(), std::string const &amp;unit=std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer element with the specified name.  <a href="#a9901e666ac60d41473a69bae04859871">More...</a><br /></td></tr>
<tr class="separator:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a32ac07c9d4fab89208a93016a101898a">TransferElement</a> (const <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &amp;other)</td></tr>
<tr class="memdesc:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: do not allow copying when in <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>, remove asynchronous read state.  <a href="#a32ac07c9d4fab89208a93016a101898a">More...</a><br /></td></tr>
<tr class="separator:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aa578ad1991d6b9763b5cc8096220af0d">~TransferElement</a> ()</td></tr>
<tr class="memdesc:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <a href="#aa578ad1991d6b9763b5cc8096220af0d">More...</a><br /></td></tr>
<tr class="separator:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a1b1ecc0786839b0949f13a4203187e5b">getName</a> () const </td></tr>
<tr class="memdesc:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#a1b1ecc0786839b0949f13a4203187e5b">More...</a><br /></td></tr>
<tr class="separator:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a95f64bf74aed8bb95796dafaff5ddd98">getUnit</a> () const </td></tr>
<tr class="memdesc:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#a95f64bf74aed8bb95796dafaff5ddd98">More...</a><br /></td></tr>
<tr class="separator:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adc66ca9c081ec77cf6d9cc64a4c267fb">getDescription</a> () const </td></tr>
<tr class="memdesc:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#adc66ca9c081ec77cf6d9cc64a4c267fb">More...</a><br /></td></tr>
<tr class="separator:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e7690a5dbba2e34a0fc8f91f4af5ca inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a77e7690a5dbba2e34a0fc8f91f4af5ca">getVersionNumber</a> () const </td></tr>
<tr class="memdesc:a77e7690a5dbba2e34a0fc8f91f4af5ca inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#a77e7690a5dbba2e34a0fc8f91f4af5ca">More...</a><br /></td></tr>
<tr class="separator:a77e7690a5dbba2e34a0fc8f91f4af5ca inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b2fdb9a6dea04fd343edf9511a0159 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a06b2fdb9a6dea04fd343edf9511a0159">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})=0</td></tr>
<tr class="memdesc:a06b2fdb9a6dea04fd343edf9511a0159 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a06b2fdb9a6dea04fd343edf9511a0159">More...</a><br /></td></tr>
<tr class="separator:a06b2fdb9a6dea04fd343edf9511a0159 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb02e2fa3228e645f6ff88d10226381 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a3eb02e2fa3228e645f6ff88d10226381">doReadTransfer</a> ()=0</td></tr>
<tr class="memdesc:a3eb02e2fa3228e645f6ff88d10226381 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a3eb02e2fa3228e645f6ff88d10226381">More...</a><br /></td></tr>
<tr class="separator:a3eb02e2fa3228e645f6ff88d10226381 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad313e332b8bf872eade35bd4cdec9462 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ad313e332b8bf872eade35bd4cdec9462">doReadTransferNonBlocking</a> ()=0</td></tr>
<tr class="memdesc:ad313e332b8bf872eade35bd4cdec9462 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ad313e332b8bf872eade35bd4cdec9462">More...</a><br /></td></tr>
<tr class="separator:ad313e332b8bf872eade35bd4cdec9462 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095ac74aa9aa2fc21baa37d9e07e85e1 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a095ac74aa9aa2fc21baa37d9e07e85e1">doReadTransferLatest</a> ()=0</td></tr>
<tr class="memdesc:a095ac74aa9aa2fc21baa37d9e07e85e1 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a095ac74aa9aa2fc21baa37d9e07e85e1">More...</a><br /></td></tr>
<tr class="separator:a095ac74aa9aa2fc21baa37d9e07e85e1 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab34ce80a5397cdcf8f0ebe69585547 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a2ab34ce80a5397cdcf8f0ebe69585547">preRead</a> ()</td></tr>
<tr class="memdesc:a2ab34ce80a5397cdcf8f0ebe69585547 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any pre-read tasks if necessary.  <a href="#a2ab34ce80a5397cdcf8f0ebe69585547">More...</a><br /></td></tr>
<tr class="separator:a2ab34ce80a5397cdcf8f0ebe69585547 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e189d1260a18cd02ada7a5ba2e44c8 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ad6e189d1260a18cd02ada7a5ba2e44c8">postRead</a> ()</td></tr>
<tr class="memdesc:ad6e189d1260a18cd02ada7a5ba2e44c8 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed.  <a href="#ad6e189d1260a18cd02ada7a5ba2e44c8">More...</a><br /></td></tr>
<tr class="separator:ad6e189d1260a18cd02ada7a5ba2e44c8 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e00e60a19ea7f94ce0d520f335bb4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a986e00e60a19ea7f94ce0d520f335bb4">preWrite</a> ()</td></tr>
<tr class="memdesc:a986e00e60a19ea7f94ce0d520f335bb4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed.  <a href="#a986e00e60a19ea7f94ce0d520f335bb4">More...</a><br /></td></tr>
<tr class="separator:a986e00e60a19ea7f94ce0d520f335bb4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0126b6acdba460cb27676878d10c83a3 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0126b6acdba460cb27676878d10c83a3">postWrite</a> ()</td></tr>
<tr class="memdesc:a0126b6acdba460cb27676878d10c83a3 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any post-write cleanups if necessary.  <a href="#a0126b6acdba460cb27676878d10c83a3">More...</a><br /></td></tr>
<tr class="separator:a0126b6acdba460cb27676878d10c83a3 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74817fa1c4323897f0af32bbc3d57aa5 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a74817fa1c4323897f0af32bbc3d57aa5">isSameRegister</a> (const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;other) const =0</td></tr>
<tr class="memdesc:a74817fa1c4323897f0af32bbc3d57aa5 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two TransferElements are identical, i.e.  <a href="#a74817fa1c4323897f0af32bbc3d57aa5">More...</a><br /></td></tr>
<tr class="separator:a74817fa1c4323897f0af32bbc3d57aa5 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2807cd6932846d6988b9fb645a420e9b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a2807cd6932846d6988b9fb645a420e9b">isReadOnly</a> () const =0</td></tr>
<tr class="memdesc:a2807cd6932846d6988b9fb645a420e9b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <a href="#a2807cd6932846d6988b9fb645a420e9b">More...</a><br /></td></tr>
<tr class="separator:a2807cd6932846d6988b9fb645a420e9b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e803ec5758a3cd2d25a1e743e24d5c inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a55e803ec5758a3cd2d25a1e743e24d5c">isReadable</a> () const =0</td></tr>
<tr class="memdesc:a55e803ec5758a3cd2d25a1e743e24d5c inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#a55e803ec5758a3cd2d25a1e743e24d5c">More...</a><br /></td></tr>
<tr class="separator:a55e803ec5758a3cd2d25a1e743e24d5c inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e9f2ec21138931f5f8c5cdc03c11a4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aa0e9f2ec21138931f5f8c5cdc03c11a4">isWriteable</a> () const =0</td></tr>
<tr class="memdesc:aa0e9f2ec21138931f5f8c5cdc03c11a4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#aa0e9f2ec21138931f5f8c5cdc03c11a4">More...</a><br /></td></tr>
<tr class="separator:aa0e9f2ec21138931f5f8c5cdc03c11a4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmtca4u_1_1_time_stamp.html">TimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aeedfb9d715e3077bad6312238e411998">getTimeStamp</a> () const </td></tr>
<tr class="memdesc:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aeedfb9d715e3077bad6312238e411998">More...</a><br /></td></tr>
<tr class="separator:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aac3faef1e424f7eb1546f1aa7aa34d85">isArray</a> () const </td></tr>
<tr class="memdesc:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aac3faef1e424f7eb1546f1aa7aa34d85">More...</a><br /></td></tr>
<tr class="separator:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c43acb77928d2ccc12829d1b386195b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a4c43acb77928d2ccc12829d1b386195b">getHardwareAccessingElements</a> ()=0</td></tr>
<tr class="memdesc:a4c43acb77928d2ccc12829d1b386195b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a4c43acb77928d2ccc12829d1b386195b">More...</a><br /></td></tr>
<tr class="separator:a4c43acb77928d2ccc12829d1b386195b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174b74892bb5aa866b0be19c73e67542 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a174b74892bb5aa866b0be19c73e67542">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:a174b74892bb5aa866b0be19c73e67542 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a174b74892bb5aa866b0be19c73e67542">More...</a><br /></td></tr>
<tr class="separator:a174b74892bb5aa866b0be19c73e67542 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd708790ccb8388ee8f7d01d6b47220 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#accd708790ccb8388ee8f7d01d6b47220">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; newElement)=0</td></tr>
<tr class="memdesc:accd708790ccb8388ee8f7d01d6b47220 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#accd708790ccb8388ee8f7d01d6b47220">More...</a><br /></td></tr>
<tr class="separator:accd708790ccb8388ee8f7d01d6b47220 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8a0815a31412f1e862dff4bf6b5f90d4">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;)</td></tr>
<tr class="memdesc:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a8a0815a31412f1e862dff4bf6b5f90d4">More...</a><br /></td></tr>
<tr class="separator:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7779fc0a610a11a1b9758a2584fa6ce inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ab7779fc0a610a11a1b9758a2584fa6ce">getId</a> () const </td></tr>
<tr class="memdesc:ab7779fc0a610a11a1b9758a2584fa6ce inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> for this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ab7779fc0a610a11a1b9758a2584fa6ce">More...</a><br /></td></tr>
<tr class="separator:ab7779fc0a610a11a1b9758a2584fa6ce inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad303b70009f4865e9257427e3fb19cd3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; UserType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ad303b70009f4865e9257427e3fb19cd3">buffer_2D</a></td></tr>
<tr class="memdesc:ad303b70009f4865e9257427e3fb19cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer of converted data elements.  <a href="#ad303b70009f4865e9257427e3fb19cd3">More...</a><br /></td></tr>
<tr class="separator:ad303b70009f4865e9257427e3fb19cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28233ce68547ac22042bbf771f8645fe"><td class="memItemLeft" align="right" valign="top">boost::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a28233ce68547ac22042bbf771f8645fe">readAsyncThread</a></td></tr>
<tr class="memdesc:a28233ce68547ac22042bbf771f8645fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread which might be launched in <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>  <a href="#a28233ce68547ac22042bbf771f8645fe">More...</a><br /></td></tr>
<tr class="separator:a28233ce68547ac22042bbf771f8645fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53de00ce15dae98be90d436c369467f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ab39a705c71eac410d1eb1e17ec30494d">TransferFuture::PromiseType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a53de00ce15dae98be90d436c369467f8">readAsyncPromise</a></td></tr>
<tr class="memdesc:a53de00ce15dae98be90d436c369467f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promise used in <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>  <a href="#a53de00ce15dae98be90d436c369467f8">More...</a><br /></td></tr>
<tr class="separator:a53de00ce15dae98be90d436c369467f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112b1b90a1259c55d24a546ec3cf832c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_chimera_t_k_1_1_transfer_future_1_1_data.html">TransferFuture::Data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a112b1b90a1259c55d24a546ec3cf832c">transferFutureData</a> {{}}</td></tr>
<tr class="memdesc:a112b1b90a1259c55d24a546ec3cf832c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transferred in the TransferFuture, used by the default implementation of <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>  <a href="#a112b1b90a1259c55d24a546ec3cf832c">More...</a><br /></td></tr>
<tr class="separator:a112b1b90a1259c55d24a546ec3cf832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a674e1814502195c7545c0d6512f65fcc">_name</a></td></tr>
<tr class="memdesc:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier uniquely identifying the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a674e1814502195c7545c0d6512f65fcc">More...</a><br /></td></tr>
<tr class="separator:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a53051ab33dd295fa8d14007159d5498c">_unit</a></td></tr>
<tr class="memdesc:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engineering unit.  <a href="#a53051ab33dd295fa8d14007159d5498c">More...</a><br /></td></tr>
<tr class="separator:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adaebf84a4baead76fcca5b38bead596a">_description</a></td></tr>
<tr class="memdesc:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of this variable/register.  <a href="#adaebf84a4baead76fcca5b38bead596a">More...</a><br /></td></tr>
<tr class="separator:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472a62db198011226904af5d41aec7b inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a3472a62db198011226904af5d41aec7b">_id</a></td></tr>
<tr class="memdesc:a3472a62db198011226904af5d41aec7b inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a3472a62db198011226904af5d41aec7b">More...</a><br /></td></tr>
<tr class="separator:a3472a62db198011226904af5d41aec7b inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a04f6bbbd0a7230f21c0900541efc5336">isInTransferGroup</a></td></tr>
<tr class="memdesc:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not.  <a href="#a04f6bbbd0a7230f21c0900541efc5336">More...</a><br /></td></tr>
<tr class="separator:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5c05a8d573fc17c6fcc6c0a7874c7 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a82d5c05a8d573fc17c6fcc6c0a7874c7">hasActiveFuture</a> {false}</td></tr>
<tr class="memdesc:a82d5c05a8d573fc17c6fcc6c0a7874c7 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether there is an "active" TransferFuture which was given out by readAync() but its ready state was not yet obtained by the user e.g.  <a href="#a82d5c05a8d573fc17c6fcc6c0a7874c7">More...</a><br /></td></tr>
<tr class="separator:a82d5c05a8d573fc17c6fcc6c0a7874c7 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8194c23ca0a8b08293e6c3410c845bc1 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8194c23ca0a8b08293e6c3410c845bc1">activeFuture</a></td></tr>
<tr class="memdesc:a8194c23ca0a8b08293e6c3410c845bc1 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently "active" future, if hasActiveFuture == true.  <a href="#a8194c23ca0a8b08293e6c3410c845bc1">More...</a><br /></td></tr>
<tr class="separator:a8194c23ca0a8b08293e6c3410c845bc1 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab6255101bca3f241ade8a80d4ae0292f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab6255101bca3f241ade8a80d4ae0292f">MultiplexedDataAccessor&lt; UserType &gt;</a></td></tr>
<tr class="memdesc:ab6255101bca3f241ade8a80d4ae0292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the compatibility layers need access to the buffer_2D  <a href="#ab6255101bca3f241ade8a80d4ae0292f">More...</a><br /></td></tr>
<tr class="separator:ab6255101bca3f241ade8a80d4ae0292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6915d546591b571ef2f0099548c9b726"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6915d546591b571ef2f0099548c9b726">RegisterAccessor</a></td></tr>
<tr class="separator:a6915d546591b571ef2f0099548c9b726"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0db950554a40340e7aeca3249ca2d46d">SharedPtr</a></td></tr>
<tr class="memdesc:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for more compact syntax.  <a href="#a0db950554a40340e7aeca3249ca2d46d">More...</a><br /></td></tr>
<tr class="separator:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:ae22fdbe57951c132c5af6b8634de04fc inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html">TransferElement::ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#ae22fdbe57951c132c5af6b8634de04fc">readAny</a> (std::list&lt; std::reference_wrapper&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&gt; elementsToRead)</td></tr>
<tr class="memdesc:ae22fdbe57951c132c5af6b8634de04fc inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data asynchronously from all given TransferElements and wait until one of the TransferElements has new data.  <a href="#ae22fdbe57951c132c5af6b8634de04fc">More...</a><br /></td></tr>
<tr class="separator:ae22fdbe57951c132c5af6b8634de04fc inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a> [] = &quot;n./a.&quot;</td></tr>
<tr class="memdesc:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant string to be used as a unit when the unit is not provided or known.  <a href="#a05577297da10eba9575c1606efb838b9">More...</a><br /></td></tr>
<tr class="separator:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:af76e8a733a92e5a36ab6466e8fec43d7 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af76e8a733a92e5a36ab6466e8fec43d7">makeUniqueId</a> ()</td></tr>
<tr class="memdesc:af76e8a733a92e5a36ab6466e8fec43d7 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow generating a unique <a class="el" href="classmtca4u_1_1_transfer_element_1_1_i_d.html" title="Simple class holding a unique ID for a TransferElement. ">ID</a> from derived classes.  <a href="#af76e8a733a92e5a36ab6466e8fec43d7">More...</a><br /></td></tr>
<tr class="separator:af76e8a733a92e5a36ab6466e8fec43d7 inherit pro_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename UserType&gt;<br />
class mtca4u::NDRegisterAccessor&lt; UserType &gt;</h3>

<p>N-dimensional register accessor. </p>
<p>Base class for all register accessor implementations. The user frontend classes <a class="el" href="classmtca4u_1_1_buffering_register_accessor.html" title="DEPRECATED! Use OneDRegisterAccessor or ScalarRegisterAccessor instead! ">BufferingRegisterAccessor</a> and <a class="el" href="classmtca4u_1_1_two_d_register_accessor.html" title="TODO add documentation. ">TwoDRegisterAccessor</a> are using implementations based on this class to perform the actual IO. </p>

<p>Definition at line <a class="el" href="_forward_declarations_8h_source.html#l00028">28</a> of file <a class="el" href="_forward_declarations_8h_source.html">ForwardDeclarations.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0c25221f86d205fd8dc1455f117cce9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::<a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">TransferElement::unitNotSet</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a> with the specified name (passed on to the transfer element). </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00030">30</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6ddfa3f825d640747c3897a9bf86a745"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::<a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying and moving is not allowed. </p>

</div>
</div>
<a class="anchor" id="ad0f1bbe0fcb7da3a47fb93f0d0827f35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::<a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab88f2a3b6f6621915200028bf25dd653"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::~<a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A virtual base class needs a virtual destructor. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00045">45</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa43c72b7f057bb4b5c49a2d1a18c6291"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;UserType&gt;&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::accessChannel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or set register accessor's channel vector. </p>
<dl class="section attention"><dt>Attention</dt><dd>No bounds checking is performed, use <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a1ae26e3cf0212552bbcef32d652ca794" title="Return number of channels. ">getNumberOfChannels()</a> to obtain the number of elements in the register. </dd></dl>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00087">87</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ee7404d3ed5c18ef973d1de0e0d51a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UserType&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::accessData </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or set register accessor's buffer content (1D version). </p>
<dl class="section attention"><dt>Attention</dt><dd>No bounds checking is performed, use <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ac1bc3aaa9295836e9b57914c727f3fa0" title="Return number of elements per channel. ">getNumberOfSamples()</a> to obtain the number of elements in the register. </dd></dl>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00073">73</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5fb349b93ebfb50ecdd8d05acf2b817e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UserType&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::accessData </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get or set register accessor's buffer content (2D version). </p>
<dl class="section attention"><dt>Attention</dt><dd>No bounds checking is performed, use <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a1ae26e3cf0212552bbcef32d652ca794" title="Return number of channels. ">getNumberOfChannels()</a> and <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ac1bc3aaa9295836e9b57914c727f3fa0" title="Return number of elements per channel. ">getNumberOfSamples()</a> to obtain the number of channels and samples in the register. </dd></dl>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00080">80</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421728451ad214684469eda96ef2b002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmtca4u_1_1_fixed_point_converter.html">FixedPointConverter</a> <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::getFixedPointConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DO NOT USE. </p>
<p>FOR BACKWARDS COMPATIBILITY ONLY.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>This function is for backwards compatibility with the deprecated <a class="el" href="classmtca4u_1_1_register_accessor.html" title="DEPRECATED! Use BufferingRegisterAccessor instead! ">RegisterAccessor</a> only. Return the fixed point converter used to convert the raw data from the device to the type T. If no conversion by the fixed point converter is required, this function will throw an exception. </dd></dl>

<p>Reimplemented in <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_register_accessor.html#af3c01129d1a2fb2abf57cbc36c511254">mtca4u::NumericAddressedBackendRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_l_n_m_backend_channel_accessor.html#a4cadbfe7763975abc8eb6b07efe678cd">mtca4u::LNMBackendChannelAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_scale_register_plugin_register_accessor.html#a817bf5b11222a6f69fd2dc7c5091a457">mtca4u::ScaleRegisterPluginRegisterAccessor&lt; UserType &gt;</a>, <a class="el" href="classmtca4u_1_1_numeric_addressed_backend_muxed_register_accessor.html#a5a5aece9f568f58678cc855233a4a222">mtca4u::NumericAddressedBackendMuxedRegisterAccessor&lt; UserType &gt;</a>, and <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html#ace039e43e23532b1e48ab668539de375">mtca4u::MultiplexedDataAccessor&lt; UserType &gt;</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00203">203</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ee409160a6ae5f38fefe00fd60b74c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::getNInputQueueElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED DO NOT USE! Instead make a call to <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6aaab0c60542dd30afbe945a4a6dd74c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> and check the return value. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>This function is deprecated, remove it at some point!</dd></dl>
<p>This function was deprecated since it cannot be implemented for lockfree implementations (like the ControlSystemAdapter's ProcessVariable).</p>
<p>Return number of waiting data elements in the queue (or buffer). Use when the accessor was obtained with <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> to obtain the amount of data waiting for retrieval in this accessor. If the returned value is 0, the call to <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a" title="Read the data from the device. ">read()</a> will block until new data has arrived. If the returned value is &gt; 0, it is guaranteed that the next call to <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a" title="Read the data from the device. ">read()</a> will not block. If the accessor was obtained without the <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> flag, this function will always return 1. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00194">194</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ae26e3cf0212552bbcef32d652ca794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::getNumberOfChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of channels. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00097">97</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1bc3aaa9295836e9b57914c727f3fa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::getNumberOfSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of elements per channel. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00092">92</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7019d19d8f0de92b2f98aabba1a54bdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a475c56d5d123fd245ff352808c281ea2">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00101">101</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a822df4071c161dcf41d509a7e6d4ed50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc6919cf836ec5c375b0ee4e731ea2b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9de32ce75e92adb3796e1f19605ebc1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#aff8dfb35106ffe971cb900a87c22a1a3">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00105">105</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f883f2c5a8573957dfcfe0a769218b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6aaab0c60542dd30afbe945a4a6dd74c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6aaab0c60542dd30afbe945a4a6dd74c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElemennt::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread. A reference is returned since we need polymorphism. This is possible since the implementation anyway needs to store the object to be able to return it a second time if <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> is called again before the future is fulfilled.</p>
<p>Note: This feature is still experimental. Expect API changes without notice! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a7483fd20ad5c8c4332368738de10c56b">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00159">159</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb9b88505d198ab828c1dd60d78f7607"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a6aaab0c60542dd30afbe945a4a6dd74c" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a3664a01fdc6f463ad0f0516742000c5c">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00140">140</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6aaab0c60542dd30afbe945a4a6dd74c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a9de32ce75e92adb3796e1f19605ebc1a" title="Read the data from the device. ">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a2165a21cef5394f18d1dcbd227801260">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00122">122</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24e3389434ad8f8737ff7050788e146e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All implementations must call this function in their destructor. </p>
<p>Also, implementations must call it in their constructors before throwing an exception (hint: put catch-all block around the entired constructor, call <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#a24e3389434ad8f8737ff7050788e146e" title="All implementations must call this function in their destructor. ">shutdown()</a> there and then rethrow the exception).</p>
<p>Implementation note: This function call is necessary to ensure that a potentially still-running thread launched in <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> is properly terminated before destroying the accessor object. Since this thread accesses virtual functions like <a class="el" href="classmtca4u_1_1_transfer_element.html#a3eb02e2fa3228e645f6ff88d10226381" title="Read the data from the device but do not fill it into the user buffer of this TransferElement. ">doReadTransfer()</a>, the full accessor object must still be alive, thus shutting down the thread in the base class destructor is too late. Technically, implementations overriding <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> would not need to call this function, but to make sure all implementations which do not override <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> actually call it, the function call is enforced for all implementations in the destructor with an assert. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00062">62</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ab6255101bca3f241ade8a80d4ae0292f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmtca4u_1_1_multiplexed_data_accessor.html">MultiplexedDataAccessor</a>&lt; UserType &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the compatibility layers need access to the buffer_2D </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00218">218</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6915d546591b571ef2f0099548c9b726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmtca4u_1_1_register_accessor.html">RegisterAccessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00219">219</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad303b70009f4865e9257427e3fb19cd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;UserType&gt; &gt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::buffer_2D</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer of converted data elements. </p>
<p>The buffer is always two dimensional. If a register with a single dimension should be accessed, the outer vector has only a single element. For a scalar register, only a single element is present in total (buffer_2D[0][0]). This has a negligible performance impact when optimisations are enabled, but allows a coherent interface for all accessors independent of their dimension.</p>
<p>Implementation note: The buffer must be created with the right number of elements in the constructor! </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00215">215</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53de00ce15dae98be90d436c369467f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ab39a705c71eac410d1eb1e17ec30494d">TransferFuture::PromiseType</a> <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::readAsyncPromise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promise used in <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00225">225</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a28233ce68547ac22042bbf771f8645fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::thread <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::readAsyncThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread which might be launched in <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00222">222</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a112b1b90a1259c55d24a546ec3cf832c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_chimera_t_k_1_1_transfer_future_1_1_data.html">TransferFuture::Data</a> <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">mtca4u::NDRegisterAccessor</a>&lt; UserType &gt;::transferFutureData {{}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data transferred in the TransferFuture, used by the default implementation of <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html#ab4f883f2c5a8573957dfcfe0a769218b" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_8h_source.html#l00228">228</a> of file <a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device/include/<a class="el" href="_forward_declarations_8h_source.html">ForwardDeclarations.h</a></li>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device_backends/include/<a class="el" href="_n_d_register_accessor_8h_source.html">NDRegisterAccessor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 14 2017 06:17:18 for mtca4u-deviceaccess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
