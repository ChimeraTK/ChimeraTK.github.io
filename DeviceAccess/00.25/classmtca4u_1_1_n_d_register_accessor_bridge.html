<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>mtca4u-deviceaccess: mtca4u::NDRegisterAccessorBridge&lt; UserType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DESY_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mtca4u-deviceaccess
   &#160;<span id="projectnumber">00.25.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemtca4u.html">mtca4u</a></li><li class="navelem"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">NDRegisterAccessorBridge</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmtca4u_1_1_n_d_register_accessor_bridge-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mtca4u::NDRegisterAccessorBridge&lt; UserType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for the reigster accessor bridges (<a class="el" href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a>, <a class="el" href="classmtca4u_1_1_one_d_register_accessor.html" title="Accessor class to read and write registers transparently by using the accessor object like a vector o...">OneDRegisterAccessor</a> and <a class="el" href="classmtca4u_1_1_two_d_register_accessor.html" title="TODO add documentation. ">TwoDRegisterAccessor</a>).  
 <a href="classmtca4u_1_1_n_d_register_accessor_bridge.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmtca4u_1_1_n_d_register_accessor_bridge.png" usemap="#mtca4u::NDRegisterAccessorBridge_3C_20UserType_20_3E_map" alt=""/>
  <map id="mtca4u::NDRegisterAccessorBridge_3C_20UserType_20_3E_map" name="mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;_map">
<area href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. " alt="mtca4u::TransferElement" shape="rect" coords="474,56,780,80"/>
<area href="classmtca4u_1_1_buffering_register_accessor.html" title="DEPRECATED! Use OneDRegisterAccessor or ScalarRegisterAccessor instead! " alt="mtca4u::BufferingRegisterAccessor&lt; UserType &gt;" shape="rect" coords="0,168,306,192"/>
<area href="classmtca4u_1_1_one_d_register_accessor.html" title="Accessor class to read and write registers transparently by using the accessor object like a vector o..." alt="mtca4u::OneDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="316,168,622,192"/>
<area href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v..." alt="mtca4u::ScalarRegisterAccessor&lt; UserType &gt;" shape="rect" coords="632,168,938,192"/>
<area href="classmtca4u_1_1_two_d_register_accessor.html" title="TODO add documentation. " alt="mtca4u::TwoDRegisterAccessor&lt; UserType &gt;" shape="rect" coords="948,168,1254,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb2496201ced6787f1f1ebb9a5b96096"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#abb2496201ced6787f1f1ebb9a5b96096">getNInputQueueElements</a> () const </td></tr>
<tr class="memdesc:abb2496201ced6787f1f1ebb9a5b96096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of waiting data elements in the queue (or buffer).  <a href="#abb2496201ced6787f1f1ebb9a5b96096">More...</a><br /></td></tr>
<tr class="separator:abb2496201ced6787f1f1ebb9a5b96096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa542896c14145a27faca963b82967dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#aa542896c14145a27faca963b82967dc7">replace</a> (const <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">NDRegisterAccessorBridge</a>&lt; UserType &gt; &amp;newAccessor)</td></tr>
<tr class="memdesc:aa542896c14145a27faca963b82967dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new accessor to this <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html" title="Base class for the reigster accessor bridges (ScalarRegisterAccessor, OneDRegisterAccessor and TwoDRe...">NDRegisterAccessorBridge</a>.  <a href="#aa542896c14145a27faca963b82967dc7">More...</a><br /></td></tr>
<tr class="separator:aa542896c14145a27faca963b82967dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022e8519779563bb271c2b643dde7d71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a022e8519779563bb271c2b643dde7d71">replace</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt;&gt; newImpl)</td></tr>
<tr class="memdesc:a022e8519779563bb271c2b643dde7d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature of relace() with the same functionality, used when a pointer to the implementation has been obtained directly (instead of a <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html" title="Base class for the reigster accessor bridges (ScalarRegisterAccessor, OneDRegisterAccessor and TwoDRe...">NDRegisterAccessorBridge</a>).  <a href="#a022e8519779563bb271c2b643dde7d71">More...</a><br /></td></tr>
<tr class="separator:a022e8519779563bb271c2b643dde7d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f3ee31e19c43ee4db44bf14426e515"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a67f3ee31e19c43ee4db44bf14426e515">isInitialised</a> () const </td></tr>
<tr class="memdesc:a67f3ee31e19c43ee4db44bf14426e515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the accessor is properly initialised.  <a href="#a67f3ee31e19c43ee4db44bf14426e515">More...</a><br /></td></tr>
<tr class="separator:a67f3ee31e19c43ee4db44bf14426e515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828b08e88b2854a151f2a393d545dabc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a828b08e88b2854a151f2a393d545dabc">doReadTransfer</a> () override</td></tr>
<tr class="memdesc:a828b08e88b2854a151f2a393d545dabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a828b08e88b2854a151f2a393d545dabc">More...</a><br /></td></tr>
<tr class="separator:a828b08e88b2854a151f2a393d545dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982735c311b461350c53b39fd5302881"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a982735c311b461350c53b39fd5302881">doReadTransferNonBlocking</a> () override</td></tr>
<tr class="memdesc:a982735c311b461350c53b39fd5302881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a982735c311b461350c53b39fd5302881">More...</a><br /></td></tr>
<tr class="separator:a982735c311b461350c53b39fd5302881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33dc545449852faa5dec4b872b0c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a7e33dc545449852faa5dec4b872b0c5f">doReadTransferLatest</a> () override</td></tr>
<tr class="memdesc:a7e33dc545449852faa5dec4b872b0c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a7e33dc545449852faa5dec4b872b0c5f">More...</a><br /></td></tr>
<tr class="separator:a7e33dc545449852faa5dec4b872b0c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3db1e3b1e0b55f22a7906a654017034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#ac3db1e3b1e0b55f22a7906a654017034">postRead</a> () override</td></tr>
<tr class="memdesc:ac3db1e3b1e0b55f22a7906a654017034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed.  <a href="#ac3db1e3b1e0b55f22a7906a654017034">More...</a><br /></td></tr>
<tr class="separator:ac3db1e3b1e0b55f22a7906a654017034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94bc4809d5ba2e539b7de23d7567692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#af94bc4809d5ba2e539b7de23d7567692">readAsync</a> () override</td></tr>
<tr class="memdesc:af94bc4809d5ba2e539b7de23d7567692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#af94bc4809d5ba2e539b7de23d7567692">More...</a><br /></td></tr>
<tr class="separator:af94bc4809d5ba2e539b7de23d7567692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce5978a17802052818e1d7e878c7289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#adce5978a17802052818e1d7e878c7289">getVersionNumber</a> () const override</td></tr>
<tr class="memdesc:adce5978a17802052818e1d7e878c7289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#adce5978a17802052818e1d7e878c7289">More...</a><br /></td></tr>
<tr class="separator:adce5978a17802052818e1d7e878c7289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076480948f741845acfc1cc941e94862"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a076480948f741845acfc1cc941e94862">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={}) override</td></tr>
<tr class="memdesc:a076480948f741845acfc1cc941e94862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a076480948f741845acfc1cc941e94862">More...</a><br /></td></tr>
<tr class="separator:a076480948f741845acfc1cc941e94862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40abca9a32c6aba5b7414edd754a4775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a40abca9a32c6aba5b7414edd754a4775">isReadOnly</a> () const override</td></tr>
<tr class="memdesc:a40abca9a32c6aba5b7414edd754a4775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the register accessor allows only reading.  <a href="#a40abca9a32c6aba5b7414edd754a4775">More...</a><br /></td></tr>
<tr class="separator:a40abca9a32c6aba5b7414edd754a4775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02f4ec33234254feccbd55dd9c66685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#af02f4ec33234254feccbd55dd9c66685">isReadable</a> () const override</td></tr>
<tr class="memdesc:af02f4ec33234254feccbd55dd9c66685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#af02f4ec33234254feccbd55dd9c66685">More...</a><br /></td></tr>
<tr class="separator:af02f4ec33234254feccbd55dd9c66685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d471aa50dd373f91123215bd21d20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a89d471aa50dd373f91123215bd21d20b">isWriteable</a> () const override</td></tr>
<tr class="memdesc:a89d471aa50dd373f91123215bd21d20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#a89d471aa50dd373f91123215bd21d20b">More...</a><br /></td></tr>
<tr class="separator:a89d471aa50dd373f91123215bd21d20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbdb8c9e0d1c9370c0c2f5db85b9df6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a8dbdb8c9e0d1c9370c0c2f5db85b9df6">isSameRegister</a> (const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;other) const override</td></tr>
<tr class="memdesc:a8dbdb8c9e0d1c9370c0c2f5db85b9df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two TransferElements are identical, i.e.  <a href="#a8dbdb8c9e0d1c9370c0c2f5db85b9df6">More...</a><br /></td></tr>
<tr class="separator:a8dbdb8c9e0d1c9370c0c2f5db85b9df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297307b218bde43d5ab0762967403c55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a297307b218bde43d5ab0762967403c55">getHardwareAccessingElements</a> () override</td></tr>
<tr class="memdesc:a297307b218bde43d5ab0762967403c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a297307b218bde43d5ab0762967403c55">More...</a><br /></td></tr>
<tr class="separator:a297307b218bde43d5ab0762967403c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ca83441bc319ec3713d572cfb42173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a14ca83441bc319ec3713d572cfb42173">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt; newElement) override</td></tr>
<tr class="memdesc:a14ca83441bc319ec3713d572cfb42173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a14ca83441bc319ec3713d572cfb42173">More...</a><br /></td></tr>
<tr class="separator:a14ca83441bc319ec3713d572cfb42173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef07ab0aad73ba295dabb7acbdd759a"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a8ef07ab0aad73ba295dabb7acbdd759a">getHighLevelImplElement</a> () override</td></tr>
<tr class="memdesc:a8ef07ab0aad73ba295dabb7acbdd759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a8ef07ab0aad73ba295dabb7acbdd759a">More...</a><br /></td></tr>
<tr class="separator:a8ef07ab0aad73ba295dabb7acbdd759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec246234229b9f6662390455a16525f"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#aaec246234229b9f6662390455a16525f">getValueType</a> () const override</td></tr>
<tr class="memdesc:aaec246234229b9f6662390455a16525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#aaec246234229b9f6662390455a16525f">More...</a><br /></td></tr>
<tr class="separator:aaec246234229b9f6662390455a16525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a9901e666ac60d41473a69bae04859871">TransferElement</a> (std::string const &amp;name=std::string(), std::string const &amp;unit=std::string(<a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer element with the specified name.  <a href="#a9901e666ac60d41473a69bae04859871">More...</a><br /></td></tr>
<tr class="separator:a9901e666ac60d41473a69bae04859871 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a32ac07c9d4fab89208a93016a101898a">TransferElement</a> (const <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &amp;other)</td></tr>
<tr class="memdesc:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: do not allow copying when in <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>, remove asynchronous read state.  <a href="#a32ac07c9d4fab89208a93016a101898a">More...</a><br /></td></tr>
<tr class="separator:a32ac07c9d4fab89208a93016a101898a inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aa578ad1991d6b9763b5cc8096220af0d">~TransferElement</a> ()</td></tr>
<tr class="memdesc:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <a href="#aa578ad1991d6b9763b5cc8096220af0d">More...</a><br /></td></tr>
<tr class="separator:aa578ad1991d6b9763b5cc8096220af0d inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a1b1ecc0786839b0949f13a4203187e5b">getName</a> () const </td></tr>
<tr class="memdesc:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#a1b1ecc0786839b0949f13a4203187e5b">More...</a><br /></td></tr>
<tr class="separator:a1b1ecc0786839b0949f13a4203187e5b inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a95f64bf74aed8bb95796dafaff5ddd98">getUnit</a> () const </td></tr>
<tr class="memdesc:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#a95f64bf74aed8bb95796dafaff5ddd98">More...</a><br /></td></tr>
<tr class="separator:a95f64bf74aed8bb95796dafaff5ddd98 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adc66ca9c081ec77cf6d9cc64a4c267fb">getDescription</a> () const </td></tr>
<tr class="memdesc:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#adc66ca9c081ec77cf6d9cc64a4c267fb">More...</a><br /></td></tr>
<tr class="separator:adc66ca9c081ec77cf6d9cc64a4c267fb inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6bfac3968093e94171e76123f382dd inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd">read</a> ()</td></tr>
<tr class="memdesc:a9a6bfac3968093e94171e76123f382dd inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#a9a6bfac3968093e94171e76123f382dd">More...</a><br /></td></tr>
<tr class="separator:a9a6bfac3968093e94171e76123f382dd inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2ea63a93acb6b93af71c1882a6154 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:a39c2ea63a93acb6b93af71c1882a6154 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#a39c2ea63a93acb6b93af71c1882a6154">More...</a><br /></td></tr>
<tr class="separator:a39c2ea63a93acb6b93af71c1882a6154 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6114d163656e92a02b901c8d7ddc346 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#af6114d163656e92a02b901c8d7ddc346">readLatest</a> ()</td></tr>
<tr class="memdesc:af6114d163656e92a02b901c8d7ddc346 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#af6114d163656e92a02b901c8d7ddc346">More...</a><br /></td></tr>
<tr class="separator:af6114d163656e92a02b901c8d7ddc346 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e00e60a19ea7f94ce0d520f335bb4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a986e00e60a19ea7f94ce0d520f335bb4">preWrite</a> ()</td></tr>
<tr class="memdesc:a986e00e60a19ea7f94ce0d520f335bb4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed.  <a href="#a986e00e60a19ea7f94ce0d520f335bb4">More...</a><br /></td></tr>
<tr class="separator:a986e00e60a19ea7f94ce0d520f335bb4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0126b6acdba460cb27676878d10c83a3 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0126b6acdba460cb27676878d10c83a3">postWrite</a> ()</td></tr>
<tr class="memdesc:a0126b6acdba460cb27676878d10c83a3 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any post-write cleanups if necessary.  <a href="#a0126b6acdba460cb27676878d10c83a3">More...</a><br /></td></tr>
<tr class="separator:a0126b6acdba460cb27676878d10c83a3 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmtca4u_1_1_time_stamp.html">TimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aeedfb9d715e3077bad6312238e411998">getTimeStamp</a> () const </td></tr>
<tr class="memdesc:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aeedfb9d715e3077bad6312238e411998">More...</a><br /></td></tr>
<tr class="separator:aeedfb9d715e3077bad6312238e411998 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#aac3faef1e424f7eb1546f1aa7aa34d85">isArray</a> () const </td></tr>
<tr class="memdesc:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated, do not use.  <a href="#aac3faef1e424f7eb1546f1aa7aa34d85">More...</a><br /></td></tr>
<tr class="separator:aac3faef1e424f7eb1546f1aa7aa34d85 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8a0815a31412f1e862dff4bf6b5f90d4">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;)</td></tr>
<tr class="memdesc:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a8a0815a31412f1e862dff4bf6b5f90d4">More...</a><br /></td></tr>
<tr class="separator:a8a0815a31412f1e862dff4bf6b5f90d4 inherit pub_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1208e1b695c1ba9f5b14cf565948a724"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a1208e1b695c1ba9f5b14cf565948a724">NDRegisterAccessorBridge</a> (boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &gt; impl)</td></tr>
<tr class="separator:a1208e1b695c1ba9f5b14cf565948a724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d9063a0ea8a4a0262b15bbc1255170"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a41d9063a0ea8a4a0262b15bbc1255170">NDRegisterAccessorBridge</a> ()</td></tr>
<tr class="separator:a41d9063a0ea8a4a0262b15bbc1255170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7c339e960c7ea1e2c181993200369004"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a7c339e960c7ea1e2c181993200369004">_impl</a></td></tr>
<tr class="memdesc:a7c339e960c7ea1e2c181993200369004"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the implementation  <a href="#a7c339e960c7ea1e2c181993200369004">More...</a><br /></td></tr>
<tr class="separator:a7c339e960c7ea1e2c181993200369004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a674e1814502195c7545c0d6512f65fcc">_name</a></td></tr>
<tr class="memdesc:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier uniquely identifying the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a674e1814502195c7545c0d6512f65fcc">More...</a><br /></td></tr>
<tr class="separator:a674e1814502195c7545c0d6512f65fcc inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a53051ab33dd295fa8d14007159d5498c">_unit</a></td></tr>
<tr class="memdesc:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engineering unit.  <a href="#a53051ab33dd295fa8d14007159d5498c">More...</a><br /></td></tr>
<tr class="separator:a53051ab33dd295fa8d14007159d5498c inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#adaebf84a4baead76fcca5b38bead596a">_description</a></td></tr>
<tr class="memdesc:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of this variable/register.  <a href="#adaebf84a4baead76fcca5b38bead596a">More...</a><br /></td></tr>
<tr class="separator:adaebf84a4baead76fcca5b38bead596a inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a04f6bbbd0a7230f21c0900541efc5336">isInTransferGroup</a></td></tr>
<tr class="memdesc:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> has been added to a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> or not.  <a href="#a04f6bbbd0a7230f21c0900541efc5336">More...</a><br /></td></tr>
<tr class="separator:a04f6bbbd0a7230f21c0900541efc5336 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5c05a8d573fc17c6fcc6c0a7874c7 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a82d5c05a8d573fc17c6fcc6c0a7874c7">hasActiveFuture</a> {false}</td></tr>
<tr class="memdesc:a82d5c05a8d573fc17c6fcc6c0a7874c7 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether there is an "active" TransferFuture which was given out by readAync() but its ready state was not yet obtained by the user e.g.  <a href="#a82d5c05a8d573fc17c6fcc6c0a7874c7">More...</a><br /></td></tr>
<tr class="separator:a82d5c05a8d573fc17c6fcc6c0a7874c7 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8194c23ca0a8b08293e6c3410c845bc1 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a8194c23ca0a8b08293e6c3410c845bc1">activeFuture</a></td></tr>
<tr class="memdesc:a8194c23ca0a8b08293e6c3410c845bc1 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently "active" future, if hasActiveFuture == true.  <a href="#a8194c23ca0a8b08293e6c3410c845bc1">More...</a><br /></td></tr>
<tr class="separator:a8194c23ca0a8b08293e6c3410c845bc1 inherit pro_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a0db950554a40340e7aeca3249ca2d46d">SharedPtr</a></td></tr>
<tr class="memdesc:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for more compact syntax.  <a href="#a0db950554a40340e7aeca3249ca2d46d">More...</a><br /></td></tr>
<tr class="separator:a0db950554a40340e7aeca3249ca2d46d inherit pub_types_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a35198ee418b6e37c4d1858a18eda6d0f inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">static boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a35198ee418b6e37c4d1858a18eda6d0f">readAny</a> (std::list&lt; std::reference_wrapper&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&gt; elementsToRead)</td></tr>
<tr class="memdesc:a35198ee418b6e37c4d1858a18eda6d0f inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data asynchronously from all given TransferElements and wait until one of the TransferElements has new data.  <a href="#a35198ee418b6e37c4d1858a18eda6d0f">More...</a><br /></td></tr>
<tr class="separator:a35198ee418b6e37c4d1858a18eda6d0f inherit pub_static_methods_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classmtca4u_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classmtca4u_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classmtca4u_1_1_transfer_element.html">mtca4u::TransferElement</a></td></tr>
<tr class="memitem:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmtca4u_1_1_transfer_element.html#a05577297da10eba9575c1606efb838b9">unitNotSet</a> [] = &quot;n./a.&quot;</td></tr>
<tr class="memdesc:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant string to be used as a unit when the unit is not provided or known.  <a href="#a05577297da10eba9575c1606efb838b9">More...</a><br /></td></tr>
<tr class="separator:a05577297da10eba9575c1606efb838b9 inherit pub_static_attribs_classmtca4u_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename UserType&gt;<br />
class mtca4u::NDRegisterAccessorBridge&lt; UserType &gt;</h3>

<p>Base class for the reigster accessor bridges (<a class="el" href="classmtca4u_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a>, <a class="el" href="classmtca4u_1_1_one_d_register_accessor.html" title="Accessor class to read and write registers transparently by using the accessor object like a vector o...">OneDRegisterAccessor</a> and <a class="el" href="classmtca4u_1_1_two_d_register_accessor.html" title="TODO add documentation. ">TwoDRegisterAccessor</a>). </p>
<p>Provides a private implementation of the <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> interface to allow the bridges to be added to a <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a>. Also stores the shared pointer to the <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a> implementation. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00021">21</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1208e1b695c1ba9f5b14cf565948a724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::<a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">NDRegisterAccessorBridge</a> </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &gt;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00123">123</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a41d9063a0ea8a4a0262b15bbc1255170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::<a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">NDRegisterAccessorBridge</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00127">127</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a828b08e88b2854a151f2a393d545dabc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::doReadTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function followed by <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#ac3db1e3b1e0b55f22a7906a654017034" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a>.</p>
<p>Implementation note: This function must return within ~1 second after boost::thread::interrupt() has been called on the thread calling this function. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a3eb02e2fa3228e645f6ff88d10226381">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00055">55</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e33dc545449852faa5dec4b872b0c5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::doReadTransferLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function followed by <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#ac3db1e3b1e0b55f22a7906a654017034" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_transfer_element.html#af6114d163656e92a02b901c8d7ddc346" title="Read the latest value, discarding any other update since the last read if present. ">readLatest()</a>. For the return value, see <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a095ac74aa9aa2fc21baa37d9e07e85e1">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00063">63</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a982735c311b461350c53b39fd5302881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::doReadTransferNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device without blocking but do not fill it into the user buffer of this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Calling this function followed by <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#ac3db1e3b1e0b55f22a7906a654017034" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> is exactly equivalent to a call to just <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. For the return value, see <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#ad313e332b8bf872eade35bd4cdec9462">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00059">59</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a297307b218bde43d5ab0762967403c55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; &gt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a4c43acb77928d2ccc12829d1b386195b">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00100">100</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8ef07ab0aad73ba295dabb7acbdd759a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a>&gt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::getHighLevelImplElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the highest level implementation <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>For TransferElements which are itself an implementation this will directly return a shared pointer to this. If this <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is a user frontend, the pointer to the internal implementation is returned.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Reimplemented from <a class="el" href="classmtca4u_1_1_transfer_element.html#a174b74892bb5aa866b0be19c73e67542">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00113">113</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb2496201ced6787f1f1ebb9a5b96096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::getNInputQueueElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of waiting data elements in the queue (or buffer). </p>
<p>Use when the accessor was obtained with <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> to obtain the amount of data waiting for retrieval in this accessor. If the returned value is 0, the call to <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> will block until new data has arrived. If the returned value is &gt; 0, it is guaranteed that the next call to <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> will not block. If the accessor was obtained without the <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> flag, this function will always return 1. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00030">30</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaec246234229b9f6662390455a16525f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a475c56d5d123fd245ff352808c281ea2">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00117">117</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="adce5978a17802052818e1d7e878c7289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::getVersionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version number that is associated with the last transfer (i.e. </p>
<p>last read or write). See <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">ChimeraTK::VersionNumber</a> for details.</p>
<p>The returned version number may be invalid (i.e. ChimeraTK::VersionNumber::isValid() returns false), if <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> as not been specified. If <a class="el" href="namespacemtca4u.html#a46449a2e75616026f5c97696929c6cb5aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was specified, a valid version number must be returned (either obtained from the ChimeraTK::VersionNumberSource or derived from an existing version number e.g. of another variable). </p>

<p>Reimplemented from <a class="el" href="classmtca4u_1_1_transfer_element.html#a77e7690a5dbba2e34a0fc8f91f4af5ca">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00075">75</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67f3ee31e19c43ee4db44bf14426e515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::isInitialised </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the accessor is properly initialised. </p>
<p>It is initialised if it was constructed passing the pointer to an implementation (a <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a>), it is not initialised if it was constructed only using the placeholder constructor without arguments. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00051">51</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="af02f4ec33234254feccbd55dd9c66685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#af02f4ec33234254feccbd55dd9c66685" title="Check if transfer element is readable. ">isReadable()</a> is not true. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a55e803ec5758a3cd2d25a1e743e24d5c">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00088">88</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40abca9a32c6aba5b7414edd754a4775"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the register accessor allows only reading. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a2807cd6932846d6988b9fb645a420e9b">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00084">84</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8dbdb8c9e0d1c9370c0c2f5db85b9df6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::isSameRegister </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> const  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the two TransferElements are identical, i.e. </p>
<p>accessing the same hardware register. The definition of an "hardware register" is strongly depending on the backend implementation, thus using this function in application code will probably break the abstraction!</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>Rename this function to something more appropriate (e.g. mayJoinTransfer?) </dd></dl>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a74817fa1c4323897f0af32bbc3d57aa5">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00096">96</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89d471aa50dd373f91123215bd21d20b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#a89d471aa50dd373f91123215bd21d20b" title="Check if transfer element is writeable. ">isWriteable()</a> is not true. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#aa0e9f2ec21138931f5f8c5cdc03c11a4">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00092">92</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac3db1e3b1e0b55f22a7906a654017034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::postRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed. </p>
<p>Called by the <a class="el" href="classmtca4u_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group. ">TransferGroup</a> after a read was executed directly on the underlying accessor. This function must be implemented to extract the read data from the underlying accessor and expose it to the user. </p>

<p>Reimplemented from <a class="el" href="classmtca4u_1_1_transfer_element.html#ad6e189d1260a18cd02ada7a5ba2e44c8">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00067">67</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="af94bc4809d5ba2e539b7de23d7567692"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&amp; <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> or <a class="el" href="classmtca4u_1_1_transfer_element.html#a39c2ea63a93acb6b93af71c1882a6154" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="classmtca4u_1_1_transfer_element.html#a9a6bfac3968093e94171e76123f382dd" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElemennt::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread. A reference is returned since we need polymorphism. This is possible since the implementation anyway needs to store the object to be able to return it a second time if <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html#af94bc4809d5ba2e539b7de23d7567692" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a> is called again before the future is fulfilled.</p>
<p>Note: This feature is still experimental. Expect API changes without notice! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a7483fd20ad5c8c4332368738de10c56b">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00071">71</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa542896c14145a27faca963b82967dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">NDRegisterAccessorBridge</a>&lt; UserType &gt; &amp;&#160;</td>
          <td class="paramname"><em>newAccessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new accessor to this <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html" title="Base class for the reigster accessor bridges (ScalarRegisterAccessor, OneDRegisterAccessor and TwoDRe...">NDRegisterAccessorBridge</a>. </p>
<p>Since another <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html" title="Base class for the reigster accessor bridges (ScalarRegisterAccessor, OneDRegisterAccessor and TwoDRe...">NDRegisterAccessorBridge</a> is passed as argument, both NDRegisterAccessorBridges will then point to the same accessor and thus are sharing the same buffer. To obtain a new copy of the accessor with a distinct buffer, the corresponding getXXRegisterAccessor() function of <a class="el" href="classmtca4u_1_1_device.html" title="Class allows to read/write registers from device. ">Device</a> must be called. </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00038">38</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a022e8519779563bb271c2b643dde7d71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt;&gt;&#160;</td>
          <td class="paramname"><em>newImpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative signature of relace() with the same functionality, used when a pointer to the implementation has been obtained directly (instead of a <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html" title="Base class for the reigster accessor bridges (ScalarRegisterAccessor, OneDRegisterAccessor and TwoDRe...">NDRegisterAccessorBridge</a>). </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00044">44</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a14ca83441bc319ec3713d572cfb42173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identicel (see sameRegister()) with the given <a class="el" href="classmtca4u_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#accd708790ccb8388ee8f7d01d6b47220">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00104">104</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a076480948f741845acfc1cc941e94862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>

<p>Implements <a class="el" href="classmtca4u_1_1_transfer_element.html#a06b2fdb9a6dea04fd343edf9511a0159">mtca4u::TransferElement</a>.</p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00079">79</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7c339e960c7ea1e2c181993200369004"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt;UserType&gt; &gt; <a class="el" href="classmtca4u_1_1_n_d_register_accessor_bridge.html">mtca4u::NDRegisterAccessorBridge</a>&lt; UserType &gt;::_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the implementation </p>

<p>Definition at line <a class="el" href="_n_d_register_accessor_bridge_8h_source.html#l00130">130</a> of file <a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/msk_jenkins/workspace/ChimeraTK_documentation_update/checkouts/DeviceAccess/device/include/<a class="el" href="_n_d_register_accessor_bridge_8h_source.html">NDRegisterAccessorBridge.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 15 2017 06:14:19 for mtca4u-deviceaccess by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
